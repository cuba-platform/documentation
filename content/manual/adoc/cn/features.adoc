[[features]]
=== Platform Features

This section provides overview on various optional features provided by the platform.

[[dynamic_attributes]]
==== Dynamic Attributes

_Dynamic attributes_ are additional entity attributes, that can be added without changing the database schema and restarting the application. Dynamic attributes are usually used to define new entity properties at deployment or production stage.

CUBA dynamic attributes implement the link:$$https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model$$[Entity-Attribute-Value] model.

.Dynamic Attributes Classes Diagram
image::dynamic_attributes.png[align="center"]

*  `Category` - defines a _category_ of objects and the corresponding set of dynamic attributes. The category must be assigned to some entity type.
+
For example, there is an entity of the Car type. We can define two categories for it: Truck and Passenger. The Truck category will contain Load Capacity and Body Type attributes, and the Passenger category â€“ Number of Seats and Child Seat.

*  `CategoryAttribute` - defines a dynamic attribute related to some category. Each attribute describes a single field of a definite type. The required `Code` field contains the system name of the attribute. The `Name` field contains the human-readable attribute name.

*  `CategoryAttributeValue` - dynamic attribute value for a particular entity instance. Dynamic attribute values are physically stored in the dedicated `++SYS_ATTR_VALUE++` table. Each table record has a reference to some entity (`++ENTITY_ID++` column).

An entity instance can have dynamic attributes of all categories related to the entity type. So if you create two categories of the Car entity mentioned above, you will be able to specify any dynamic attribute from both categories for a Car instance. If you want to be able to classify an entity instance as belonging to a single category (a car can be either truck or passenger), the entity must implement <<categorized_entity,Categorized>> interface. In this case an entity instance will have the reference to a category, and dynamic attributes from this category only.

Loading and saving of dynamic attribute values is handled by <<dataManager,DataManager>>. The `LoadContext.setLoadDynamicAttributes()` method is used to indicate that dynamic attributes should be loaded for entity instances. By default, dynamic attributes are not loaded. At the same time, `DataManager` always saves dynamic attributes contained in entity instances passed to `commit()`.

Dynamic attribute values are available through `getValue()` / `setValue()` methods for any persistent entity inherited from `BaseGenericIdEntity`. An attribute code with the `+++++` prefix should be passed to these methods, for example:

[source, java]
----
include::{sourcesdir}/features/dynamicAttr_1.java[]
----

In fact, the direct access to attribute values in the application code is rarely needed. Any dynamic attribute can be automatically displayed in any <<gui_Table,Table>> or <<gui_FieldGroup,FieldGroup>> component bound to a datasource containing the entity, for which the dynamic attribute was created. The attribute editor described below allows you to specify screens and components that should show the attribute.

User <<permissions,permissions>> to access dynamic attributes can be set in the <<roles,security role>> editor in the same way as for regular attributes. Dynamic attributes are displayed with the `+++++` prefix.

[[dynamic_attributes_mgmt]]
===== Managing Dynamic Attributes

Managing attributes categories and descriptions is done via special screens available in *Administration > Dynamic Attributes* menu.

The category browser shows the list of all registered categories.

.Categories Browser
image::categoryBrowser.png[align="center"]

The category editor allows you to create a new category for an entity and define a set of dynamic attributes. The category name and the related entity type fields are mandatory. The *Default* checkbox indicates that this category will be automatically selected for a new instance of an entity implementing `Categorized` interface.

.Category Editor
image::categoryEditor.png[align="center"]

The *Name localization* groupbox is shown if the application supports more than one language. It enables setting the localized values of category names for each available locale.

.Category name localization
image::categoryLocalization.png[align="center"]

Dynamic attribute editor enables setting the name, system code, value type and the default value of the attribute.

.Dynamic Attribute Editor
image::runtimePropertyEditor.png[align="center"]

For all value types, except `Boolean`, there is a *Width* field available to set up the field width in `FieldGroup` in pixels or as a percentage. If the *Width* field is empty, its assumed value is 100%.

For all value types, except `Boolean` and `Enumeration`, there is also an *Is* *collection* checkbox available. It allows you to create multi-valued dynamic attributes of a selected type.

Localization is supported for all types of dynamic attributes:

.Dynamic Attribute Localization
image::runtimePropertyLocalization.png[align="center"]

For the `Enumeration` value type, the set of named values is defined in the *Enumeration* field via the list editor.

.Dynamic Attribute Editor for `Enumeration` type
image::runtimePropertyEnum.png[align="center"]

Each enumeration value can also be localized to the languages, available for the application.

.Dynamic Attribute Localization for `Enumeration` type
image::runtimePropertyEnumLocalization.png[align="center"]

A dynamic attribute also has visibility settings, which define the screens where it should be displayed. By default, the attribute is invisible on any screen.

.Dynamic Attribute Visibility Settings
image::runtimePropertyVisibility.png[align="center"]

In addition to the screen, you can also specify a component in which the attribute is to appear (for example, for screens, where several <<gui_FieldGroup,FieldGroup>> components show the fields of the same entity).

If the attribute is marked as visible on a screen, it will automatically appear in all field groups and tables displaying entities of the corresponding type on the screen.

Access to dynamic attributes can also be restricted by <<roles,user role>> settings. Security settings for dynamic attributes are similar to those for regular attributes.

In order for changes in attribute and visibility settings to take effect, click *Apply settings* in the categories browser. Changes can also be applied via *Administration > JMX Console* by calling the `clearDynamicAttributesCache()` method of the `app-core.cuba:type=CachingFacade` JMX bean.

The dynamic attribute added to the screen automatically by specifying visibility settings is shown below:

image::runtimePropsApplyChanges.png[align="center"]

Dynamic attributes can be added to a screen manually. To do this, follow these steps:

* In the `dsContext` section of the screen XML-descriptor, set the `loadDynamicAttributes` property to `true` for a datasource that loads the entity (entities), for example:
+
[source, xml]
----
<dsContext>
    <datasource id="carDs" class="com.company.sample.entity.Car" view="_local" loadDynamicAttributes="true"/>
</dsContext>
----

* Specify the dynamic attribute code with the `+++++` prefix in the `property` XML attribute of a component definition:
+
[source, xml]
----
<textField id="numberOfSeats" datasource="carDs" property="+numberOfSeats"/>
----

[[categorized_entity]]
===== Categorized Entities

If an entity implements `com.haulmont.cuba.core.entity.Categorized` interface, you can use `com.haulmont.cuba.gui.components.RuntimePropertiesFrame` component for displaying dynamic attributes of this entity. This component allows a user to select a category for the particular entity instance and specify values of dynamic attributes of this category.

In order to use the `RuntimePropertiesFrame` component in an edit screen, do the following:

* Two <<datasources,datasources>> should be declared in the `dsContext` section:
+
--
**  `runtimePropsDatasource` - a specific datasource to load the `CategoryAttributeValue` instances. The `mainDs` attribute must refer to the main datasource, which contains the edited entity.

** A regular `collectionDatasource` to load the list of categories of this entity type.

Example:

[source, xml]
----
<dsContext>
  <datasource id="carDs"
      class="com.company.sample.entity.Car"
      view="carEdit"/>

  <runtimePropsDatasource id="runtimePropsDs"
      mainDs="carDs"/>

  <collectionDatasource id="categories"
      class="com.haulmont.cuba.core.entity.Category"
      view="_local">
    <query>
         select c from sys$Category c where c.entityType='sample$Car'
    </query>
  </collectionDatasource>
</dsContext>
----
--

* Now, the `runtimeProperties` visual component may be included in the XML-descriptor of the screen:
+
[source, xml]
----
<runtimeProperties id="runtimePropsFrame"
  runtimeDs="runtimePropsDs"
  categoriesDs="categories"/>
----

[[email_sending]]
==== Email Sending

The platform provides email sending facilities with the following features:

* Synchronous or asynchronous sending. In case of synchronous sending, the calling code waits till the message is sent to the SMTP server. In case of asynchronous sending, the message is persisted to the database and the control is returned immediately to the calling code. The actual sending is done later by a <<scheduled_tasks,scheduled task>>.

* Reliable tracking of message sending timestamp or errors in the database for both synchronous and asynchronous modes.

* User interface to search and view information about sent messages, including all message attributes and content, sending status and the number of attempts.

See an example of using this mechanism in the <<sending_emails_recipe,Sending Emails>> development recipe.

[[email_sending_methods]]
===== Sending Methods

To send an email, the `EmailerAPI` bean should be used at the Middleware, and the `EmailService` service â€“ at the client tier.

The basic methods of these components are described below:

* `sendEmail()` â€“ synchronous message sending. The calling code is blocked while sending the message to the SMTP server.
+
The message can be transmitted in the form of a set of parameters (the comma-separated list of recipients, subject, content, array of attachments), and in the form of a special `EmailInfo` object, which encapsulates all this information and allows you to explicitly set the sender's address and to form the message body using a *FreeMarker* template.
+
`EmailException` may be thrown during synchronous sending, containing the information on the recipient addresses, where delivery has failed, and the corresponding error messages.
+
During the execution of the method, a `SendingMessage` instance is created in the database for each recipient. It has the initial `SendingStatus.SENDING` status, and `SendingStatus.SENT` after successful sending. In case of a message sending error, the message status changes to `SendingStatus.NOTSENT`.

* `sendEmailAsync()` â€“ asynchronous message sending. This method returns the list (by the number of recipients) of `SendingMessage` instances in `SendingStatus.QUEUE` status, which were created in the database. The actual sending is performed with the subsequent call of the `EmailerAPI.processQueuedEmails()` method, which should be invoked from a <<scheduled_tasks,scheduled task>> with the desired frequency.

[[email_attachments]]
===== Email Attachments

The `EmailAttachment` object is a wrapper that holds the attachment as a byte array (the `data` field), the file name (the `name` field), and, if necessary, the attachment identifier which is unique for this message (the optional but useful `contentId` field).

The attachment identifier may be used to insert images in the message body. For this, a unique `contentId` (for example, `myPic`) is specified when creating `EmailAttachment`. Expression like `cid:myPic` can be used as a path to insert the attachment in the message body. So, to insert an image you can specify the following HTML element:

[source, xml]
----
<img src="cid:myPic"/>
----

[[email_sending_properties]]
===== Configuring Email Sending Parameters

Email sending parameters can be configured using the <<app_properties,application properties>> listed below. All of them are runtime parameters and are stored in the database, but can be overridden for a specific *Middleware* block in its `app.properties` file.

All email sending parameters are available via the `EmailerConfig` configuration interface.

[[cuba.email.fromAddress]]
* `cuba.email.fromAddress` â€“ the default sender's address. It is used if the `EmailInfo.from` attribute is not specified.
+
Default value: `DoNotReply@localhost`

[[cuba.email.smtpHost]]
* `cuba.email.smtpHost` â€“ the address of the SMTP server.
+
Default value: `test.host`

[[cuba.email.smtpPort]]
* `cuba.email.smtpPort` â€“ the port of the SMTP server.
+
Default value: `25`

[[cuba.email.smtpAuthRequired]]
* `cuba.email.smtpAuthRequired` flags whether the SMTP server requires authentication. It corresponds to the `mail.smtp.auth` parameter, which is passed at the creation of the `javax.mail.Session` object.
+
Default value: `false`

[[cuba.email.smtpSslEnabled]]
* `cuba.email.smtpSslEnabled` flags whether `SSL` protocol is enabled. It corresponds to the `mail.transport.protocol` parameter with the `smtps` value, which is passed at the creation of the `javax.mail.Session` object.
+
Default value: `false`

[[cuba.email.smtpStarttlsEnable]]
* `cuba.email.smtpStarttlsEnable` â€“ flags the use of the `STARTTLS` command when authenticating on the SMTP server. It corresponds to the `mail.smtp.starttls.enable` parameter, which is passed at the creation of the `javax.mail.Session` object.
+
Default value: `false`

[[cuba.email.smtpUser]]
* `cuba.email.smtpUser` â€“ the user name for SMTP server authentication.

[[cuba.email.smtpPassword]]
* `cuba.email.smtpPassword` â€“ the user password for SMTP server authentication.

[[cuba.email.delayCallCount]]
* `cuba.email.delayCallCount` â€“ is used in asynchronous sending of emails to skip first few calls of `EmailManager.queueEmailsToSend()` after server startup to reduce the load during application initialization. Email sending will start with the next call.
+
Default value: `2`

[[cuba.email.messageQueueCapacity]]
* `cuba.email.messageQueueCapacity` â€“ for asynchronous sending, the maximum number of messages read from the queue and sent in one call of `EmailManager.queueEmailsToSend()`.
+
Default value: `100`

[[cuba.email.defaultSendingAttemptsCount]]
* `cuba.email.defaultSendingAttemptsCount` for asynchronous sending, the default number of attempts to send an email. It is used if the `attemptsCount` parameter is not specified when calling `Emailer.sendEmailAsync()`.
+
Default value: `10`

[[cuba.email.maxSendingTimeSec]]
* `cuba.email.maxSendingTimeSec` â€“ the maximum expected time in seconds, which is required to send an email to the SMTP server. It is used for asynchronous sending to optimize the selection of `SendingMessage` objects from the DB queue.
+
Default value: 120

[[cuba.email.sendAllToAdmin]]
* `cuba.email.sendAllToAdmin` â€“ indicates that all messages should be sent to the cuba.email.adminAddress address, regardless of the specified recipient's address. It is recommended to use this parameter during system development and debugging.
+
Default value: `false`

[[cuba.email.adminAddress]]
* `cuba.email.adminAddress` â€“ the address, to which all messages are sent if the `cuba.email.sendAllToAdmin` property is switched on.
+
Default value: `admin@localhost`

[[cuba.emailerUserLogin]]
* `cuba.emailerUserLogin` â€“ the login of system user, used by asynchronous email sending code to be able to persist the information to the database. It is recommended to create a separate user (for example, `emailer`) without a password, so that it will be impossible to log in under their name via user interface. This is also convenient to search for messages related to email sending in the server log.
+
Default value: `admin`

[[cuba.email.exceptionReportEmailTemplateBody]]
* `cuba.email.exceptionReportEmailTemplateBody` - path to the exception report email body `*.gsp`-template location.
+
--
The templates are based on Groovy `SimpleTemplateEngine` syntax, thus you can use Groovy blocks inside of the template content:

** `toHtml()` method converts the string to HTML string by escaping and replacing special symbols,

** `timestamp` - last attempt date to send the email,

** `errorMessage` - the message of error,

** `stacktrace` - stack trace of the error.

Example of a template file:

[source, html]
----
<html>
<body>
<p>${timestamp}</p>
<p>${toHtml(errorMessage)}</p>
<p>${toHtml(stacktrace)}</p>
</body>
</html>
----
--

[[cuba.email.exceptionReportEmailTemplateSubject]]
* `cuba.email.exceptionReportEmailTemplateSubject` - path to the exception report email subject `*.gsp` template location.
+
--
Example of a template file:

[source, groovy]
----
[${systemId}] [${userLogin}] Exception Report
----
--

You can also use properties from JavaMail API, adding them to the `app.properties` file of the *core* module. The `mail.*` properties are passed at the creation of the `javax.mail.Session` object.

You can view the current parameter values and send a test message using the `app-core.cuba:type=Emailer` JMX bean.

[[entity_inspector]]
==== Entity Inspector

The entity inspector enables working with any application objects without having to create dedicated screens. The inspector dynamically generates the screens to browse and edit the instances of the selected entity.

This gives the system administrator an opportunity to review and edit the data that is not accessible from standard screens due to their design, and to create the data model and main menu sections linked to the entity inspector only, at prototyping stage.

The entry point for the inspector is the `com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml` screen.

If a `String`-type parameter named `entity` with an entity name has been passed to the screen, the inspector will show a list of entities with the abilities for filtering, selection and editing. The parameter can be specified when registering the screen in <<screens.xml,screens.xml>>, for example:

`screens.xml`

[source, xml]
----
<screen id="sales$Product.lookup"
      template="/com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml">
  <param name="entity"
         value="sales$Product"/>
</screen>
----

`menu.xml`

[source, xml]
----
<item id="sales$Product.lookup"/>
----

Screen identifier defined as `++{entity_name}.lookup++` allows <<gui_PickerField,PickerField>> and <<gui_LookupPickerField,LookupPickerField>> components to use this screen within the `PickerField.LookupAction` standard action.

Generally, the screen may be called without any parameters. In this case, the top part will contain an entity selection field. In the *cuba* application component, the inspector screen is registered with the `entityInspector.browse` identifier, so it can be simply referenced in a menu item:

[source, xml]
----
<item id="entityInspector.browse"/>
----

[[entity_log]]
==== Entity Log

This mechanism tracks entity persistence at the <<entity_listeners,entity listeners>> level, i.e. it is guaranteed to track all changes passing through persistent context of the <<entityManager,EntityManager>>. Direct changes to entities in the database using SQL, including the ones performed using <<nativeQuery,NativeQuery>> or <<queryRunner,QueryRunner>>, are not tracked.

Modified entity instances are passed to `registerCreate()`, `registerModify()` and `registerDelete()` methods of the `EntityLogAPI` bean before they are saved to the database. Each method has `auto` parameter, allowing separation of automatic logs added by entity listeners from manual logs added by calling these methods from the application code. When these methods are called from entity listeners the value of `auto` parameter is `true`.

The logs contain information about the time of modification, the user who has modified the entity, and the new values of the changed attributes. Log entries are stored in the *SEC_ENTITY_LOG* table corresponding to the `EntityLogItem` entity. Changed attribute values are stored in the *CHANGES* column and are converted to instances of `EntityLogAttr` entity when they are loaded by the Middleware.

[[entity_log_setup]]
===== Setting Up Entity Log

The simplest way to set up the entity log is using the *Administration > Entity Log > Setup* application screen.

You can also set up Entity Log by entering some records in the database, if you want to include the configuration to the <<db_scripts,database initialization scripts>>.

Logging is configured using the `LoggedEntity` and `LoggedAttribute` entities corresponding to *SEC_LOGGED_ENTITY* and *SEC_LOGGED_ATTR* tables.

`LoggedEntity` defines the types of entities that should be logged. `LoggedEntity` has the following attributes:

* `name` (*NAME* column) â€“ the name of the entity <<metaClass,meta-class>>, for example, `sales$Customer`.

* `auto` (*AUTO* column) â€“ defines if the system should log the changes when EntityLogAPI is called with `auto = true` parameter (i.e. called by <<entity_listeners,entity listeners>>).

* `manual` (*MANUAL* column) â€“ defines if the system should log the changes when `EntityLogAPI` is called with `auto = false` parameter.

`LoggedAttribute` defines the entity attribute to be logged and contains a link to the `LoggedEntity` and the attribute name.

To set up logging for a certain entity, the corresponding entries should be added into the *SEC_LOGGED_ENTITY* and *SEC_LOGGED_ATTR* tables. For example, logging the changes to `name` and `grade` attributes of the `Customer` entity can be enabled using:

[source, sql]
----
insert into SEC_LOGGED_ENTITY (ID, CREATE_TS, CREATED_BY, NAME, AUTO, MANUAL)
values ('25eeb644-e609-11e1-9ada-3860770d7eaf', now(), 'admin', 'sales$Customer', true, true);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), 'admin', '25eeb644-e609-11e1-9ada-3860770d7eaf', 'name');

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), 'admin', '25eeb644-e609-11e1-9ada-3860770d7eaf', 'grade');
----

The logging mechanism is activated by default. If you want to stop it, set the `Enabled` attribute of the `app-core.cuba:type=EntityLog` JMX bean `false` and then invoke the its `invalidateCache()` operation. Alternatively, set the <<cuba.entityLog.enabled,cuba.entityLog.enabled>> application property to `false` and restart the server.

[[entity_log_view]]
===== Viewing the Entity Log

The entity log content can be viewed on a dedicated screen available at *Administration > Entity Log*.

The change log for a certain entity can also be accessed from any application screen by loading a collection of `EntityLogItem` and the associated `EntityLogAttr` instances into the datasources and creating the visual components connected to these datasources. For example:

[source, xml]
----
include::{sourcesdir}/features/entity_log.xml[]
----

Logged attributes should contain the <<localizedValue_annotation,@LocalizedValue>> annotation in order to display localized values. When annotated, the logging mechanism populates the `EntityLogAttr.messagesPack` field, and the table in the example above is able to use `locValue` column instead of `value`:

[source, xml]
----
<table id="logAttrTable" width="100%" height="100%">
  <columns>
      <column id="name"/>
      <column id="locValue"/>
  </columns>
  <rows datasource="logAttrDs"/>
</table>
----

[[entity_snapshots]]
==== Entity Snapshots

The entity saving mechanism, much like the <<entity_log,entity log>>, is intended to track data changes at runtime. It has the following distinct features:

* The whole state (or snapshot) of a graph of entities defined by a specified <<views,view>> is saved.

* Snapshot saving mechanism is explicitly called from the application code.

* The platform allows the snapshots to be viewed and compared.

[[entity_snapshots_save]]
===== Saving Snapshots

In order to save a snapshot of a given graph of entities, you need to call the `EntitySnapshotService.createSnapshot()` method passing the entity which is an entry point to the graph and the <<views,view>> describing the graph. The snapshot will be created using the loaded entities without any calls to the database. As a result, the snapshot will not contain the fields that are not included in the view used to load the entity.

The graph of Java objects is converted into XML and saved in the *SYS_ENTITY_SNAPSHOT* table (corresponding to the `EntitySnapshot` enitity) together with the link to the primary entity.

Usually, snapshots need to be saved after <<screen_edit,editor screen>> commit. This may be achieved by overriding the `postCommit()` method of the screen controller, for example:

[source, java]
----
include::{sourcesdir}/features/entity_snapshots_save.java[]
----

[[entity_snapshots_view]]
===== Viewing Snapshots

Viewing snapshots for arbitrary entities is possible using the `com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml` frame. For example:

[source, xml]
----
<frame id="diffFrame"
      src="/com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml"
      width="100%"
      height="100%"/>
----

The snapshots should be loaded into the frame from the edit screen controller:

[source, java]
----
include::{sourcesdir}/features/entity_snapshots_view.java[]
----

The `diff-view.xml` frame shows the list of snapshots for the given entity, with an ability to compare them. The view for each snapshot includes the user, date and time. When a snapshot is selected from the list, the changes will be displayed compared to the previous snapshot. All attributes are marked as changed for the first snapshot. Selecting two snapshots shows the results of the comparison in a table.

The comparison table shows attribute names and their new values. When a row is selected, the detailed information on attribute changes across two snapshots is shown. Reference fields are displayed according to their <<namePattern_annotation,instance name>>. When comparing collections, the new and removed elements are highlighted with green and red color respectively. Collection elements with changed attributes are displayed without highlighting. Changes to element positions are not recorded.

[[entity_statistics]]
==== Entity Statistics

The entity statistics mechanism provides the information on the current number of entity instances in the database. This data is used to automatically select the best lookup strategy for linked entities and to limit the size of search results displayed in UI screens.

Statistics is stored in the `SYS_ENTITY_STATISTICS` table which is mapped to the `EntityStatistics` entity. It can be updated automatically using the `refreshStatistics()` method of the <<persistenceManagerMBean,PersistenceManagerMBean>> JMX bean. If you pass an entity name as a parameter, the statistics will be collected for the given entity, otherwise - for all entities. If you want to update the statistics regularly, create a <<scheduled_tasks_cuba,scheduled task>> invoking this method. Keep it mind that the collection process will execute `select count(*)` for each entity and can put significant load on the database.

Programmatic access to entity statistics is available via `PersistenceManagerAPI` interface on the middle tier and `PersistenceManagerService` on the the client tier. Statistics is cached in memory, so any direct changes to statistics in the database will be applied only after the server restart or after calling the `PersistenceManagerMBean.flushStatisticsCache()` method.

The `EntityStatistics` attributes are described below.

* `name` (`NAME` column) â€“ the name of the entity <<metaClass,meta-class>>, for example, `sales$Customer`.

* `instanceCount` (`INSTANCE_COUNT` column) â€“ the approximate number of entity instances.

* `fetchUI` (`FETCH_UI` column) â€“ the size of the data displayed on a page when extracting entity lists.
+
For example, the <<gui_Filter,Filter>> component uses this number in the *Show N rows* field.

* `maxFetchUI` (`MAX_FETCH_UI` column) â€“ the maximum number of entity instances that can be extracted and passed to the client tier.
+
This limit is applied when showing entity lists in such components as <<gui_LookupField,LookupField>> or <<gui_LookupPickerField,LookupPickerField>>, as well as tables without a <<gui_Filter,filter>>, when no limitations are applied to the connected <<datasources,datasource>> via `CollectionDatasource.setMaxResults()`. In this case the data source itself limits the number of extracted instances to `maxFetchUI`.

* `lookupScreenThreshold` (`LOOKUP_SCREEN_THRESHOLD` column) â€“ the threshold, measured in number of entities, which determines when <<screen_lookup,lookup screens>> should be used instead of dropdowns for entity lookup.
+
The <<gui_Filter,Filter>> component takes this parameter into account when choosing filter parameters. Until the threshold is reached, the system uses the <<gui_LookupField,LookupField>> component, and once the threshold is exceeded, the <<gui_PickerField,PickerField>> component is used. Hence, if lookup screens should be used for a specific entity in a filter parameter, it is possible to set the value of `lookupScreenThreshold` to a value lower than `instanceCount`.

`PersistenceManagerMBean` JMX bean enables setting default values for all of the parameters mentioned above via `DefaultFetchUI`, `DefaultMaxFetchUI`, `DefaultLookupScreenThreshold` attributes. The system will use the corresponding default values when an entity has no statistics, which is a common case.

Besides, `PersistenceManagerMBean.enterStatistics()` method allows a user to enter statistics data for an entity. For example, the following parameters should be passed to the method to set a default page size to 1,000 and maximum number of loaded into <<gui_LookupField,LookupField>> instances to 30,000:

[source, json]
----
entityName: sales$Customer
fetchUI: 1000
maxFetchUI: 30000
----

Another example: suppose that you have a filter condition by the Customer entity, and you want to use a lookup screen instead of dropdown list when selecting Customer in the condition parameter. Then invoke the `enterStatistics()` method with the following parameters:

[source, json]
----
entityName: sales$Customer
instanceCount: 2
lookupScreenThreshold: 1
----

Here we ignore the actual number of Customer records in the database and manually specify that the threshold is always exceeded.

[[entityImportExport]]
==== Export and Import Entities in JSON

The platform provides an API for exporting and importing graphs of entities in JSON format. It is available on Middleware via the `EntityImportExportAPI` interface and on the client tier via `EntityImportExportService`. These interfaces have an identical set of methods which are described below. The export/import implementation delegates to the `EntitySerializationAPI` interface which can also be used directly.

* `exportEntitiesToJSON()` - serializes a collection of entities to JSON.
+
[source, java]
----
include::{sourcesdir}/common/entityImportExportService_1.java[]
----

* `exportEntitiesToZIP()` - serializes a collection of entities to JSON and packs the JSON file into ZIP archive. In the following example, the ZIP archive is saved to the file storage using the <<fileLoader,FileLoader>> interface:
+
[source, java]
----
include::{sourcesdir}/common/entityImportExportService_2.java[]
----

* `importEntitiesFromJSON()` - deserializes the JSON and persists deserialized entities according to the rules, described by the `entityImportView` parameter (see JavaDocs on the `EntityImportView` class). If an entity is not present in the database, it will be created. Otherwise the fields of the existing entity that are specified in the `entityImportView` will be updated.

* `importEntitiesFromZIP()` - reads a ZIP archive that contains a JSON file, deserializes the JSON and persists deserialized entities like the `importEntitiesFromJSON()` method.
+
[source, java]
----
include::{sourcesdir}/common/entityImportExportService_3.java[]
----

[[file_storage]]
==== File Storage

File storage enables uploading, storing and downloading arbitrary files associated with the entities. In the standard implementation, the files are stored outside of the main database using a specialized structure within the file system.

File storage mechanism includes the following parts:

* `FileDescriptor` entity â€“ the descriptor of the uploaded file (not to be confused with `java.io.FileDescriptor`) enables referencing the file from the data model objects.

* `FileStorageAPI` interface â€“ provides access to the file storage at the middle <<app_tiers,tier>>. Its main methods are:

** `saveStream()` â€“ saves the contents of the file passed as the `InputStream` according to the specified `FileDescriptor`.

** `openStream()` â€“ returns the contents of the file defined by the `FileDescriptor` in the form of an opened `InputStream`.

* `FileUploadController` class â€“ a Spring MVC controller, which enables sending files from the Client to the Middleware with HTTP POST requests.

* `FileDownloadController` class â€“ Spring MVC controller which enables retrieving files from the Middleware to the Client with HTTP GET requests.

*  <<gui_FileUploadField,FileUpload>> and <<gui_FileMultiUploadField,FileMultiUpload>> visual components â€“ enable uploading files from the user's computer to the client tier of the application and then transferring them to the Middleware.

* `FileUploadingAPI` interface â€“ temporary storage for files uploaded to the client tier. It is used for uploading files to the client tier by the visual components mentioned above. The application code can use `putFileIntoStorage()` method for moving a file into the persistent storage of the Middleware.

* <<fileLoader,FileLoader>> - an interface for working with the file storage using the same set of methods on both middle and client tiers.

* `ExportDisplay` â€“ client tier interface allowing downloading various application resources to the user's computer. Files can be retrieved from persistent storage using the `show()` method, which requires a `FileDescriptor`. An instance of `ExportDisplay` may be obtained either by calling the `AppConfig.createExportDisplay()` static method, or through <<screen_controller_injection,injection>> into the controller class.

[TIP]
====
File transfer between the user's computer and the storage in both directions is always performed by copying data between input and output streams. Files are never fully loaded into memory at any application level, which enables transferring files of almost any size.
====

[[file_upload]]
===== Uploading Files

Files from the user's computer can be uploaded into the storage using the <<gui_FileUploadField,FileUpload>> and <<gui_FileMultiUploadField,FileMultiUpload>> components. Usage examples are provided in this manual in the appropriate component descriptions, as well as in <<images_recipe>>.

`FileUpload` component is also available within the ready-to-use <<dialogs_fileUploadDialog,FileUploadDialog>> window designed to load files in the temporary storage.

The temporary client-level storage (`FileUploadingAPI`) stores temporary files in the folder defined by <<cuba.tempDir,cuba.tempDir>> application property. Temporary files can remain in the folder in case of any failures. The `clearTempDirectory()` method of the `cuba_FileUploading` bean is invoked periodically by the scheduler defined in the <<spring.xml,cuba-web-spring.xml>> file.

[[file_download]]
===== Downloading Files

Files can be downloaded from the file storage to the user's computer by using the `ExportDisplay` interface. It can be obtained by calling the `AppConfig.createExportDisplay()` static method or via <<screen_controller_injection,injection>> in the controller class. For example:

[source, java]
----
AppConfig.createExportDisplay(this).show(fileDescriptor);
----

The `show()` method accepts an optional `ExportFormat` type parameter, which defines the type of the content and the file extension. If the format has not been provided, the extension is retrieved from the `FileDescriptor`, and the content type is set to `application/octet-stream`.

The file extension defines whether the file is downloaded via the browser's standard open/save dialog (`Content-Disposition = attachment`), or if the browser will attempt to show the file in the browser window (`Content-Disposition = inline`). The list of extensions for files that should be shown in the browser window is defined by the <<cuba.web.viewFileExtensions,cuba.web.viewFileExtensions>> application property.

`ExportDisplay` also enables downloading of arbitrary data if `ByteArrayDataProvider` is used as a parameter of the `show()` method. For example:

[source, java]
----
include::{sourcesdir}/features/exportDisplay_1.java[]
----

[[fileLoader]]
===== FileLoader Interface

The `FileLoader` interface allows you to work with file storage using the same set of methods on both middle and client tiers. Uploading and downloading of files is performed using streams:

* `saveStream()` â€“ saves an `InputStream` contents into file storage.

* `openStream()` â€“ returns an input stream to load a file contents from file storage.

[TIP]
====
Both client-side and server-side implementations of `FileLoader` follow the common rule: file transfer is always performed by copying data between input and output streams. Files are never fully loaded into memory at any application level, which enables transferring files of almost any size.
====

As an example of using `FileLoader` let's consider a simple task of saving a user input into the text file and displaying the file content in another field on the same screen.

The screen contains two `textArea` fields. Suppose the user inputs text in the first `textArea`, clicks the `buttonIn` below, and the text is saved to the `FileStorage`. The second `textArea` will display the content of the saved file on `buttonOut` click.

Below is the fragment of the screen XML descriptor:

[source, xml]
----
include::{sourcesdir}/features/fileLoader_1.xml[]
----

The screen controller contains two methods invoked on buttons click:

* In the `onButtonInClick()` method we create a byte array from the first `textArea` input. Then we create a `FileDescriptor` object and define the new file name, extension, size, and creation date with its attributes.
+
Then we save the new file with the `saveStream()` method of `FileLoader`, passing the `FileDescriptor` to it and providing the file content with an `InputStream` supplier. We also commit the `FileDescriptor` to the data store using the `DataManager` interface.

* In the `onButtonOutClick()` method we extract the content of the saved file using the `openStream()` method of the `FileLoader`. Then we display the content of the file in the second `textArea`.

[source, java]
----
include::{sourcesdir}/features/fileLoader_1.java[]
----

image::fileLoader_recipe.png[align="center"]

[[file_storage_impl]]
===== Standard File Storage Implementation

The standard implementation stores files in a dedicated folder structure within one or several file locations.

The roots of the structure can be defined in the <<cuba.fileStorageDir,cuba.fileStorageDir>> application property in the format of comma-separated paths list. For example:

[source, properties]
----
cuba.fileStorageDir=/work/sales/filestorage,/mnt/backup/filestorage
----

If the property is not defined, the storage will be located in the `filestorage` sub-folder of the Middleware's <<work_dir,work directory>>. This folder is `tomcat/work/app-core/filestorage` in standard Tomcat deployment.

With several locations defined, the storage behaves as follows:

* First folder in the list is considered as _primary_, others â€“ as _backup_.

* Stored files are first placed in the primary folder, and then copied to all of the backup directories.
+
The system checks that each folder is accessible before storing a file. If the primary directory is not accessible, the system throws an exception without storing the file. If any of the backup directories are not accessible, the file gets stored in available ones and the corresponding error is logged.

* The files are read from the primary directory.
+
If the primary directory is not accessible, the system reads files from the first available backup directory containing the required files. A corresponding error is logged.

The storage folder structure is organized in the following way:

* There are three levels of subdirectories representing the files upload date â€“ year, month, and day.

* The actual files are saved in the `day` directory. The file names match the identifiers of the corresponding `FileDescriptor` objects. The file extension matches that of the source file.

* The root folder of the structure contains a `storage.log` file with the information on each stored file, including the user and upload time. This log is not required for operation of the storage mechanism, but it could be useful for troubleshooting.

The `app-core.cuba:type=FileStorage` JMX bean displays the current set of storage roots and offers the following methods for troubleshooting:

* `findOrphanDescriptors()` â€“ finds all instances of `FileDescriptor` in the database that do not have a matching file in the storage.

* `findOrphanFiles()` â€“ finds all files in the storage that do not have a corresponding `FileDescriptor` instance in the database.

[[aws_file_storage_impl]]
===== Amazon S3 File Storage Implementation

The standard file storage implementation can be replaced by a cloud storage service. We recommend to use separate cloud file storage services for cloud deployments which, commonly, don't guarantee the persistence of external files on their hard drives.

The platform provides support of Amazon S3 file storage service out-of-the-box. To support other services, you need to implement your custom logic.

To add Amazon S3 support, firstly, you need to register `AmazonS3FileStorage` class in the `spring.xml` file of the *core* module:

[source, xml]
----
<bean name="cuba_FileStorage"
          class="com.haulmont.cuba.core.app.filestorage.amazon.AmazonS3FileStorage"/>
----

Next, you should define your Amazon settings in the `app.properties` file in the *core* module:

[source, plain]
----
cuba.amazonS3.accessKey = <Access Key>
cuba.amazonS3.secretAccessKey = <Secret Access Key>
cuba.amazonS3.region = <Region>
cuba.amazonS3.bucket = <Bucket Name>
----

[TIP]
====
The `accessKey` and `secretAccessKey` should be those of your AWS IAM user account, not the AWS account itself. You can find the correct credentials on the *Users* tab of your AWS console.
====

The storage folder structure is organized similarly to the <<file_storage_impl,standard implementation>>.

[[folders_pane]]
==== Folders Panel

The folders panel provides quick access to frequently used information. It is a panel on the left side of the main application window containing a hierarchical structure of folders. Clicking on folders shows the corresponding system screens with certain parameters.

At the moment of writing, the panel is available for the *Web Client* only.

The platform supports three types of folders: _application folders_, _search folders_ and _record sets_. Application folders are displayed at the top of the panel as a separate folder tree. Search folders and record sets are displayed at the bottom of the panel in a combined tree. Folders support keyboard <<shortcuts,shortcuts>> if the <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> property is `true`.

* Application folders:

** Open screens with or without a <<gui_Filter,filter>>.

** The set of folders depend on the current user session. Folder visibility is defined by a Groovy script.

** Application folders can be created and changed only by users with special <<permissions,permissions>>.

** Folder headers may show the record count calculated by a Groovy script.

** Folder headers are updated on timer events, which means that record count and display style for each folder can be updated.

* Search folders:

** Open screens with a <<gui_Filter,filter>>.

** Search folders can be local or global, accessible only by the user who created them or by all users, respectively.

** Local folders can be created by any user, while global are created only by users with special permissions.

* Record sets:

** Open screens with a <<gui_Filter,filter>> containing a condition to select specific records by their identifiers.

** Record set content can be edited using the dedicated table <<gui_Action,actions>>: Add to set and Remove from set.

** Record sets are available only to the user who created them.

The following application properties can influence the functionality of the folder panel:

* <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>>

* <<cuba.web.foldersPaneVisibleByDefault,cuba.web.foldersPaneVisibleByDefault>>

* <<cuba.web.foldersPaneDefaultWidth,cuba.web.foldersPaneDefaultWidth>>

* <<cuba.web.appFoldersRefreshPeriodSec,cuba.web.appFoldersRefreshPeriodSec>>

* <<cuba.web.showFolderIcons,cuba.web.showFolderIcons>>

[[application_folder]]
===== Application Folders

Creating application folders requires special <<permissions,permissions>> to create/edit application folders (`cuba.gui.appFolder.global`).

A simple application folder can be created via the folder panel context menu. Such folder will not be connected to the system screens and can be only used to group other folders within a folder tree.

A folder that opens a screen with a filter can be created as follows:

* Open a screen and filter the records as necessary.

* Select *Save as application folder* option in the *Filter...* button menu.

* Fill in the folder attributes in the *Add* dialog:

** *Folder name*.

** *Window title* â€“ a string to be added to the window title when opening it from the folder.

** *Parent folder* â€“ determines the location of the new folder in the folder tree.

** *Visibility script* â€“ a Groovy script defining folder visibility, executed at the start of user session.
+
The script should return a `Boolean`. The folder is visible, if the script is not defined or returns `true` or `null`. Example of a Groovy script:
+
[source, groovy]
----
userSession.currentOrSubstitutedUser.login == 'admin'
----

** *Count script* â€“ a Groovy script defining the record count and display style for a folder. Executed at the start of the user session and on timer.
+
The script should return a numeric value, the integer part of which will be used as the record count value. If the script is not defined or returns `null`, the counter will not be displayed. In addition to the returned value, the script can also set the `style` variable, which will be used as folder display style. Example of a Groovy script:
+
[source, java]
----
def em = persistence.getEntityManager()
def q = em.createQuery('select count(o) from sales$Order o')
def count = q.getSingleResult()

style = count > 0 ? 'emphasized' : null
return count
----
+
In order for the style to be displayed, the application theme should contain this style for the `v-tree-node` element in `cuba-folders-pane`, for example:
+
[source, css]
----
.c-folders-pane .v-tree-node.emphasized {
  font-weight: bold;
}
----

Scripts can use the following variables defined in the `groovy.lang.Binding` context:

* `folder` â€“ an instance of `AppFolder` entity for which the script is executed.

* `userSession` â€“ instance of <<userSession,UserSession>> for current user session.

* `persistence` â€“ implementation of the <<persistence,Persistence>> interface.

* `metadata` â€“ implementation of the <<metadata,Metadata>> interface.

The platform uses the same instance of `groovy.lang.Binding` for all scripts when the folders are being updated. So it is possible to pass variables between them in order to eliminate duplicate requests and increase performance.

Script sources can be stored within the attributes of the `AppFolder` entity or in separate files. In the latter case, the attribute should include a file path with a mandatory ".groovy" extension, as required by the <<resources,Resources>> interface. If an attribute contains a string ending with ".groovy", the script will be loaded from the corresponding file; otherwise, the attribute content itself will be used as a script.

Application folders are instances of the `AppFolder` entity and are stored in the related *SYS_FOLDER* and *SYS_APP_FOLDER* tables.

[[search_folder]]
===== Search Folders

Search folders can be created by the users similar to application folders. Group folders are created directly via the context menu of the folder panel. The folders connected to screens are created from the *Filter...* button menu, using the Save as search folder option.

Creating global search folders, requires the user to have *Create/edit global search folders* permission (`cuba.gui.searchFolder.global`).

Search folder's filter can be edited once the folder is created by opening the folder and changing the *Folder:{folder name}* filter. Saving the filter will change the folder filter as well.

Search folders are instances of the `SearchFolder` entity stored in the related *SYS_FOLDER* and *SEC_SEARCH_FOLDER* tables.

[[record_set]]
===== Record Sets

Using records sets within a screen is possible, if the <<gui_Filter,Filter>> has a corresponding <<gui_Table,Table>> component defined in the `applyTo` attribute. For example:

[source, xml]
----
<layout>
  <filter id="customerFilter"
          datasource="customersDs"
          applyTo="customersTable"/>

  <groupTable id="customersTable"
              width="100%">
      <buttonsPanel>
          <button action="customersTable.create"/>
...
      </buttonsPanel>
...
----

*Add to set* or *Add to current set* / *Remove from set* buttons should now appear in table context menu. If a table includes a `buttonsPanel` (as in the example above), the corresponding table buttons will also be added.

Record sets are the instances of the `SearchFolder` entity stored in the related *SYS_FOLDER* and *SEC_SEARCH_FOLDER* tables.

[[credits]]
==== Information about Software Components

The platform provides an ability to register the information about third party software components used in the application (credits) and to display this information in the UI. The information includes a software component name, a website link and the license text.

<<app_components,Application components>> of the platform contain their own files with descriptions, like `cuba-credits.xml`, `reports-credits.xml`. The <<cuba.creditsConfig,cuba.creditsConfig>> application property can be used to specify a description file of the application.

The structure of the `credits.xml` file is as follows:

* The `items` element lists the used libraries with license texts included either as an embedded `license` element, or as a `license` attribute with a link to the text in the `licenses` section.
+
It is possible to reference licenses declared in the current file as well as any other file declared in `cuba.creditsConfig` variable prior to the current one.

* The `licenses` element lists the texts of general licenses used (e.g. LGPL).

The entire list of third-party software components can be displayed using the `com/haulmont/cuba/gui/app/core/credits/credits-frame.xml` frame, which loads the information from the files defined in the `cuba.creditsConfig` property. An example of the frame within a screen:

[source, xml]
----
<dialogMode width="500" height="400"/>
<layout expand="creditsBox">
  <groupBox id="creditsBox"
            caption="msg://credits"
            width="100%">
      <frame id="credits"
              src="/com/haulmont/cuba/gui/app/core/credits/credits-frame.xml"
              width="100%"
              height="100%"/>
  </groupBox>
</layout>
----

If the dialog mode (`WindowManager.OpenType.DIALOG`) is used when opening the screen that contains the frame, the height must be specified; otherwise, the scrolling may work not correctly. See the `dialogMode` element in the example above.

[[myBatis]]
==== Integration with MyBatis

The platform includes *MyBatis* framework, which offers wider capabilities for running SQL and mapping query results to objects compared to ORM <<nativeQuery,native query>> or <<queryRunner,QueryRunner>>.

The following beans must be added into <<spring.xml,spring.xml>> file of the *core* module to use MyBatis in the project:

[source, xml]
----
include::{sourcesdir}/features/MyBatis.xml[]
----

The `MapperLocations` parameter defines a path to `mapperLocations` mapping files (according to the rules of `ResourceLoader` Spring interface).

Below is the an example of a mapping file for loading an instance of `Order` together with a related `Customer` and a collection of `Order` items:

[source, xml]
----
include::{sourcesdir}/features/mapper.xml[]
----

The following code can be used to retrieve query results from the example above:

[source, java]
----
Transaction tx = persistence.createTransaction();
try {
  SqlSession sqlSession = AppBeans.get("sqlSession");
  Order order = (Order) sqlSession.selectOne("com.sample.sales.selectOrder", orderId);
  tx.commit();
} finally {
  tx.end();
}
----

[[pessimistic_locking]]
==== Pessimistic Locking

Pessimistic locking should be used when there is a high probability of simultaneous editing of a single entity instance. In such cases the standard <<optimistic_locking,optimistic locking>>, based on entity versioning, usually creates too many collisions.

Pessimistic locking explicitly locks an entity instance when it is opened in the <<screen_edit,editor>>. As a result, only one user can edit this particular entity instance in a given moment of time.

Pessimistic locking mechanism can also be used to manage simultaneous execution of arbitrary processes. The key benefit is that the locks are distributed, since they are replicated in the Middleware cluster. More information is available in JavaDocs for the `LockManagerAPI` and `LockService` interfaces.

Pessimistic locking can be enabled for any entity class on application development or production stage using *Administration > Locks > Setup* screen, or as follows:

* Insert a new record with the following field values into the *SYS_LOCK_CONFIG* table with the following field values:
+
--
** *ID* â€“ an arbitrary UUID-type identifier.

** *NAME* â€“ the name of the object to be locked. For an entity, it should be the name of its <<metaClass,meta class>>.

** *TIMEOUT_SEC* â€“ lock expiration timeout in seconds.

Example:

[source, sql]
----
insert into sys_lock_config (id, create_ts, name, timeout_sec) values (newid(), current_timestamp, 'sales$Order', 300)
----
--

* Restart the server or call `reloadConfiguration()` method of the `app-core.cuba:type=LockManager` JMX bean.

Current state of locks can be tracked via the `app-core.cuba:type=LockManager` JMX bean or through the *Administration > Locks* screen. This screen also enables unlocking of any object.

[[queryRunner]]
==== Running SQL Using QueryRunner

`QueryRunner` is a class designed to run SQL. It should be used instead of JDBC in all cases where using plain SQL is necessary and working with the <<nativeQuery,ORM tools>> of the same purpose is not desired.

The platform's QueryRunner is a variant of link:$$http://commons.apache.org/dbutils/apidocs/org/apache/commons/dbutils/QueryRunner.html$$[Apache DbUtils QueryRunner] with the added ability to use Java Generics.

Usage example:

[source, java]
----
QueryRunner runner = new QueryRunner(persistence.getDataSource());
try {
  Set<String> scripts = runner.query("select SCRIPT_NAME from SYS_DB_CHANGELOG",
          new ResultSetHandler<Set<String>>() {
              public Set<String> handle(ResultSet rs) throws SQLException {
                  Set<String> rows = new HashSet<String>();
                  while (rs.next()) {
                      rows.add(rs.getString(1));
                  }
                  return rows;
              }
          });
  return scripts;
} catch (SQLException e) {
  throw new RuntimeException(e);
}
----

There are two ways of using `QueryRunner`: current transaction or separate transaction in autocommit mode.

* To run a query in current transaction `QueryRunner` must be instantiated using a parameterless constructor. Then, `query()` or `update()` methods should be called with a `Connection` parameter retrieved via `EntityManager.getConnection()`. There is no need to close the `Connection` after the query, as it will be closed when the transaction is committed.

* To run a query in a separate transaction, `QueryRunner` instance must be created using a constructor with the `DataSource` parameter retrieved using `Persistence.getDataSource()`. Then, `query()` or `update()` methods should be called without the `Connection` parameter. Connection will be created from the specified `DataSource` and immediately closed afterwards.

[[scheduled_tasks]]
==== Scheduled Tasks Execution

The platform offers two ways to run scheduled tasks:

* By using the standard `TaskScheduler` mechanism of the Spring Framework.

* By using platform's own mechanism of scheduled tasks execution.

[[scheduled_tasks_spring]]
===== Spring TaskScheduler

This mechanism is described in details in the *Task Execution and Scheduling* section of the Spring Framework manual.

`TaskScheduler` can be used to run methods of arbitrary Spring beans in any application <<app_tiers,block>> both at the middleware and client tiers.

Example of configuration in <<spring.xml,spring.xml>>:

[source, xml]
----
include::{sourcesdir}/features/scheduled_tasks_1.xml[]
----

In the example above, two tasks are declared, which invoke `someMethod()` and `someOtherMethod()` of the `++sales_Processor++` bean. `someMethod()` will be invoked at fixed time intervals (60 seconds) from the moment of application startup. `someOtherMethod()` is invoked according to the schedule specified by Cron expression (for the description of the format of such expressions, see http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger).

The actual launch of tasks is performed by the bean specified in the `scheduler` attribute of the `scheduled-tasks` element. It is the bean of the `CubaThreadPoolTaskScheduler` class which is configured in the *core* and *web* modules of the *cuba* application component (see `cuba-spring.xml`, `cuba-web-spring.xml`). This class provides some CUBA-specific housekeeping functionality.

In order to provide <<securityContext,SecurityContext>> to the code executed by Spring scheduled tasks on the middle tier, use <<system_authentication>>.

[[scheduled_tasks_cuba]]
===== CUBA Scheduled Tasks

*CUBA* scheduled tasks mechanism is intended to perform scheduled execution of arbitrary Spring beans methods on Middleware. The purposes of this mechanism and its distinction from the above mentioned standard *Spring Framework* schedulers are:

* The ability to configure tasks while running an application without restarting the server.

* The coordination of singleton tasks in the Middleware cluster, including: 

** Reliable protection from simultaneous execution.

** Binding tasks to servers by priorities.

A _singleton_ task is a task which must be executed only on one server at a certain moment of time. For example, reading from a queue and sending emails.

[[scheduled_tasks_cuba_reg]]
====== Task Registration

Tasks are registered in the `++SYS_SCHEDULED_TASK++` database table, which corresponds to the `ScheduledTask` entity. There are browser and editor screens for working with tasks, which are available through the *Administration* -> *Scheduled Tasks* menu.

Task attributes are described below:

* *Defined by* â€“ describes which software object implements the task. Possible values are:

** *Bean* â€“ the task is implemented by a method of a Spring <<managed_beans,managed bean>>. Additional attributes:

*** *Bean name* â€“ the name of the managed bean.
+
[WARNING]
====
The bean is listed and available for selection only if it is defined in the *core* module and has an interface, which contains methods appropriate for invocation from the task. Beans without an interface are not supported.
====

*** *Method name* â€“ the bean interface method that is executed. The method must either have no parameters, or all parameters must be of `String` type. The return type of the method can either be `void` or `String`. In the latter case the returning value will be stored in the executions table (see *Log finish* below).

*** *Method parameters* â€“ the parameters of the chosen method. Only `String` type parameters are supported.

** *Class* â€“ the task is a class that implements the `java.util.concurrent.Callable` interface. The class must have a public constructor without parameters. Additional attributes:

*** *Class name* â€“ the name of the class.

** *Script* â€“ the task is a Groovy script. The script is executed by <<scripting.runGroovyScript,Scripting.runGroovyScript()>>. Additional attributes:

*** *Script name* â€“ the name of the script.

* *User name* â€“ the name of a user on whose behalf the task will be executed. If not specified, the task will be executed on behalf of the user specified in the <<cuba.jmxUserLogin,cuba.jmxUserLogin>> application property.

* *Singleton* â€“ indicates that the task is a singleton, i.e. should be run only on one application server.

* *Scheduling type* â€“ the means of task scheduling:

** *Cron* â€“ Cron expression is a sequence of six fields, separated by spaces: second, minute, hour, day, month, day of a week. The month and the day of a week can be represented by the first three letters of their English names. Examples:

*** 0 0 * * * * â€“ the beginning of every hour of every day

*** */10 * * * * * â€“ every 10 seconds

*** 0 0 8-10 * * * â€“ every day at 8, 9 and 10 o'clock

*** 0 0/30 8-10 * * * â€“ every day at 8:00, 8:30, 9:00, 9:30 and 10 o'clock

*** 0 0 9-17 * * MON-FRI â€“ every hour from 9 to 17 on working days

*** 0 0 0 25 DEC ? â€“ every Christmas at midnight.

** *Period* â€“ task execution interval in seconds.

** *Fixed Delay* â€“ task will be executed with the specified in *Period* delay after completion of the preceding execution.

* *Period* â€“ task execution interval or delay in seconds if *Scheduling type* is *Period* or *Fixed Delay*.

* *Timeout* â€“ time in seconds, upon the expiration of which it is considered that the execution of the task is completed, regardless of whether there is information about task completion or not. If the timeout is not set explicitly, it is assumed to be 3 hours. 

* *Start date* â€“ the date/time of the first launch. If not specified, the task is launched immediately on server startup. If specified, the task is launched at `++startDate + period * N++`, where N is an integer.
+
It is reasonable to specify `Start date` only for "infrequent" tasks, i.e. running once an hour, once a day, etc.

* *Timeout* â€“ time in seconds, upon the expiration of which it is considered that the execution of the task is completed, regardless of whether there is information about task completion or not. If the timeout is not set explicitly, it is assumed to be 3 hours.

* *Time frame* â€“ if `Start date` is specified, `Time frame` defines the time window in seconds, during which the task will be launched after `++startDate + period * N++` time expires. If `Time frame` is not specified explicitly, it is equal to `period / 2`.
+
If `Start date` is not specified, `Time frame` is ignored, i.e. the task will be launched at any time after `Period` since the previous execution of the task expires.

* *Start delay* - delay of execution in seconds after the server is started and scheduling is activated. Set this parameter for a heavy task if you think that it slows down the server startup process.

* *Permitted servers* â€“ the list of comma-separated <<serverId,identifiers of servers>> that have the permission to run this task. If the list is not specified, the task may be executed on any server.
+
For singleton tasks, the order of the servers in the list defines the execution priority: the first server has a higher priority than the last. The server with a higher priority will intercept the execution of the singleton as follows: if the server with a higher priority detects that the task has been previously executed by a server with lower priority, it launches the task regardless of whether the `Period` has elapsed or not.
+
[WARNING]
====
Server priority works only if *Scheduling type* is `Period` and the *Start date* attribute is not specified. Otherwise, start occurs at the same time and the interception is impossible.
====

* *Log start* â€“ flags if the task launch should be registered in the `++SYS_SCHEDULED_EXECUTION++` table, which corresponds to the `ScheduledExecution` entity. 
+
In the current implementation, if the task is a singleton, the launch is registered regardless of this flag. 

* *Log finish* â€“ flags if the task completion should be registered in the `++SYS_SCHEDULED_EXECUTION++` table, which corresponds to the `ScheduledExecution` entity. 
+
In the current implementation, if the task is a singleton, completion is registered regardless of this flag. 

* *Description* â€“ an arbitrary text description of the task.

The task also has activity flag, which can be set in the tasks list screen. Inactive tasks are ignored.

[[scheduled_tasks_cuba_control]]
====== Tasks Handling Control

* <<cuba.schedulingActive,cuba.schedulingActive>> application property should be set to `true` to enable tasks processing. You can do it either in the *Administration > Application Properties* screen, or through the `app-core.cuba:type=Scheduling` JMX bean (see its `Active` attribute).

* All changes to tasks made via system screens take effect immediately for all servers in the cluster.

* The `removeExecutionHistory()` method of the `app-core.cuba:type=Scheduling` JMX bean can be used to remove old execution history. The method has two parameters:

** `age` â€“ the time (in hours) elapsed after the task execution.

** `maxPeriod` â€“ the maximum `Period` (in hours) for tasks that should have their execution history removed. This enables removing the history for frequently run tasks only, while keeping the history for tasks executed once a day.
+
The method can be invoked automatically. Create a new task with the following parameters:

*** *Bean name* â€“ `++cuba_SchedulingMBean++`

*** *Method name* â€“ `removeExecutionHistory(String age, String maxPeriod)`

*** *Method parameters* â€“ for example, `age` = 72, `maxPeriod` = 12.

[[scheduled_tasks_cuba_impl]]
====== Scheduling Implementation Details

* Tasks processing invocation (the `SchedulingAPI.processScheduledTasks()` method) interval is specified in `cuba-spring.xml` and is equal to 1 second by default. It sets the minimal interval between task launches, which should be twice higher, i.e. 2 seconds. Reducing these values is not recommended.

* The current implementation of the scheduler is based on the synchronization using row locks in the database table. This means that under significant load the database may not respond to the scheduler in time and it might be necessary to increase the launch interval (>1 second), thus the minimum period of launching tasks will be increased accordingly.

* If the `Permitted servers` attribute is not specified, singleton tasks are performed only on the master node of the cluster (in case other conditions are met). It should be kept in mind that a standalone server outside the cluster is also considered a master.

* The task will not be launched if its previous execution has not yet finished and the specified `Timeout` has not expired. For singleton tasks in the current implementation, this is achieved using the information in the database; for non-singletons, the execution status table is maintained in the server memory.

* The execution mechanism creates and caches <<userSession,user sessions>> for users, specified in the *User name* attribute of the tasks or in the <<cuba.jmxUserLogin,cuba.jmxUserLogin>> application property. The session is available in the execution thread of a launched task through the standard <<userSessionSource,UserSessionSource>> interface.

[WARNING]
====
Precise time synchronization of Middleware servers is required for correct execution of singleton tasks!
====

[[link_to_screen]]
==== Screen Links

The Web Client <<app_tiers,block>> enables opening application screens by commands provided in the URL. If the browser does not have an active session with a logged in user, the application will show the login screen first, and then, after successful authentication, proceed to the main application window with the requested screen.

The list of supported commands is defined by the <<cuba.web.linkHandlerActions,cuba.web.linkHandlerActions>> application property. By default, these are `open` and `o`. When the HTTP request is being processed, the last part of the URL is analyzed, and if it matches a registered command, control is passed to an appropriate processor, which is a bean implementing the `LinkHandlerProcessor` interface.

The platform provides a processor that accepts the following request parameters:

* `screen` â€“ name of the screen defined in <<screens.xml,screens.xml>>, for example:
+
[source, url]
----
http://localhost:8080/app/open?screen=sec$User.browse
----

* `item` â€“ an entity instance to be passed to the <<screen_edit,edit screen>>, encoded according to conventions of the `EntityLoadInfo` class, i.e. `entityName-instanceId` or `entityName-instanceId-viewName`. Examples:
+
[source, url]
----
http://localhost:8080/app/open?screen=sec$User.edit&item=sec$User-60885987-1b61-4247-94c7-dff348347f93

http://localhost:8080/app/open?screen=sec$User.edit&item=sec$User-60885987-1b61-4247-94c7-dff348347f93-user.edit
----
+
In order to create a new entity instance directly in the opened editor screen, add the `NEW-` prefix before the entity class name, for example:
+
[source, plain]
----
http://localhost:8080/app/open?screen=sec$User.edit&item=NEW-sec$User
----

* `params` â€“ parameters passed to the screen <<screen_controller,controller's>> `init()` method. Parameters are encoded as `name1:value1,name2:value2`. Parameter values may include entity instances encoded according to the conventions of the `EntityLoadInfo` class. Examples:
+
[source, url]
----
http://localhost:8080/app/open?screen=sales$Customer.lookup&params=p1:v1,p2:v2

http://localhost:8080/app/open?screen=sales$Customer.lookup&params=p1:sales$Customer-01e37691-1a9b-11de-b900-da881aea47a6
----

If you want to provide additional URL commands, do the following:

* Create a <<managed_beans,bean>> implementing the `LinkHandlerProcessor` interface in the *web* module of your project.

* The `canHandle()` method of your bean must return true if the current URL, which parameters are passed in the `ExternalLinkContext` object, should be processed by your bean.

* In the `handle()` method, perform required actions.

Your bean can optionally implement Spring's `Ordered` interface or contain the `Order` annotation. Then you can specify the order of your bean in the chain of processors. Use the `HIGHEST_PLATFORM_PRECEDENCE` and `LOWEST_PLATFORM_PRECEDENCE` constants of the `LinkHandlerProcessor` interface to put your bean before or after processors defined in the platform. So if you specify the order lesser than `HIGHEST_PLATFORM_PRECEDENCE`, your bean will be requested earlier and you can override actions defined by a platform processor if needed.

[[uniqueNumbers]]
==== Sequence Generation

This mechanism enables generating unique numerical sequences via a single API, independent of the DBMS type.

The main part of this mechanism is the `UniqueNumbers` <<managed_beans,bean>> with the `UniqueNumbersAPI` interface. The bean is available in the Middleware <<app_tiers,block>>. The interface has the following methods:

* `getNextNumber()` â€“ get the next value in a sequence. The mechanism enables simultaneous management of several sequences, identified by arbitrary strings. The name of the sequence from which you want to retrieve the value is passed in the `domain` parameter.
+
Sequences do not require initialization. When `getNextNumber()` is called for the first time, the corresponding sequence will be created and 1 will be returned.

* `getCurrentNumber()` â€“ obtain the current, i.e. the last generated value of the sequence. The `domain` parameter sets the sequence name.

* `setCurrentNumber()` â€“ set the current value of the sequence. This value incremented by 1 will be returned by the next call to `getNextNumber()`.

Below is an example of getting the next value in a sequence in a Middleware bean:

[source, java]
----
@Inject
private UniqueNumbersAPI uniqueNumbers;

private long getNextValue() {
  return uniqueNumbers.getNextNumber("mySequence");
}
----

The `getNextNumber()` method of the `UniqueNumbersService` <<services,service>> is used to get sequence values in client blocks. 

The `app-core.cuba:type=UniqueNumbers` <<jmx_beans,JMX bean>> with methods duplicating the methods of the `UniqueNumbersAPI` is used for sequence management.

The implementation of the sequence generation mechanism depends on the DBMS type. Sequence parameters can also be managed directly in the database, but in different ways.

* For HSQL, Microsoft SQL Server 2012+, PostgreSQL and Oracle each `UniqueNumbersAPI` sequence corresponds to a `++SEC_UN_{domain}++` sequence in the database.

* For Microsoft SQL Server before 2012 each sequence corresponds to a `++SEC_UN_{domain}++` table with a primary key of IDENTITY type.

* For MySQL sequences correspond to records in the `SYS_SEQUENCE` table.

[[userSession_log]]
==== User Session Log

This mechanism is designed for retrieving historical data on the users' login and logout by the system administrators. The logging mechanism is based on tracking <<userSession,user sessions>>. Each time the `UserSession` object is created, the log record is saved to the database containing the following fields:

* user session ID.

* user ID.

* <<user_substitution,substituted user>> ID.

* user's last action (login / logout / expiration / termination).

* remote IP address where login request came from.

* user session client type (web, desktop, portal).

* server ID (for example, `localhost:8080/app-core`).

* event start date.

* event end date.

* client information (session environment: OS, web browser etc).

By default, the user session logging mechanism is not activated. The simplest way to activate logging is using the *Enable Logging* button on the *Administration > User Session Log* application screen. Alternatively, you can use `cuba.UserSessionLogEnabled` application property.

If needed, you can create a report for the `sec$SessionLogEntry` entity.
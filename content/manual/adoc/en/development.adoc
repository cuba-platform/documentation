[[development]]
== Application Development

This chapter contains practical information on how to create platform-based applications.

[[recommended_code_style]]
=== Recommended Code Style

*Code Formatting*

* For Java and Groovy code, it is recommended to follow the standard style described in link:http://www.oracle.com/technetwork/java/codeconventions-150003.pdf[Code Conventions for the Java Programming Language]. When programming in *IntelliJ IDEA*, you can just use the default style and Ctrl-Alt-L shortcut for formatting.
+
The maximum line length is 120 characters. The indentation is 4 characters; using spaces instead of tabs is enabled.

* XML code: indentation is 4 characters; using spaces instead of tabs is enabled.

*Naming Conventions*

[cols="3*.^", frame="all", options="header"]
|===

^| Identifier ^| Naming Rule ^| Example

3+^| *Java and Groovy classes*

| Screen controller class
| UpperCamelCase

Browse screen controller `− {EntityClass}Browse`

Edit screen controller `− {EntityClass}Edit`.

| `CustomerBrowse`

`OrderEdit`

3+^| *XML screen descriptors*

| Component identifier, parameter names in queries
| lowerCamelCase, only letters and numbers.
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Datasource identifier
| lowerCamelCase, only letters and numbers ending with `Ds`.
| `attributesDs`

3+^| *SQL scripts*

| Reserved words| lowercase| `create table`

| Tables| UPPER_CASE. The name is preceded by the project name to form a namespace. It is recommended to use singular form in table names.| `++SALES_CUSTOMER++`

| Columns| UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

| Foreign key columns| UPPER_CASE. Consists of the table referred by the column (without the project prefix) and the _ID suffix.| `++CUSTOMER_ID++`

| Indexes| UPPER_CASE. Consists of the IDX_ prefix, name of the table that the index is created for (with the project prefix) and names of the fields included in the index.| `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Project File Structure

Below is the project file structure of a simple application, *Sales*, consisting of the *Middleware*, *Web Client* and *Web Portal* <<app_tiers,blocks>>.

.Project File Structure
image::project_structure.png[align="center"]

The project root contains build scripts (`build.gradle`, `settings.gradle`) and *IntelliJ IDEA* project files.

The `modules` directory includes the subdirectories of the project <<app_modules,modules>> − *global*, *core*, *gui*, *portal, web*.

.The global Module Structure
image::project_structure_global.png[align="center"]

The *global* module contains the source code directory, `src`, with configuration files – <<metadata.xml,metadata.xml>>, <<persistence.xml,persistence.xml>> and <<views.xml,views.xml>>. The `com.sample.sales.service` package contains interfaces of the *Middleware* services; the `com.sample.sales.entity` package contains <<data_model,entity>> classes and <<message_packs,localization files>> for them.

.The core Module Structure
image::project_structure_core.png[align="center"]

The *core* module contains the following directories:

* `db` – directory with the database <<db_scripts,create and update scripts>>.

* `src` – source code directory; its root contains the <<app_properties_files,application properties>> file of the *Middleware* block and the <<spring.xml,spring.xml>> configuration file. The `com.samples.sales.core` package contains the *Middleware* classes: implementations of <<services,services>>, <<managed_beans,managed beans>> and <<jmx_beans,JMX beans>>.

* `web` – directory with the configuration files of the web application built from the *Middleware* block: <<context.xml,context.xml>> and <<web.xml,web.xml>>.

.The gui Module Structure
image::project_structure_gui.png[align="center"]

The *gui* module includes the source code directory, `src`, with the <<screens.xml,screens.xml>> configuration file. The `com.sample.sales.gui` package contains XML descriptors and screen controllers, and <<message_packs,localization files>> for them.

.The web Module Structure
image::project_structure_web.png[align="center"]

The *web* module contains the following directories:

* `src` – source code directory with the <<app_properties_files,application properties>> file of the *Web Client* block and configuration files – <<menu.xml,web-menu.xml>>, <<permissions.xml,web-permissions.xml>>, <<screens.xml,web-screens.xml>> and <<spring.xml,web-spring.xml>>. The `com.samples.sales.web` package contains the main class of the *Web Client* block (inheritor of `DefaultApp`) and the <<main_message_pack,main localized messages pack>>.

* `web` – directory with configuration files of the web application built from the *Web Client*: <<context.xml,context.xml>> and <<web.xml,web.xml>>.

[[build_scripts]]
=== Build Scripts

Platform based projects are built using *Gradle* build system. Build scripts are two files in the project root directory:

* `settings.gradle` – defines the project name and the set of <<app_modules,modules>>.

* `build.gradle` – defines the build configuration.

This section describes the structure of the scripts and the purpose and parameters of Gradle tasks.

[[build.gradle]]
==== Structure of build.gradle

This section describes the structure and main elements of the `build.gradle` script.

buildscript::
+
--
The `buildscript` section of the script defines the following:

* A version of the platform.

* A set of <<artifact_repository, repositories>> for loading project dependencies. See how to configure access to the repositories <<access_to_repo,below>>.

* Dependencies used by the build system, including the CUBA Gradle plugin.

Below the `buildscript` section, a few variables are defined. They are used in the script later.
--

cuba::
+
--
The CUBA-specific build logic is encapsulated in the `cuba` Gradle plugin. It is included in the root of the script and in the `configure` section of all modules by the following statement:

[source, groovy]
----
apply(plugin: 'cuba')
----

The settings of the *cuba* plugin are defined in `cuba` section:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Let us consider the available options:

* `artifact` - this section defines the group and version of the project <<artifact, artifacts>> being built. Artifact names are based on module names specified in `settings.gradle`.

** `group` - artifact group.
** `version` - artifact version.
** `isSnapshot` - if `true`, artifact names will have the `SNAPSHOT` suffix.
+
You can override the artifact version from the command line, for example:
+
[source, plain]
----
gradle assemble -Pcuba.artifact.version=1.1.1
----

* `tomcat` - this section defines the settings of the Tomcat server which is used for <<fast_deployment, fast deployment>>.

** `dir` - location of the Tomcat <<build.gradle_setupTomcat, installation>> directory.
** `port` - listening port; 8080 by default.
** `debugPort` - Java debug listening port; 8787 by default.
** `shutdownPort` - port listening to the `SHUTDOWN` command; 8005 by default.
** `ajpPort` - AJP connector port; 8009 by default.

* `ide` - this section contains instructions for Studio and IDE.

** `vcs` - a version control system for the project. Only `Git` and `svn` are currently supported.
** `copyright` - copyright text to be inserted into beginning of each source file.
** `classComment` - comment text to be placed above class declarations in Java source files.

* `uploadRepository` - this section defines the settings of the <<artifact_repository, repository>> where assembled project artifacts will be uploaded to upon completion of the `uploadArchives` task.
+
** `url` - the repository URL. If not specified, Haulmont's repository is used.
** `user` - the repository user.
** `password` - the repository password.
+
You can pass the upload repository parameters from the command line with the following arguments:
+
[source]
----
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
----
--

dependencies::
+
--
This section contains a set of <<app_components,application components>> used by the project. Components are specified by their *global* module artifact. In the following example, three components are used: `com.haulmont.cuba` (*cuba* component of the platform), `com.haulmont.reports` (*reports* premium add-on) and `com.company.base` (a custom component):

[source, groovy]
----
dependencies {
  appComponent("com.haulmont.cuba:cuba-global:$cubaVersion")
  appComponent("com.haulmont.reports:reports-global:$cubaVersion")
  appComponent("com.company.base:base-global:0.1-SNAPSHOT")
}
----
--

configure::
+
--
The `configure` sections contain configuration of <<app_modules,modules>>. The most important part of the configuration is the declaration of dependencies. For example:

[source,groovy]
----
include::{sourcesdir}/development/build_gradle_2.groovy[]
----

Non-standard module dependencies can be specified in Studio on the *Project properties > Advanced* tab. See Studio context help for details.
--

[[access_to_repo]]
==== Configuring Access to Repository

Main Repository::
+
--
When you create a new project, you have to select a main repository containing CUBA artifacts. By default, there are two options (and you can have more if you set up a <<private_repo,private repository>>):

* `++https://repo.cuba-platform.com/content/groups/work++` - a repository located at Haulmont's server. It requires common credentials which are specified right in the build script (`cuba` / `cuba123`).

* `++https://dl.bintray.com/cuba-platform/main++` - a repository hosted at https://bintray.com[JFrog Bintray]. It has anonymous access.

Both repositories have identical contents for the latest platform versions, but Bintray does not contain snapshots. We assume that Bintray is more reliable for worldwide access.

In case of Bintray, the build script of the new project is also configured to use Maven Central, JCenter and Vaadin Add-ons repositories separately.
--

[[access_to_premium_repo]]
Access to CUBA Premium Add-ons::
+
--
If your project uses CUBA Premium Add-ons, Studio adds one more repository:

* In case of `repo.cuba-platform.com` it is `++https://repo.cuba-platform.com/content/groups/premium++`

* In case of Bintray it is `++https://cuba-platform.bintray.com/premium++`

If you use a <<private_repo,private repository>>, nothing is added automatically, because it is assumed that it proxies all CUBA repositories including premium ones.

Both Premium Add-ons repositories require a user name and a password which are provided by per-developer subscription. The first part of your license key before dash is the repository user name, the part after dash is the password. For example, if your key is `111111222222-abcdefabcdef`, then the user name is `111111222222` and the password is `abcdefabcdef`.

When you build the project from Studio, it passes repository credentials to Gradle automatically. If you want to build the project outside Studio, you can pass `premiumRepoUser` and `premiumRepoPass` in the command line arguments with `-P` prefix. In case of Bintray, the user name must be followed by `@cuba-platform`.

Example of building with `repo.cuba-platform.com`:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Example of building with Bintray:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222@cuba-platform -PpremiumRepoPass=abcdefabcdef
----

Instead of passing credentials each time you build the project from the command line, you can set them once in one of the following ways.

* Either create a `~/.gradle/gradle.properties` file and set properties in it:

[source]
----
premiumRepoUser=111111222222
premiumRepoPass=abcdefabcdef
----

* Or set the following environment variables for your operating system:

** `CUBA_PREMIUM_USER` - will be used if `premiumRepoUser` is not passed.

** `CUBA_PREMIUM_PASSWORD` - will be used if `premiumRepoPass` is not passed.
--

[[custom_repositories]]
Custom Repositories::
+
--
Your project can use any number of custom repositories containing <<app_components,application components>>. They should be specified in `build.gradle` manually *after* the main repository, for example:

[source,groovy]
----
include::{sourcesdir}/development/access_to_repo_1.groovy[]
----
--

[[build.gradle_tasks]]
==== Build Tasks

_Tasks_ are executable units in Gradle. They are defined both in the plugins and in the build script itself. Below are CUBA-specific tasks; their parameters can be configured in `build.gradle`.

[[build.gradle_buildInfo]]
===== buildInfo

The `buildInfo` task is automatically added to your `global` module configuration by the CUBA Gradle plugin. It writes the `build-info.properties` file with the information about your application into the `global` artifact (e.g. `app-global-1.0.0.jar`). This information is read by the `BuildInfo` bean at runtime and is displayed on the *Help > About* window. This bean can also be invoked by different mechanisms to get the information about the application name, version, etc.

You can optionally change the following task parameters:

* `appName` - application name. By default, the project name set in `settings.gradle` is used.

* `artifactGroup` - artifact group, which is by convention equal to the root package of the project.

* `version` - application version. By default, the version set in the `cuba.artifact.version` property is used.

* `properties` - a map of arbitrary properties, empty by default.

Example of specifying custom properties of the `buildInfo` task:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildInfo_1.groovy[]
----

[[build.gradle_buildUberJar]]
===== buildUberJar

`buildUberJar` – the task of the `CubaUberJarBuilding` type that creates JAR files containing the application code and all its dependencies together with embedded Jetty HTTP server. You can create either a single all-in-one JAR file or separate JARs for each application <<app_tiers,block>>, e.g. `app-core.jar` for the middleware and `app.jar` for the web client.

The task must be declared in the root of `build.gradle`. The resulting JAR files are located in the `build/distributions` project subdirectory. See the <<uberjar_deployment>> section for how to run the generated JAR files.

[TIP]
====
The task can be configured using the *Deployment settings > Uber JAR* page in Studio. See its context help for details.
====

Task parameters:

* `coreJettyEnvPath` - required parameter that defines a relative (from the project root) path to a file which contains JNDI resource definitions for Jetty HTTP server. The file must at least contain definition of a JDBC data source for the main database. Studio can generate this file on the basis of entered database connection parameters. You can also set it at run time using the `-jettyEnvPath` <<uberjar_deployment,command line>> argument.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    coreJettyEnvPath = 'modules/core/web/META-INF/jetty-env.xml'
    // ...
}
----

* `appProperties` - a map defining application properties. These properties will be added to the `WEB-INF/local.app.properties` files inside generated JARs.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    appProperties = ['cuba.automaticDatabaseUpdate' : true]
    // ...
}
----

* `singleJar` - if set to `true`, a single JAR containing all modules (core, web, portal) will be created. `false` by default.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    singleJar = true
    // ...
}
----

* `webPort` - port for single (if `singleJar=true`) or web JAR embedded HTTP server, `8080` if not defined. Can also be set at run time using the `-port` command line argument.

* `corePort` - port for core JAR embedded HTTP server, `8079` if not defined. Can also be set at run time using the `-port` <<uberjar_deployment,command line>> argument for the respective JAR.

* `portalPort` - port for portal JAR embedded HTTP server, `8081` if not defined. Can also be set at run time using the `-port` command line argument for the respective JAR.

* `appName` - name of the application, which is `app` by default. You can change it for the whole project if you set *Module prefix* field on the *Project Properties > Advanced* tab in Studio, or you can set it only for the `buildUberJar` task using this parameter. For example:
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    appName = 'sales'
    // ...
}
----
+
After changing the application name to `sales` the task will generate `sales-core.jar` and `sales.jar` files and the web client will be available at `++http://localhost:8080/sales++`. You can also change web contexts at run time without changing the application name using the `-contextName` <<uberjar_deployment,command line>> argument or just by renaming the JAR file itself.

* `logbackConfigurationFile` - defines a relative path to a file to be used for logging configuration.

* `webJettyConfPath` - a relative path to a file to be used for Jetty server configuration for the single (if `singleJar=true`) or web JAR (if `singleJar=false`). See https://www.eclipse.org/jetty/documentation/9.4.x/jetty-xml-config.html.

* `coreJettyConfPath` (do not confuse with `coreJettyEnvPath` described above) - a relative path to a file to be used for Jetty server configuration for the core JAR (if `singleJar=false`).

* `portalJettyConfPath` - a relative path to a file to be used for Jetty server configuration for the portal JAR (if `singleJar=false`).

* `coreWebXmlPath` - a relative path to a file to be used as a `web.xml` for the core module web application.

* `webWebXmlPath` - a relative path to a file to be used as a `web.xml` for the web module web application.

* `portalWebXmlPath` - a relative path to a file to be used as a `web.xml` for the portal module web application.

* `excludeResources` - a file pattern of resources to not include in JARs.

* `mergeResources` - a file pattern of resources to be merged in JARs.

* `webContentExclude` - a file pattern of web content to not include in web JAR.

* `coreProject` - a Gradle project representing the core module (Middleware). If not defined, the standard *core* module is used.

* `webProject` - a Gradle project representing the web module (Web Client). If not defined, the standard *web* module is used.

* `portalProject` - a Gradle project representing the portal module (Web Portal). If not defined, the standard *portal* module is used.

* `polymerProject` - a Gradle project representing the <<polymer_ui,Polymer UI>> module. If not defined, the standard *polymer-client* module is used.

* `polymerBuildDir` - the name of the directory where the <<polymer_build_and_structure,Polymer UI is built>>. It is `es6-unbundled` by default. Set this parameter if you have changed the build preset in `polymer.json`.

[[build.gradle_buildWar]]
===== buildWar

`buildWar` – the task of the `CubaWarBuilding` type, which builds a WAR file from the application code and its dependencies. It should be declared in the root of `build.gradle`. The resulting WAR file(s) are located in the `build/distributions` project subdirectory.

[TIP]
====
The task can be configured using the *Deployment settings > WAR* page in Studio. See its context help for details.
====

Any CUBA application consists of at least two <<app_tiers,blocks>>: Middleware and Web Client. So the most natural way to deploy an application is to create two separate WAR files: one for Middleware and one for Web Client. This also allows you to <<scaling,scale>> your application when the number of users grows. However, separate WAR files contain some duplicated dependencies that increase overall size. Besides, extended deployment options are often not needed and rather complicate the process. The `CubaWarBuilding` task can create both types of WAR files: one per block or single WAR containing both blocks. In the latter case, the application blocks are loaded into separate class loaders inside one web application.

Creating separate WAR files for Middleware and Web Client::
+
--
To create separate WAR files for Middleware and Web Client, use the following task configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Task parameters:

* `appHome` – the path to the <<app_home,application home>> directory. You can specify an absolute or relative path to the home directory, or a placeholder for Java system variable which should be set at server start.

* `appProperties` - an optional map defining <<app_properties,application properties>>. These properties will be added to the `/WEB-INF/local.app.properties` files inside generated WAR.
+
`appProperties = ['cuba.automaticDatabaseUpdate': 'true']` will create the database at the first launch, if there wasn't any.

* `singleWar` - should be set to `false` for building separate WAR files.

* `includeJdbcDriver` - include JDBC driver which is currently used in the project. `false` by default.

* `includeContextXml` - include Tomcat `context.xml` file which is currently used in the project. `false` by default.

* `coreContextXmlPath` - the relative path to a file which should be used instead of project's `context.xml` if `includeContextXml` is set to `true`.

* `hsqlInProcess` - if set to `true`, the database URL in `context.xml` will be modified for HSQL in-process mode.

* `coreProject` - the Gradle project representing the *core* module (Middleware). If not defined, the standard *core* module is used.

* `webProject` - the Gradle project representing the *web* module (Web Client). If not defined, the standard *web* module is used.

* `portalProject` - the Gradle project representing the *portal* module (Web Portal). Set this property if the application project contains the *portal* module. For example, `portalProject = project(':app-portal')`.

* `coreWebXmlPath`, `webWebXmlPath`, `portalWebXmlPath` - a relative path to a file to be used as a `web.xml` of the corresponding application block.
+
Example of using custom `web.xml` files:
+
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_4.groovy[]
----

* `polymerBuildDir` - the name of the directory where the <<polymer_build_and_structure,Polymer UI is built>>. It is `es6-unbundled` by default. Set this parameter if you have changed the build preset in `polymer.json`.
--

Creating a single WAR file::
+
--
To create a single WAR file that comprises both Middleware and Web Client blocks, use the following task configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

The following parameters should be specified in addition to the ones described above:

* `singleWar` - should be omitted or set to `true`.

* `webXmlPath` - the relative path to a file to be used as a `web.xml` of the single WAR. This file defines two servlet context listeners that load the application blocks: `SingleAppCoreServletListener` and `SingleAppWebServletListener`. All initialization parameters are passed to them through context parameters.
+
Example of `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Single WAR contains only *core* and *web* modules (Middleware and Web Client). To deploy the *portal* module, use separate WAR files.
--

See also <<war_deployment>> section for step-by-step instructions on some variants of WAR deployment.

[[build.gradle_buildWidgetSet]]
===== buildWidgetSet

`buildWidgetSet` - the task of the `CubaWidgetSetBuilding` which builds a custom GWT widgetset if the `web-toolkit` module exists in the project. This module enables development of <<own_components,custom visual components>>.

Available parameters:

* `style` - the script output style: `OBF`, `PRETTY` or `DETAILED`. `OBF` by default.

* `logLevel` - the logging level: `ERROR`, `WARN`, `INFO`, `TRACE`, `DEBUG`, `SPAM`, or `ALL`. `INFO` by default.

* `draft` - compile quickly with minimal optimizations. `false` by default.

Example usage:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWidgetSet_1.groovy[]
----

[[build.gradle_createDb]]
===== createDb

`createDb` – the task of the `CubaDbCreation` type which creates application database by executing the corresponding <<db_scripts,scripts>>. It is declared in the *core* module. Parameters:

* `dbms` – the <<dbms_types, DBMS type>>, specified as the string `hsql`, `postgres`, `mssql`, or `oracle`.

* `dbName` – the database name.

* `dbUser` – the DBMS username.

* `dbPassword` – the DBMS user password.

* `host` – the DBMS host and port (optional) in the `host[:port]` format. If not specified, `localhost` is used.

* `connectionParams` - an optional connection parameters string which will be appended to the end of the connection URL.

* `masterUrl` – the URL used to connect when creating the database. If not specified, the default value that depends on the DBMS type and the `host` parameter is used.

* `dropDbSql` – the SQL command to delete the database. If not specified, the default value that depends on the DBMS type is used.

* `createDbSql` – the SQL command to create a database. If not specified, the default value that depends on the DBMS type is used.

* `driverClasspath` – the list of JAR files containing the JDBC driver. The items in the list are separated by ":" on Linux and by ";" on Windows. If not specified, the system uses the dependencies that are part of the current module's `jdbc` configuration. Explicit definition of `driverClasspath` is necessary when using Oracle, because its JDBC driver is not available in the dependencies.

* `oracleSystemPassword` – the SYSTEM user password for Oracle.

Example for PostgreSQL:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----

Example for MS SQL Server:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
    connectionParams = ';instance=myinstance'
}
----

Example for Oracle:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_debugWidgetSet]]
===== debugWidgetSet

`debugWidgetSet` - the task of the `CubaWidgetSetDebug` type which launches GWT Code Server for debugging widgets in the browser.

Example usage:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
----

Ensure that the `web-toolkit` module has a dependency on Servlet API library in the `runtime` configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
----

See <<debug_widgets>> for information on how to debug code in the browser.

[[build.gradle_deploy]]
===== deploy

`deploy` – the task of the `CubaDeployment` type which performs <<fast_deployment,fast deployment>> of a module to Tomcat. It is declared in the *core*, *web* and *portal* modules. Parameters:

* `appName` – name of the web application that will be created from the module. In fact, it is the name of a subdirectory inside `tomcat/webapps`.

* `jarNames` – the list of JAR file names (without versions) produced as a result of building a module and intended to be placed into the `WEB-INF/lib` catalog of the web application. All other module artifacts and dependencies will be copied to `tomcat/shared/lib`.

For example:

[source, groovy]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
===== deployThemes

`deployThemes` - the task of the `CubaDeployThemeTask` type which builds and deploys <<web_theme,themes>> defined in the project to the running web application deployed by the <<build.gradle_deploy,deploy>> task. Changes in the themes are applied without the server restart.

For example:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_deployWar]]
===== deployWar

`deployWar` - the task of the `CubaJelasticDeploy` type which deploys the WAR file to Jelastic server.

[TIP]
====
The task can be configured using the *Deployment settings > Cloud* page in Studio. See its context help for details.
====

For example:

[source, groovy]
----
task deployWar(type: CubaJelasticDeploy, dependsOn: buildWar) {
   email = '<your@email.address>'
   password = '<your password>'
   context = '<app contex>'
   environment = '<environment name or ID>'
   hostUrl = '<Host API url>'
}
----

Task parameters:

* `appName` - the name of the web application. By default, it corresponds to the Modules prefix, e.g., `app`.

* `email` - Jelastic server account login.

* `password` - Jelastic account password.

* `context` - the application context. Default value: `ROOT`.

* `environment` - the environment where the application WAR will be deployed. You can set either the environment name or its ID.

* `hostUrl` - URL of the API host. Typically it is `app.jelastic.<host name>`.

* `srcDir` - the directory where the WAR is located. By default it is `"${project.buildDir}/distributions/war"`.

[[build.gradle_enhance]]
===== enhance

`enhance` – the task of the `CubaEnhancing` type which performs bytecode enhancement (weaving) of entity classes. It is declared in the *global* <<app_modules,module>>.

For example:

[source, groovy]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - allows you to specify the set of <<persistence.xml, persistence.xml>> files explicitly. If not set, the task will enhance all persistent entities listed in the `*persistence.xml` files located in the CLASSPATH.

* `metadataXml` - allows you to specify the <<metadata.xml, metadata.xml>> project file explicitly. If not set, the task will enhance all non-persistent entities listed in the `*metadata.xml` files located in the module source tree.

[[build.gradle_restart]]
===== restart

`restart` – the task that stops the local Tomcat server, runs <<fast_deployment,fast deployment>>, and starts the server once again.

[[build.gradle_setupTomcat]]
===== setupTomcat

`setupTomcat` – the task of the `CubaSetupTomcat` type which performs installation and initialization of the local Tomcat server for subsequent <<fast_deployment,fast deployment>> of the application. This task is automatically added to the project when you apply the *cuba* Gradle plugin, so you don't need to declare it in `build.gradle`. Tomcat installation directory is specified by the `tomcat.dir` property of the `cuba` section. By default, it is the project's `build/tomcat` subdirectory.

[[build.gradle_start]]
===== start

`start` – the task of the `CubaStartTomcat` type which starts the local Tomcat server installed by the <<build.gradle_setupTomcat,setupTomcat>> task. This task is automatically added to the project when you add the *cuba* plugin, so you don't need to declare it in `build.gradle`.

[[build.gradle_startDb]]
===== startDb

`startDb` – the task of the `CubaHsqlStart` type which starts the local HSQLDB server. Parameters:

* `dbName` – database name, default is `cubadb`.

* `dbDataDir` – database directory, default is the `deploy/hsqldb` subfolder of the project.

* `dbPort` – server port, default is 9001.

For example:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
----

[[build.gradle_stop]]
===== stop

`stop` – the task of `CubaStopTomcat` type which stops the local Tomcat server installed by the <<build.gradle_setupTomcat,setupTomcat>> task. This task is automatically added to the project when you include the *cuba* plugin, so you don't need to declare it in `build.gradle`.

[[build.gradle_stopDb]]
===== stopDb

`stopDb` – the task of the `CubaHsqlStop` type which stops the local HSQLDB server. The parameters are similar to `startDb`.

[[build.gradle_tomcat]]
===== tomcat

`tomcat` – the task of the `Exec` type which starts the local Tomcat server in the opened terminal window and keeps it open even if the start failed. This task may be useful for troubleshooting, e.g., to detect problems caused by Java version mismatch etc, on the server start.

[[build.gradle_updateDb]]
===== updateDb

`updateDb` – the task of the `CubaDbUpdate` type which updates the database by executing the corresponding <<db_scripts,scripts>>. It is similar to the `createDb` task, except that the `dropDbSql` and `createDbSql` parameters are omitted.

[[build.gradle_zipProject]]
===== zipProject

`zipProject` is the task of the `CubaZipProject` type which creates a ZIP archive of your project. The archive will not contain IDE project files, build results and Tomcat server. But HSQL database is included to the archive if present in the `build` directory.

This task is automatically added to the project when you apply the *cuba* Gradle plugin, so you don’t need to declare it in `build.gradle`.

[[build_task_start]]
==== Starting Build Tasks

Gradle tasks described in build scripts can be launched in the following ways:

* If you are working with the project in CUBA Studio, all commands under the *Build* and *Run* main menu items actually connect to the Gradle daemon (launched at the start of Studio server) and run corresponding tasks.

* Alternatively, you can use the executable `gradlew` script (Gradle wrapper) included in the project. The script should be located in the project root directory and can be created in Studio using the *Build* > *Create Gradle wrapper* command.

* One more way is to use the manually installed Gradle version {gradleVersion}. In this case, run the `gradle` executable located in the `bin` subdirectory of the Gradle installation.

[TIP]
====
It is recommended to run the `gradlew` and `gradle` commands with the `--daemon` argument; in this case the Gradle daemon is retained in memory, which significantly accelerates the subsequent execution.

To remove the daemon from memory, you can use the `--stop` argument.
====

For example, in order to compile the Java files and build the JAR files for project artifacts, you need to run the following command:

[source]
----
gradlew --daemon assemble
----

[WARNING]
====
If your project uses Premium Add-ons and you are starting build tasks outside Studio, you should pass the Premium Add-ons repository credentials to Gradle. See the section <<access_to_premium_repo, above>> for details.
====

Typical build tasks in their normal usage sequence are provided below.

* `idea`, `eclipse` – create IntelliJ IDEA or Eclipse project files. When this task is executed, dependencies with their source code are loaded from the artifact repository to the local Gradle cache.

* `cleanIdea`, `cleanEclipse` – remove IntelliJ IDEA or Eclipse project files.

* `assemble` – compile Java files and build JARs for project artifacts in the `build` subdirectories of the modules.

* `clean` – remove `build` subdirectories of all project modules.

* <<build.gradle_setupTomcat,setupTomcat>> – setup the Tomcat server to the path that is specified by the `cuba..tomcat.dir` property of the `build.gradle` script.

* <<build.gradle_deploy,deploy>> – deploy the application to the Tomcat server that has been pre-installed by the `setupTomcat` task.

* <<build.gradle_createDb,createDb>> – create an application database and run the corresponding <<db_scripts,scripts>>.

* <<build.gradle_updateDb,updateDb>> – update the existing application database by running the corresponding <<db_scripts,scripts>>.

* <<build.gradle_start,start>> – start the Tomcat server.

* <<build.gradle_stop,stop>> – stop the running Tomcat server.

* <<build.gradle_restart,restart>> – sequentially run the `stop`, `deploy`, `start` tasks.

[[private_repo]]
==== Setting Up a Private Artifact Repository

This section describes how to set up a private Maven repository and use it instead of the CUBA public repository for storing the platform artifacts and other dependencies. It is recommended in the following cases:

- You have an unstable or slow connection to the internet. In spite of the fact that Gradle caches downloaded artifacts on the developer's machine, you may need to connect to the artifact repository from time to time, for example when you run build for the first time or switch to a newer version of the platform.
-  You cannot have direct access to the internet due to a security policy of your organization.
-  You are not going to prolong your subscription to CUBA Premium Add-ons, but you need to be able to build your application in the future using the downloaded version of the artifacts.

The process of setting up a private repository consists of the following steps:

- Install the repository manager software in a network connected to the internet.
- Configure the private repository as a proxy for the CUBA public repository.
- Make your project build script use the private repository. It can be done in Studio or right in `build.gradle`.
- Perform full build of your project to cache all required artifacts in the private repository.

[[private_repo_install]]
===== Install the Repository Manager

For the purpose of this example, we will use Sonatype Nexus OSS repository manager and Microsoft Windows operating system.

- link:http://www.sonatype.org/downloads/nexus-latest-bundle.zip[Download] Sonatype Nexus OSS version 2.x (2.14.3 has been tested)
- Unpack zip file to the directory `c:\nexus-2.14.3-02`
- Modify settings located in file `c:\nexus-2.14.3-02\conf\nexus.properties`:
+
** You may configure server port; default is 8081
+
** Configure repository data folder:
+
--
replace
--
+
[source]
----
nexus-work=${bundleBasedir}/../sonatype-work/nexus
----
+
--
with any convenient path to cached data, for example
--
+
[source]
----
nexus-work=${bundleBasedir}/nexus/sonatype-work/content
----
- Navigate to the folder `c:\nexus-2.14.3-02\bin`
- To start and stop Nexus as a service, install the wrapper (run command as Administrator):
+
[source]
----
nexus.bat install
----

- Launch *nexus* service.
- Open `++http://localhost:8081/nexus++` in the web browser and log in with the default credentials: login `admin` and password `admin123`.

[[private_repo_configure]]
===== Configure the Proxy Repository

Click to the *Repositories* link on the left panel.

On the opened *Repositories* page click the *Add* button, then choose *Proxy Repository*. A new repository will be added. Fill in required fields at *Configuration* tab:

- *Repository ID*: `cuba-work`
- *Repository Name*: `cuba-work`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/work++`
- *Auto Blocking Enabled*: `false`
- Enable *Authentication*, set *Username*: `cuba`, *Password*: `cuba123`
- Click *Save* button.

Create a Repository Group, in Nexus click *Add* button, then choose *Repository Group* and do the following on *Configuration* tab:

- Enter the *Group ID*: `cuba-group`
- Enter the *Group Name*: `cuba-group`
- *Provider*: `Maven2`
- Add the repository *cuba-work* from *Available Repositories* to *Ordered Group Repositories*
- Click *Save* button.

If you have a subscription to the Premium Add-ons, add one more repository with the following settings:

- *Repository ID*: `cuba-premium`
- *Repository Name*: `cuba-premium`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/premium++`
- *Auto Blocking Enabled*: `false`
- Enable *Authentication*, set the first part of your license key (before dash) in the *Username* field and the second part of your license key (after dash) in the *Password* field.
- Click *Save* button.
- Click *Refresh* button.
- Select the *cuba-group* group.
- On the *Configuration* tab, add *cuba-premium* repository to the group below *cuba-work*.
- Click *Save* button.

[[private_repo_usage]]
===== Using the Private Repository

Now your private repository is ready to use. Find the *cuba-group* URL at the top of the screen, for example:
----
http://localhost:8081/nexus/content/groups/cuba-group
----

- If you are creating a new project, click the button next to the *Repository* field in the *New project* window.
- For an existing project, edit *Project properties* and click the button next to the *Repository* field.
- In the opened dialog, click *Add*, enter the repository URL and credentials: `admin / admin123`.
- Select the new repository and click *OK* to use it in the project.
- Save the *Project properties* page.
- Build the project.

During the first build your new repository downloads necessary artifacts and keeps them in the cache for the next usage. You may find them in `c:\nexus-2.14.3-02\sonatype-work` folder.

[[private_repo_in_isolated_network]]
===== Repository in an Isolated Network

If you need to develop on CUBA in a network without connection to the internet, do the following:

- Install a copy of the repository manager in the target network.

- Copy the cached content of the <<private_repo_configure,repository>> from the open network to the isolated one. If you followed the instructions above, the content is stored in
+
----
c:\nexus-2.14.3-02\sonatype-work
----

- Restart the *nexus* service.

If you need to add artifacts of a new platform version to the isolated repository, go to the environment connected to the internet, make a build through its repository and then copy the contents to the isolated environment again.

[[private_repo_studio_in_isolated_network]]
===== CUBA Studio in an Isolated Network

In order to use CUBA Studio in an isolated network, follow the steps below:

- Download https://services.gradle.org/distributions/[Gradle] (version {gradleVersion} is required) and install it onto developers machines.
- Open CUBA Studio Server window.
- Press *Advanced* button and set path to the folder where you have installed Gradle.
- Start the Studio server.
- Follow the steps <<private_repo_usage,above>> to configure your project.

[[project_creation]]
=== Creating a Project

The recommended way to create a new project is to use *CUBA Studio*. An example can be found in the <<qs_create_project,Quick Start>> chapter of this manual.

Once the project is created, you can keep developing it in the Studio, or create *IntelliJ IDEA* or *Eclipse* project files and open the project in the IDE.

[[logging]]
=== Logging

The platform uses *Logback* framework for logging.

To output to the log, use *SLF4J* API: get a logger for the current class and invoke one of its methods, for example:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
----

Logs for the Middleware, Web Client and Web Portal <<app_tiers,blocks>> are configured at the application server level; in <<fast_deployment,fast deployment>> mode the server is Tomcat. Logs for the Desktop Client block are configured separately.

[[logging_setup_tomcat]]
==== Setting up Logging in Tomcat

Running Gradle <<build.gradle_setupTomcat,setupTomcat>> task installs the Tomcat server into the project directory and performs its additional configuration. Particularly, `setenv.bat` and `setenv.sh` files are created in the `tomcat/bin` subfolder, and `logback.xml` is created in the `tomcat/conf` subfolder.

Among other things, the `setenv.*` files define loading parameters for the `logback.xml` configuration file using the `CATALINA_OPTS` variable.

`logback.xml` defines logging configuration. The file has the following structure:

* `appender` elements define the "output device" for the log. The main appenders are `FILE` and `CONSOLE`. The `level` parameter of `ThresholdFilter` defines the message threshold. By default, it is `DEBUG` for a file and `INFO` for console. It means that `ERROR`, `WARN`, `INFO` and `DEBUG` messages are written to a file, while `ERROR`, `WARN` and `INFO` are written to console.
+
The path to the log file for the file appender is defined in the `file` parameter. The default is `tomcat/logs/app.log`.

* `logger` elements define the logger parameters that are used to print messages from the program code. Logger names are hierarchical, i.e. the settings of the `com.company.sample` logger have effect on the `com.company.sample.core.CustomerServiceBean` and `com.company.sample.web.CustomerBrowse` loggers, if the loggers do not explicitly override the settings with their own.
+
Minimum logging level is defined by the `level` attribute. For example, if the category is `INFO`, then `DEBUG` and `TRACE` messages will not be logged. It should be kept in mind that message logging is also affected by the level threshold set in the appender.

You can quickly change logger levels and appender thresholds for a running server using the * Administration* > *Server log* screen available in the web client. Any changes to the logging settings are effective only during server runtime and are not saved to a file. The screen also enables viewing and loading log files from the server <<log_dir,logs folder>> (tomcat/logs).

The platform automatically adds the following information to the messages written to the file log:

* _application_ – the name of the web application that has logged the message. This information enables identifying messages from different application blocks (Middleware, Web Client), since they are written into the same file.

* _user_ – the login name of the user who invoked the code logging the message. This helps to track activity of a certain user in the log. If the code that logged a message was not invoked within a specific user session, the user information is not added.

For example, the following message has been written to the log by the code of the Middleware block (`app-core`), running under the `admin` user:

[source, log]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Setting up Logging in The Desktop Client

For the desktop client, the logback.xml file should be located in the source files directory of the project's *desktop* module. When an application is built, it is packed into the corresponding JAR file and is accessible in CLASSPATH.

Make the following steps to set up logging for your project:

* Create a new file, for example `sample-logback.xml`, in the `src` directory of the *desktop* module, and copy the contents of `cuba-logback.xml` to this new file. `cuba-logback.xml` file is located in one of the platform's JAR files and can be easily found using search in the IDE.

* Define path to a log file in the `file` parameter of the `FILE` appender.

* Add settings for loggers of your project.

* In the <<gui_desktop,inheritor class>> of `com.haulmont.cuba.desktop.App` of your project, for example `SampleApp`, override the `getDefaultLogConfig()` method and use it to return the path to your log file relative to the CLASSPATH root. For example:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* If necessary, you can override the location of the configuration file at the application start using <<logback.configurationFile,logback.configurationFile>> system property.

[[debugging]]
=== Debugging

This section explains how to use step-by-step debugging in CUBA applications.

[[debug_setup]]
==== Connecting a Debugger

You can start Tomcat server in debug mode by either running the <<build_task_start,Gradle task>>

`gradlew start`

or by running the `++bin/debug.*++` command file of the installed *Tomcat*.

After this, the server will accept debugger connections over port 8787. Port number can be changed in the `++bin/setenv.*++` file, in the `++JPDA_OPTS++` variable.

For debugging in *Intellij IDEA* you need to create a new *Remote* type *Run/Debug Configuration* element in the application project and set its *Port* property to 8787.

[[debug_version]]
==== Debug Version of Widgetset

The easiest way to debug the application on the client side without *GWT Super Dev Mode* is to use the debug configuration inside the *web* module configuration.

. Add the new debug configuration inside `webModule`:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_1.groovy[]
----

. Add the debug dependency inside the `dependencies` block of `webModule`:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_2.groovy[]
----
+
If the *charts* add-on is added, then `debug("com.haulmont.charts:charts-web-toolkit:$cubaVersion:debug@zip")` must be used.

. Add `deploy.doLast` task to the `webModule` configure block:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_3.groovy[]
----

The debug scenarios will be deployed in the `$cuba.tomcat.dir/webapps/app/VAADIN/widgetsets/com.haulmont.cuba.web.toolkit.ui.WidgetSet` directory of the project.

[[debug_widgets]]
==== Debugging Web Widgets

You can use *GWT Super Dev Mode* to debug web widgets on the browser side.

. Setup the <<build.gradle_debugWidgetSet,debugWidgetSet>> task in `build.gradle`.

. Deploy the application and start Tomcat.

. Run the `debugWidgetSet` task:
+
`gradlew debugWidgetSet`
+
The running GWT Code Server will recompile your widgetset on modification.

. Open `++http://localhost:8080/app?debug&superdevmode++` in Chrome web browser and wait for the widgetset is built for the first time.

. Open the debug console in Chrome:
+
image::debugWidgetSet_chrome_console.png[align="center"]

. After changing the Java code in the `web-toolkit` module, refresh the web page in the browser. The widgetset will be rebuilt incrementally in approximately 8-10 seconds.

[[testing]]
=== Testing

This section covers the ways of testing CUBA applications on different layers.

[[unit_tests]]
==== Unit Tests

Unit tests can be created and run both at the Middleware and the Client <<app_tiers,tiers>>. The platform includes link:http://junit.org[JUnit] and link:http://jmockit.github.io/[JMockit] frameworks for this purpose.

Let us assume you have the following screen controller:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

You can write the following test checking the `init()` method:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Middleware Integration Tests

In the middle tier, you can create integration tests which run in a fully functional Spring container connected to the database. In such tests you can run code from any layer of the Middleware, from services to ORM.

First, create the `test` directory in your *core* module next to the `src` directory. Re-create IDE project files to be able to run tests from the IDE.

The platform contains the `TestContainer` class which can be used as a base class for the test container in the application project. Create a subclass in the `test` directory of your *core* module and, in its constructor, redefine parameters for loading <<app_components, components>> and <<app_properties_files, application properties>> and test database connection parameters. For example:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

We recommend using a separate test database, which can be created, for example, by the following Gradle <<build.gradle_createDb, task>> defined in `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

The test container should be used in test classes as a JUnit rule specified by the `@ClassRule` annotation:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

In the example above, the test container is initialized once for all test methods of this class, and disposed after all of them finished.

As the container startup takes some time, you may want to initialize the container once for all tests contained in several test classes. In this case, create a common singleton instance of your test container:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

And use it in your test classes:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

Useful container methods::
+
--
The `TestContainer` class contains the following methods that can be used in the test code (see the `CustomerLoadTest` example above):

* `persistence()` – returns the reference to the <<persistence,Persistence>> interface.

* `metadata()` – returns the reference to the <<metadata,Metadata>> interface.

* `deleteRecord()` – this set of overloaded methods is aimed to be used in `@After` methods to clean up the database after tests.
--

Logging::
+
--
The test container sets up logging according to the `test-logback.xml` file provided by the platform. It is contained in the root of the `cuba-core-tests` artifact.

If you want to configure logging levels for your tests, do the following:

* Copy `test-logback.xml` from the platform artifact to the root of the `test` folder of your project's `core` module, e.g. as `my-test-logback.xml`.

* Configure appenders and loggers in `my-test-logback.xml`.

* Add a static initializer to your test container to specify the location of your logback configuration file in the `logback.configurationFile` system property:
+
[source, java]
----
include::{sourcesdir}/development/testing_9.java[]
----
--

Additional Data Stores::
+
--
If your project uses <<data_store,additional data stores>>, you should create corresponding JDBC data sources in your test container. For example, if you have `mydb` datastore which is a PostgreSQL database, add the following method to the test container class:

[source, java]
----
include::{sourcesdir}/development/testing_10.java[]
----
--

[[integration_tests_client]]
==== Client Tier Integration Tests

Client tier integration tests can be implemented using link:http://jmockit.github.io[JMockit] framework. It helps isolating the tests from the Middleware and creating the required infrastructure objects.

Client integration test class should be inherited from `CubaClientTestCase`. In the `@Before` method, you should call the inherited methods `addEntityPackage()`, `setViewConfig()` and then `setupInfrastructure()` to create <<metadata,Metadata>> and <<configuration,Configuration>> objects and deploy metadata for selected entities. Then, in the `@Before` method, you can extend the infrastructure with required mock objects using `Expectations` or `NonStrictExpectations`.

An example of an initialized `@Before` method from one of the platform tests:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

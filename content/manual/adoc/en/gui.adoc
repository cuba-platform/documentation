[[gui_framework]]
=== Generic User Interface

Generic user interface (Generic UI, GUI) subsystem allows you to create UI screens using XML and Java. The screens created using this approach work identically in both standard client <<app_tiers,blocks>>: Web Client and Desktop Client. 

.The Structure of Generic User Interface 
image::ClientStructure.png[align="center"]

Main components of Generic UI screens are marked as green:

* <<screen_xml,XML-descriptors>> – XML files containing information about datasources and screen layout.
* <<screen_controller,Controllers>> – Java classes containing logic for screen initialization and handling of events generated by UI controls.

The code of application screens included in the *gui* <<app_modules,module>> interacts with visual component interfaces (VCL Interfaces) implemented separately in the *web* and *desktop* modules of the *cuba* <<app_components,application component>>. For Web Client the implementation is based on the *Vaadin* framework, for Desktop Client on the *Java Swing* framework.

<<gui_vcl,Visual Components Library>> (VCL)contains a large set of ready-to-use components.

<<datasources,Datasources>> mechanism provides a unified interface that ensures functioning of data-aware visual components.

Client's infrastructure (Infrastructure) includes main application window, mechanisms for display and interaction of UI screens and means of interaction with the middleware.

[[screens]]
==== Screens

A generic UI screen is defined by an <<screen_xml,XML-descriptor>> and a <<screen_controller,controller>> class. The descriptor has a link to the controller class.

In order to be able to invoke the screen from the main menu or from Java code (e.g. from controller of a different screen) the XML-descriptor should be registered in the project's <<screens.xml,screens.xml>> file. The default screen that should be opened after login can be set using the <<cuba.web.defaultScreenId,cuba.web.defaultScreenId>> <<app_properties,application property>>.

The main menu of an application is generated separately for the Web Client and the Desktop Client based on the <<menu.xml,menu.xml>> files, located in the project's *web* and *desktop* modules.

[[screen_types]]
===== Screen Types

This section describes the following basic types of screens:

* <<frame,Frame>>
* <<screen_simple,Simple Screen>>
* <<screen_lookup,Lookup Screen>>
* <<screen_edit,Edit Screen>>
* <<screen_combined,Combined Screen>>

[[frame]]
====== Frame

Frames are reusable parts of screens. Frames are included in screens using the <<gui_Frame,frame>> XML element.

A frame controller must extend the <<abstractFrame,AbstractFrame>> class.

[TIP]
====
You can create a frame in Studio using the *Blank frame* template.
====

Below are the rules of interaction between a frame and its enclosing screen:

* Frame components can be referenced from a screen using dot: `++frame_id.component_id++`

* List of screen components can be obtained from a frame controller by invoking `++getComponent(component_id)++` method, but only if there is no component with the same name in the frame itself. I.e. frame components mask screen components.

* Screen <<datasources,datasource>> can be obtained from a frame by invoking `++getDsContext().get(ds_id)++` method or <<screen_controller_injection,injection>>, or using `++ds$ds_id++` in <<datasource_query,query>>, but only if the datasource with the same name is not declared in the frame itself (same as for components).

* From a screen, frame datasource can be obtained only by iterating the `getDsContext().getChildren()` collection.

The screen commit causes commit of modified datasources of all frames included in the screen.

[[screen_simple]]
====== Simple Screen

Simple screens enable displaying and editing of arbitrary information including individual instances and lists of entities. Screens of this type have only the core functionality for opening in the application's main window and working with <<datasources,datasources>>.

The controller of a simple screen must be inherited from the <<abstractWindow,AbstractWindow>> class.

[TIP]
====
You can create a simple screen in Studio using the *Blank screen* template.
====

[[screen_lookup]]
====== Lookup Screen

Lookup screens are designed to select and return instances or lists of entities. The standard <<lookupAction,LookupAction>> in visual components like <<gui_PickerField,PickerField>> and <<gui_LookupPickerField,LookupPickerField>> invokes lookup screens to select related entities.

When a lookup screen is invoked by the `openLookup()` method, it contains a panel with the buttons for selection. When a user selects an instance or multiple instances, the lookup screen invokes the handler which was passed to it, thus returning results to the calling code. When being invoked by `openWindow()` method or, for example, from the main menu, the selection panel is not displayed, effectively transforming the lookup screen into a <<screen_simple,simple screen>>.

The controller of a lookup screen should be inherited from the <<abstractLookup,AbstractLookup>> class. The `lookupComponent` attribute of the screen's XML must point to a component (for example <<gui_Table,Table>>), from which the selected entity instance should be taken as a result of the lookup.

[TIP]
====
You can create a lookup screen for an entity in Studio using the *Entity browser* or *Entity combined screen* templates.
====

By default, the <<lookupAction,LookupAction>> uses a lookup screen registered in <<screens.xml,screens.xml>> with the `{entity_name}.lookup` or `{entity_name}.browse` identifier, for example, `sales$Customer.lookup`. So make sure you have one when using components mentioned above. Studio registers browse screens with `{entity_name}.browse` identifiers, so they are automatically used as lookup screens.

[[screen_lookup_customization]]
Customization of the lookup screen look and behavior::
+
--
* To change the lookup panel (*Select* and *Cancel* buttons) for all lookup screens in the project, create a frame and register it with the `lookupWindowActions` identifier. The default frame is in `/com/haulmont/cuba/gui/lookup-window.actions.xml`. Your frame must contain a button linked to the `lookupSelectAction` action (which is added automatically to the screen when it is opened as a lookup).

* To replace the lookup panel in a certain screen, just create a button linked to the `lookupSelectAction` action in the screen. Then the default frame will not be added. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/screen_lookup_1.xml[]
----

* To replace the default select action with a custom one, just add your action in the controller:
+
[source, java]
----
include::{sourcesdir}/gui/screen_lookup_2.java[]
----
+
Use `com.haulmont.cuba.gui.components.SelectAction` as a base class for your action and override its methods when needed.
--

[[screen_edit]]
====== Edit Screen

Edit screen is designed to display and edit entity instances. It initializes the instance being edited and contains <<gui_Action,actions>> for committing changes to the database. Edit screen should be opened by the `openEditor()` method accepting an entity instance as an argument.

By default, the standard <<createAction,CreateAction>> and <<editAction,EditAction>> open a screen, registered in <<screens.xml,screens.xml>> with the `{entity_name}.edit` identifier, for example, `sales$Customer.edit`.

Edit screen controller must be inherited from the <<abstractEditor,AbstractEditor>> class.

[TIP]
====
You can create an edit screen for an entity in Studio using the *Entity editor* template.
====

The `datasource` attribute of a screen's XML should refer to a datasource containing the edited entity instance. The following standard button frames in the XML can be used to display actions that commit or cancel changes:

* `editWindowActions` (file `com/haulmont/cuba/gui/edit-window.actions.xml`) – contains *OK* and *Cancel* buttons

* `extendedEditWindowActions` (file `com/haulmont/cuba/gui/extended-edit-window.actions.xml`) – contains *OK & Close*, *OK* and *Cancel*

The following actions are implicitly initialized in the edit screen:

* `windowCommitAndClose` (corresponds to the `++Window.Editor.WINDOW_COMMIT_AND_CLOSE++` constant) – an action committing changes to the database and closing the screen. The action is initialized if the screen has a visual component with `windowCommitAndClose` identifier. The action is displayed as an *OK & Close* button when the mentioned above standard `extendedEditWindowActions` frame is used.

* `windowCommit` (corresponds to the `++Window.Editor.WINDOW_COMMIT++` constant) – an action which commits changes to the database. In absence of `windowCommitAndClose` action, closes the screen after committing. The action is always displayed as an *OK* button if the screen has the abovementioned standard frames.

* `windowClose` (corresponds to the `++Window.Editor.WINDOW_CLOSE++` constant) – which closes the screen without committing any changes. The action is always initialized. If the screen has the abovementioned standard frames, it is displayed as *Cancel* button.

Thus, if the screen contains an `editWindowActions` frame, the *OK* button commits the changes and closes the screen, and the *Cancel* button – closes the screen without committing the changes. If the screen contains an `extendedEditWindowActions` frame, the *OK* button only commits the changes, *OK & Close* button commits the changes and closes the screen, and the *Cancel* button closes the screen without committing the changes.

Instead of standard frames, the actions can be visualized using arbitrary components, for example, <<gui_LinkButton,LinkButton>>.

[[screen_combined]]
====== Combined Screen

The combined screen allows you to display a list of entities on the left and an edit form for a selected entity on the right. So it is a combination of <<screen_lookup,lookup>> and <<screen_edit,edit>> screens.

The controller of a combined screen should be inherited from the <<entityCombinedScreen,EntityCombinedScreen>> class.

[TIP]
====
You can create a combined screen for an entity in Studio using the *Entity combined screen* template.
====

[[screen_xml]]
===== XML-Descriptor

XML-descriptor is a file in XML format describing <<datasources,datasources>> and screen layout.

XML schema is available at {xsd_url}/window.xsd.

Descriptor has the following structure:

`window` − root element.

`window` attributes:

* `class` − name of a <<screen_controller,controller>> class.

* `messagesPack` − a default <<message_packs,message pack>> for the screen. It is used to obtain localized messages in the controller using `getMessage()` method and in the XML descriptor using message key without specifying the pack.

* `caption` − window caption, can contain a <<messageTools.loadString,link to a message>> from the above mentioned pack, for example, 
+
[source, properties]
----
caption="msg://credits"
----

* `focusComponent` − identifier of a component which should get input focus when the screen is displayed.

* `lookupComponent` – mandatory attribute for a <<screen_lookup,lookup screen>>; defines the identifier of a visual component that the entity instance should be selected from. Supports the following types of components (and their subclasses):

** `Table`

** `Tree`

** `LookupField`

** `PickerField`

** `OptionsGroup`

* `datasource` – mandatory attribute for an <<screen_edit,edit screen>> which defines the identifier of the <<datasources,datasource>> containing the edited entity instance.

`window` elements:

* `metadataContext` − the element initializing the <<views,views>> required for the screen. It is recommended to define all views in a single <<views.xml,views.xml>> file, because all view descriptors are deployed into a common repository, so it is difficult to ensure unique names if the descriptors are scattered across multiple files.

* `dsContext` − defines <<datasources,datasource>> for the screen.

* `dialogMode` - defines the settings of geometry and behaviour of the screen when it is opened as a dialog.
+
--
Attributes of `dialogMode`:

** `closeable` - defines whether the dialog window has close button. Possible values: `true`, `false`.

** `closeOnClickOutside` - defines if the dialog window should be closed by click on outside the window area, when the window has a modal mode. Possible values: `true`, `false`.

** `forceDialog` - specifies that the screen should always be opened as a dialog regardless of what `WindowManager.OpenType` was selected in the calling code. Possible values: `true`, `false`.

** `height` - sets the height of the dialog window.

** `maximized` - if the `true` value is set, the dialog window will be maximized across the screen. Possible values: `true`, `false`.

** `modal` - specifies the modal mode for the dialog window. Possible values: `true`, `false`.

** `positionX` - sets the `x` position of the top-left corner of the dialog window.

** `positionY` - sets the `y` position of the top-left corner of the dialog window.

** `resizable` - defines whether the user can change the size of the dialog window. Possible values: `true`, `false`.

** `width` - sets the width of the dialog window.

For example:

[source, xml]
----
include::{sourcesdir}/gui/dialogs_4.xml[]
----
--

* `actions` – defines the list of <<gui_Action,actions>> for the screen.

* `timers` – defines the list of timers for the screen.

* `companions` – defines the list of <<companions,companion>> classes for the screen controller.
+
--
Elements of `companions`:

** `web` – defines a companion implemented in the *web* module.

** `desktop` – defines a companion implemented in the *desktop* module.

Each of these elements contains `class` attribute defining the companion class.
--

* `layout` − root element of the screen layout, a container with a vertical layout of components, similar to <<gui_BoxLayout,vbox>>.
+
Attributes of `layout`:

** <<gui_attr_spacing,spacing>>

** <<gui_attr_margin,margin>>

** <<gui_attr_expand,expand>>

** <<gui_attr_stylename,stylename>>

** <<gui_attr_height,height>>

** <<gui_attr_width,width>>

[[screen_controller]]
===== Screen Controller

Screen controller is a Java or Groovy class, linked to an <<screen_xml,XML-descriptor>> and containing screen initialization and event handling logic.

Controller should be inherited from one of the following base classes:

* <<abstractFrame,AbstractFrame>> − for implementation of <<frame,frames>>.

* <<abstractWindow,AbstractWindow>> − for implementation of <<screen_simple,simple screens>>.

* <<abstractLookup,AbstractLookup>> − for implementation of <<screen_lookup,lookup screens>>.

* <<abstractEditor,AbstractEditor>> − for implementation of <<screen_edit,edit screens>>.

[TIP]
====
If a screen does not need additional logic, it can use the base class itself as a controller – `AbstractWindow`, `AbstractLookup` or `AbstractEditor`, by specifying it in the XML-descriptor (these classes are not actually abstract in a sense of impossibility of instantiating). For frames, controller class can be omitted.
====

Controller class should be registered in `class` attribute of the root element `window` in a screen's XML descriptor.

.Controller Base Classes
image::Controllers.png[align="center"]

[[abstractFrame]]
====== AbstractFrame

`AbstractFrame` is the root of the controller classes hierarchy. Below is the description of its main methods:

[[abstractFrame_init]]
* `init()` is called by the framework after creating components tree described by an XML-descriptor, but before a screen is displayed.
+
--
`init()` method accepts a map of parameters that can be used in controller. These parameters can be passed both from the controller of the calling screen (using `openWindow()`, `openLookup()` or `openEditor()` methods) or defined in the screen registration file <<screens.xml,screens.xml>>.

`init()` method should be implemented if it is necessary to initialize screen components, for example:

[source, java]
----
include::{sourcesdir}/gui/abstractframe_1.java[]
---- 
--

[[abstractFrame_getMessage]]
* `getMessage()`, `formatMessage()` – methods for retrieving localized messages from a <<message_packs,pack>>, defined for a screen in the XML-descriptor. They work as shortcuts for calling the corresponding methods of the <<messages,Messages>> interface.

[[abstractFrame_openFrame]]
* `openFrame()` – loads a frame according to an identifier registered in <<screens.xml,screens.xml>> file. If the method receives a container component from the invoking code, the frame is shown within the container. The method returns frame controller. For example:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_3.java[]
---- 
+
It is not required to pass the container immediately via `openFrame()` method, instead it is possible to load the frame first and then add it to the necessary container: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_4.java[]
---- 

[[abstractFrame_openWindow]]
* `openWindow()`, `openLookup()`, `openEditor()` – open a simple screen, a lookup screen, or an edit screen respectively. Methods return a controller of the created screen.
+
For the dialog mode, the method `openWindow()` can be called with parameters, for example:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_7.java[]
----
These parameters will be considered if they don't conflict with the higher-priority parameters of the window being opened. The latter can be set either in the <<dialogOptions,getDialogOptions()>> method of screen controller or in <<screen_xml,XML descriptor>> of the screen:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_8.xml[]
----
+
`CloseListener` can be added in order to perform actions after the invoked screen closes, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5.java[]
---- 
+
Use `CloseWithCommitListener` to be notified only when the invoked screen closes by an action with the `Window.COMMIT_ACTION_ID` name (i.e. *OK* button), for example:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5_1.java[]
----

[[abstractFrame_showMessageDialog]]
* `showMessageDialog()` – shows a dialog box with a message.

[[abstractFrame_showOptionDialog]]
* `showOptionDialog()` – shows a dialog box with a message and an option for user to invoke certain actions. Actions are defined by an array of <<gui_Action,Action>> type items displayed as buttons in the dialog.
+
It is recommended to use `DialogAction` objects for display of standard buttons such as *OK*, *Cancel* and other, for example:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_6.java[]
---- 

[[abstractFrame_showNotification]]
* `showNotification()` – shows a pop up notification.

[[abstractFrame_showWebPage]]
* `showWebPage()` – opens specified web page in a browser.

'''

API::
<<abstractFrame_getMessage,formatMessage()>> -
<<abstractFrame_getMessage,getMessage()>> -
<<abstractFrame_init,init()>> -
<<abstractFrame_openFrame,openFrame()>> -
<<abstractFrame_openWindow,openEditor()>> -
<<abstractFrame_openWindow,openLookup()>> -
<<abstractFrame_openWindow,openWindow()>> -
<<abstractFrame_showMessageDialog,showMessageDialog()>> -
<<abstractFrame_showNotification,showNotification()>> -
<<abstractFrame_showOptionDialog,showOptionDialog()>> -
<<abstractFrame_showWebPage,showWebPage()>>

'''
[[abstractWindow]]
====== AbstractWindow

`AbstractWindow` is a subclass of <<abstractFrame,AbstractFrame>> and defines the following methods:

[[dialogOptions]]
* `getDialogOptions()` – returns a `DialogOptions` object to control geometry and behaviour of the screen when it is opened as a dialog  (`WindowManager.OpenType.DIALOG`). These options can be set when the screen is initialized as well as can be changed at a runtime. See the examples below.
+
Setting the width and height:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_2.java[]
----
+
Setting the dialog position on the screen:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_9.java[]
----
+
Making the dialog closeable by click on outside area:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_7.java[]
----
+
Making the dialog non-modal and resizable:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_3.java[]
----
+
Defining whether the dialog should be maximized across the screen:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_8.java[]
----
+
Specifying that the screen should always be opened as a dialog regardless of what `WindowManager.OpenType` was selected in the calling code:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_4.java[]
----

[[abstractWindow_contentSwitchMode]]
* `setContentSwitchMode()` - defines how the <<cuba.web.mainTabSheetMode,managed main TabSheet>> should switch a tab with the given window: hide it or unload its content.
+
--
Three options are available:

* `DEFAULT` - the switch mode is determined by the managed main TabSheet mode, defined in the <<cuba.web.managedMainTabSheetMode,cuba.web.managedMainTabSheetMode>> application property.

* `HIDE` - the tab content should be hidden not considering the TabSheet mode.

* `UNLOAD` - tab content should be unloaded not considering the TabSheet mode.
--

[[abstractWindow_saveSettings]]
* `saveSettings()` - saves the screen settings of the current user to the database when the screen is closed.
+
For example, the screen contains a checkBox *showPanel* that manages some panel's visibility. In the following method we create an XML element for the checkBox, then add an attribute `showPanel` containing the checkBox value to this element, and finally we save the `settings` element to the XML descriptor for the current user in the database:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_6.java[]
----

[[abstractWindow_applySettings]]
* `applySettings()` - restores settings saved in the database for the current user when the screen is opened.
+
This method can be overridden to restore custom settings. For example, in the method below we get the XML element of the checkBox from the previous example, then we make sure the required attribute is not null, and if it isn't, we set the restored value to the checkBox:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_5.java[]
----
+
Another example of managing settings is the standard *Server Log* screen from the *Administration* menu of CUBA application that automatically saves and restores recently opened log files.

[[abstractWindow_ready]]
* `ready()` - a template method that can be implemented in controller to intercept the moment of screen opening. It is invoked when the screen is fully initialized and opened.

[[abstractWindow_validateAll]]
* `validateAll()` – validates a screen. The default implementation calls `validate()` for all screen components implementing the `Component.Validatable` interface, collects information about exceptions and displays corresponding message. Method returns `false`, if any exceptions were found; and `true` otherwise.
+
This method should be overridden only if it is required to override screen validation procedure completely. It is sufficient to implement a special template method – `postValidate()`, if validation should be just supplemented.

[[abstractWindow_postValidate]]
* `postValidate()` – a template method that can be implemented in controller for additional screen validation. The method stores validation errors information in `ValidationErrors` object which is passed to it. Afterwards this information is displayed together with the errors of standard validation. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_1.java[]
---- 

[[abstractWindow_showValidationErrors]]
* `showValidationErrors()` - shows validation errors alert. It can be overridden to change the default alert behavior. The notification type can be defined by the <<cuba.gui.validationNotificationType,cuba.gui.validationNotificationType>> application property.
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_10.java[]
----

[[abstractWindow_close]]
* `close()` – closes this screen. 
+
The method accepts string value, which is then passed to `preClose()` template method and to `CloseListener` listeners. Thus, the information about the reason why the window was closed can be obtained from the code that initiated the closing event. It is recommended to use the following constants for closing edit screens: `++Window.COMMIT_ACTION_ID++` after committing changes, `++Window.CLOSE_ACTION_ID++` – without committing changes.
+
If any of the datasources contains unsaved changes, a dialog with a corresponding message will be displayed before the screen is closed. Notification type may be adjusted using the <<cuba.gui.useSaveConfirmation,cuba.gui.useSaveConfirmation>> application property.
+
A variant of `close()` method with `force = true` parameter closes the screen without calling `preClose()` and without a notification regardless of any unsaved changes.
+
`close()` method returns `true`, if the screen is closed successfully, and `false` – if closing procedure was interrupted.

[[abstractWindow_preClose]]
* `preClose()` is a template method which can be implemented in a controller to intercept the moment when the window closes. The method receives a string value provided by the closing initiator when invoking `close()` method.
+
If the `preClose()` method returns `false`, the window closing process is interrupted.

[[abstractWindow_addBeforeCloseWithCloseButtonListener]]
* `addBeforeCloseWithCloseButtonListener()` - adds a listener to be notified when a screen is closed with one of the following approaches: the screen's close button, bread crumbs, or `TabSheet` tabs' close actions (Close, Close All, Close Others). To prevent a user from closing a window accidentally, invoke the `preventWindowClose()` method of `BeforeCloseEvent`:
+
[source, java]
----
addBeforeCloseWithCloseButtonListener(BeforeCloseEvent::preventWindowClose);
----

[[abstractWindow_addBeforeCloseWithShortcutListener]]
* `addBeforeCloseWithShortcutListener` - adds a listener to be notified when a screen is closed with a close shortcut (for example, `Esc` button). To prevent a user from closing a window accidentally, invoke the `preventWindowClose()` method of `BeforeCloseEvent`:
+
[source, java]
----
addBeforeCloseWithShortcutListener(BeforeCloseEvent::preventWindowClose);
----

'''

API::
<<abstractWindow_addBeforeCloseWithCloseButtonListener,addBeforeCloseWithCloseButtonListener()>> -
<<abstractWindow_addBeforeCloseWithShortcutListener,addBeforeCloseWithShortcutListener()>> -
<<abstractWindow_applySettings,applySettings()>> -
<<abstractWindow_close,close()>> -
<<abstractWindow_contentSwitchMode,setContentSwitchMode()>> -
<<dialogOptions,getDialogOptions()>> -
<<abstractWindow_postValidate,postValidate()>> -
<<abstractWindow_preClose,preClose()>> -
<<abstractWindow_ready,ready()>> -
<<abstractWindow_saveSettings,saveSettings()>> -
<<abstractWindow_validateAll,validateAll()>>

'''

[[abstractLookup]]
====== AbstractLookup

`AbstractLookup` is the base class for <<screen_lookup,lookup screen>> controllers. It is a subclass of <<abstractWindow,AbstractWindow>> and defines the following own methods:

[[abstractLookup_setLookupComponent]]
* `setLookupComponent()` – sets the component, which will be used to select entity instances.
+
As a rule, component for selection is defined in screen XML-descriptor and there is no need to call this method in the application code.

[[abstractLookup_setLookupValidator]]
* `setLookupValidator()` – sets `Window.Lookup.Validator` object to the screen, which `validate()` method is invoked by the framework before returning selected entity instances. If `validate()` method returns `false`, the lookup and window closing process is interrupted.
+
By default, the validator is not set.

'''

API::
<<abstractLookup_setLookupComponent,setLookupComponent()>> -
<<abstractLookup_setLookupValidator,setLookupValidator()>>

'''

[[abstractEditor]]
====== AbstractEditor

`AbstractEditor` is the base class for <<screen_edit,edit screen>> controller. It is a subclass of <<abstractWindow,AbstractWindow>>.

When creating a controller class, it is recommended to parameterize `AbstractEditor` with the edited entity class. This enables `getItem()` and `initNewItem()` methods work with the specified entity type and application code does not need to do additional type conversion. For example:

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_1.java[]
---- 

`AbstractEditor` defines the following own methods:

[[abstractEditor_getItem]]
* `getItem()` – returns an instance of the entity being edited, which is set in the main <<datasources,datasource>> of the screen (i.e. specified in the `datasource` attribute of the root element of the XML-descriptor).
+
If the instance being edited is not a new one, screen opening procedure will reload the instance from the database with the required <<views,view>> as set for the main datasource.
+
Changes made to the instance returned by `getItem()`, are reflected in the state of the datasource and will be sent to the Middleware at commit.
+
[WARNING]
====
It should be considered that `getItem()` returns a value only after screen is initialized with `setItem()` method. Until this moment, this method returns `null`, for instance when calling from inside `init()` or `initNewItem()`.

However, in the `init()` method, an instance of an entity passed to `openEditor()` can be retrieved from parameters using the following approach: 

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_2.java[]
---- 

The `initNewItem()` method receives an instance as a parameter of the appropriate type.

In both cases the obtained entity instance will be reloaded afterwards unless it is a new one. Therefore you should not change it or save it in a field for future use.
====

[[abstractEditor_setItem]]
* `setItem()` – invoked by the framework when a window is opened using `openEditor()` to set the instance being edited to the main datasource. By the moment of invocation all screen components and datasources will have been created and the controller's `init()` method will have been executed.
+
It is recommended to use template methods `initNewItem()` and `postInit()`, instead of overriding `setItem()` in order to initialize a screen. 

[[initNewItem]]
* `initNewItem()` – a template method invoked by the framework before setting the edited entity instance into the main datasource.
+
The `initNewItem()` method is called for newly created entity instances only. The method is not called for <<entity_states,detached>> instances. This method can be implemented in the controller, if new entity instances must be initialized before setting them in the datasource. For example:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_3.java[]
---- 
+
A more complex example of using the `initNewItem()` method can be found in the <<init_values_in_initNewItem,cookbook>>.

[[abstractEditor_postInit]]
* `postInit()` – a template method invoked by the framework immediately after the edited entity instance is set to the main datasource. In this method, `getItem()` can be called to return a new entity instance or an instance re-loaded during screen initialization.
+
This method can be implemented in controller for final screen initialization, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_4.java[]
---- 

[[abstractEditor_commit]]
* `commit()` – validates the screen and submits changes to the Middleware via <<dataSupplier,DataSupplier>>.
+
If a method is used with `validate = false`, commit does not perform a validation.
+
It is recommended to use specialized template methods – `postValidate()`, `preCommit()` and `postCommit()` instead of overriding this method.

[[abstractEditor_commitAndClose]]
* `commitAndClose()` – validates the screen, submits changes to the Middleware and closes the screen. The value of the `++Window.COMMIT_ACTION_ID++` will be passed to the `preClose()` method and registered `CloseListener` listeners. 
+
It is recommended to use specialized template methods – `postValidate()`, `preCommit()` and `postCommit()` instead of overriding this method.

[[abstractEditor_preCommit]]
* `preCommit()` – a template method invoked by the framework during the commit process, after a successful validation, but before the data is submitted to the Middleware.
+
This method can be implemented in controller. If the method returns `false`, commit process gets interrupted, as well as window closing process (if `commitAndClose()` was invoked). For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_5.java[]
---- 

[[abstractEditor_postCommit]]
* `postCommit()` – a template method invoked by the framework at the final stage of committing changes. Method parameters are:

** `committed` – set to `true`, if the screen had changes and they have been submitted to Middleware.

** `close` – set to `true`, if the screen should be closed after the changes are committed.
+
If the screen does not close the default implementation of this method displays a message about successful commit and invokes `postInit()`.
+
This method can be overridden in controller in order to perform additional actions after successful commit, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_6.java[]
----

The diagrams below show initialization sequence and different ways to commit changes for an edit screen.

.Edit Screen Initialization
image::EditorInit.png[align="center"]

.Committing And Closing a Window With an editWindowActions Frame
image::EditorCommit.png[align="center"]

.Committing a Screen With an extendedEditWindowActions Frame
image::ExtendedEditorCommit.png[align="center"]

.Committing a Screen With an extendedEditWindowActions Frame
image::ExtendedEditorCommitAndClose.png[align="center"]

'''

API::

<<abstractEditor_commit,commit()>> -
<<abstractEditor_commitAndClose,commitAndClose()>> -
<<abstractEditor_getItem,getItem()>> -
<<initNewItem,initNewItem()>> -
<<abstractEditor_postCommit,postCommit()>> -
<<abstractEditor_postInit,postInit()>> -
<<abstractEditor_preCommit,preCommit()>> -
<<abstractEditor_setItem,setItem()>>

'''

[[entityCombinedScreen]]
====== EntityCombinedScreen

`EntityCombinedScreen` is the base class for <<screen_combined,combined screen>> controllers. It is a subclass of <<abstractLookup,AbstractLookup>>.

The `EntityCombinedScreen` class looks up key components such as table, field group and others by hardcoded identifiers. If you name your components differently, override protected methods of the class and return your identifiers to let the controller find your components. See the class JavaDocs for details.

[[screen_controller_injection]]
====== Controller Dependency Injection

Dependency Injection in controllers can be used to acquire references to utilized objects. For this purpose it is required to declare either a field of the corresponding type or a write access method (setter) with an appropriate parameter type and with one of the following annotations:

* `@Inject` – the simplest option, where an object for injection will be found according to the field/method type and the name of the field or attribute corresponding to the method according to JavaBeans rules.

* `@Named("someName")` – explicitly defines the name of the target object.

The following objects can be injected into controllers: 

* This screen's visual components defined in the XML-descriptor. If the attribute type is derived from `Component`, the system will search for a component with the corresponding name within the current screen. 

* Actions defined in the XML-descriptor – see <<gui_Action>>.

* <<datasources,Datasources>> defined in the XML-descriptor. If the attribute type is derived from `Datasource`, the system will search for a datasource with the corresponding name in the current screen.

* `UserSession`. If the attribute type is <<userSession,UserSession>>, the system will inject an object of the current user session.

* `DsContext`. If the attribute type is `DsContext`, the system will inject the `DsContext` of the current screen.

* `WindowContext`. If the attribute type is `WindowContext`, the system will inject the `WindowContext` of the current screen. 

* `DataSupplier`. If the attribute type is <<dataSupplier,DataSupplier>>, the corresponding instance will be injected.

* Any bean defined in the context of a given client block, including:

**  Middleware <<services,services>> imported by Client

** `ComponentsFactory`

** `WindowConfig`

** `ExportDisplay`

** <<background_tasks,BackgroundWorker>>

* If nothing of the mentioned above is appropriate and the controller has <<companions,companions>>, a companion for the current client type will be injected, if the types match.

[[screen_controller_injection_params]]
It is possible to inject parameters passed in a map to the `init()` method into the controller using `@WindowParam` annotation. The annotation has the `name` attribute which contains the parameter name (a key in the map) and an optional required attribute. If `required = true` and the map does not contain the corresponding parameter a `WARNING` message is added to the log.

An example of the injection of a `Job` entity passed to the controller's `init()` method:

[source, java]
----
include::{sourcesdir}/gui/cdi_1.java[]
---- 

[[companions]]
====== Controller Companions

Controller base classes are located in the *gui* <<app_modules,module>> of the *cuba* <<app_components,application component>> and do not contain references to the implementation of visual component classes (*Swing* or *Vaadin*). This allows you to use them in both types of clients.

At the same time concrete controller classes can be created in *gui*, *web* or *desktop* modules, depending on screen specifics and client <<app_tiers,blocks>> used in the project. If a controller is common for all client types but additional functionality is required for different client types, it can be implemented in so-called _companion classes_.

Companion class is located in client module of the corresponding client type (web or desktop) and implements an interface defined in the controller that uses the companion class. A companion class should be defined in the `companions` element of the screen XML-descriptor. Controller can retrieve a reference to the companion instance using injection or by invoking `getCompanion()`, and then pass control to the companion instance when appropriate, e.g. for extended initialization of visual components in a way specific to a given client type.

For example, on some screen, you need to initialize a table differently for web and desktop clients. Then in the screen controller located in *gui* module, define a companion interface and delegate the table initialization to it:

[source, java]
----
include::{sourcesdir}/gui/companion_1.java[]
----

Create companion implementations in *web* and *desktop* modules:

[source, java]
----
include::{sourcesdir}/gui/companion_2.java[]
----

[source, java]
----
include::{sourcesdir}/gui/companion_3.java[]
----

And register the implementation classes in the screen XML descriptor:

[source, xml]
----
include::{sourcesdir}/gui/companion_4.xml[]
----

The companion classes are located in *web* and *desktop* modules, therefore you can use  <<webComponentsHelper,WebComponentsHelper.unwrap()>> and <<desktopComponentsHelper,DesktopComponentsHelper.unwrap()>> to get references to Vaadin and Swing components implementing the table.

[[screen_agent]]
===== Screen Agent

Screen agent enables choosing a screen template according to the current device and display parameters. For example, you can create two screens with different layouts (and possibly different functionality), and register them in <<screens.xml,screens.xml>> with the same identifier. Then at runtime, the platform will choose a screen that better conforms to the display from which the user accesses the application.

There are three predefined screen agents in the platform: `DESKTOP`, `TABLET`, `PHONE`. They are defined by the following classes respectively: `DesktopScreenAgent`, `TabletScreenAgent`, `PhoneScreenAgent`. You can define your own agents by creating <<managed_beans,managed beans>> implementing the `ScreenAgent` interface.

A screen agent is specified for a screen in the <<screens.xml,screens.xml>> file. The value of the `agent` attribute should be either one of the predefined constants listed above or a name of the custom bean implementing `ScreenAgent`.

In Studio, an agent is specified on the *Properties* tab of the screen designer page.


include::gui_vcl.adoc[]

[[datasources]]
==== Datasources

Datasources provide data to data-aware components.

Visual components themselves do not access Middleware: they get entity instances from linked datasources. Furthermore, one datasource can work with multiple visual components if they need the same instance or set of instances.

* When a user changes a value in the component, the new value is set for the entity attribute in the datasource.

* When the entity attribute is modified in the code, the new value is set and displayed in the visual component.

* User input can be monitored both by <<datasource_listeners,datasource listeners>> and value listeners on the component – they are notified sequentially.

* To read or write the value of an attribute in the application code, it is recommended to use the datasource, rather than the component. Below is an example of reading the attribute:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_1.java[]
---- 
+
As you can see, working with entity attribute values through a component is not very straightforward. In the first example, it requires type casting and specifying <<gui_FieldGroup,FieldGroup>> field `id` as a string. The second example is more safe and direct, but requires you to know exactly the type of the field to be <<screen_controller_injection,injected>>. At the same time, if the instance is obtained from the datasource via the `getItem()` method, the values of attributes can be read and modified directly.

Datasources also track changes in entities contained therein and can send modified instances back to the middleware for storing in the database.

[WARNING]
====
Typically, a visual component is bound to an attribute that directly belongs to the entity in the datasource. In the example above, the component is bound to the `customer` attribute of the `Order` entity.

A component can also be associated with an attribute of a related entity, for example, `customer.name`. In this case, the component will display the value of the `name` attribute, however when the user changes the value, the datasource listeners will not be invoked and the changes will not be saved. Therefore, it makes sense to bind the component to second-level entity attributes only if they are intended for display. For example in a <<gui_Label,Label>>, a <<gui_Table,Table>> column, or in a <<gui_TextField,TextField>>, where `editable = false`.
====

The basic interfaces of datasources are described below.

.Datasource interfaces
image::Datasources.png[align="center"]

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/Datasource.html[Datasource] is a simple datasource designed to work with one entity instance. The instance is set by the `setItem()` method and is accessed via `getItem()`.
+
`DatasourceImpl` class is the standard implementation of such datasource, which is used, for instance, as a main datasource on entity <<screen_edit,edit screens>>.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/CollectionDatasource.html[CollectionDatasource] is a datasource designed to work with a collection of entity instances. The collection is loaded with the invocation of the `refresh()` method, instance keys are accessible through the `getItemIds()` method. The `setItem()` method sets the "current" instance of the collection and `getItem()` returns it (for example, the one that corresponds to the currently selected table row).
+
The way of loading collections is determined by implementation. The most typical one is loading from Middleware via <<dataManager,DataManager>>; in this case, `setQuery()`, `setQueryFilter()` are used to form a JPQL query.
+
`CollectionDatasourceImpl` class is the standard implementation of such datasources, which is used on screens with entity lists.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/GroupDatasource.html[GroupDatasource] is a subtype of `CollectionDatasource`, designed to work with the <<gui_GroupTable,GroupTable>> component.
+
Standard implementation is the `GroupDatasourceImpl` class.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/HierarchicalDatasource.html[HierarchicalDatasource] is a subtype of `CollectionDatasource`, designed to work with the <<gui_Tree,Tree>> and <<gui_TreeTable,TreeTable>> components.
+
Standard implementation is the `HierarchicalDatasourceImpl` class.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/NestedDatasource.html[NestedDatasource] is a datasource designed to work with instances that are loaded in an attribute of another entity. In this case, a datasource that contains a parent entity is accessible via `getMaster()`, and <<metaProperty,meta property>> that corresponds to the parent attribute containing instances of this datasource is accessible via `getProperty()`.
+
For example an `Order` instance which contains a reference to the `Customer` instance is set in the `dsOrder` datasource. Then, to link the `Customer` instance with visual components, it is enough to create `NestedDatasource` with `dsOrder` as parent and meta property to point to the `Order.customer` attribute.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/PropertyDatasource.html[PropertyDatasource] is a subtype of `NestedDatasource`, designed to work with one instance or collection of related entities that are not embedded.
+
Standard implementations: for working with one instance – `PropertyDatasourceImpl`, with a collection – `CollectionPropertyDatasourceImpl`, `GroupPropertyDatasourceImpl`, `HierarchicalPropertyDatasourceImpl`. The latter also implements the `CollectionDatasource` interface, however some of its irrelevant methods like `setQuery()` throw `UnsupportedOperationException`.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/EmbeddedDatasource.html[EmbeddedDatasource] is a subtype of `NestedDatasource`, which contains an instance of an embedded entity.
+
Standard implementation is the `EmbeddedDatasourceImpl` class.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/RuntimePropsDatasource.html[RuntimePropsDatasource] is a specific datasource, designed to work with <<dynamic_attributes,dynamic attributes>> of entities.

Typically, datasources are declared in the `dsContext` section of a <<screen_xml,screen descriptor>>.

[[datasource_auto_refresh]]
Automatic CollectionDatasource refresh::
+
--
When the screen opens, its visual components connected to collection datasources cause the datasources to load data. As a result, <<gui_Table,tables>> show data right after opening the screen, without any explicit user action. If you want to prevent automatic loading of collection datasources, set the `DISABLE_AUTO_REFRESH` screen parameter to `true` in the screen's `init()` method or pass it from the calling code. This parameter is defined in the `WindowParams` enumeration, so it can be set as shown below:

[source, java]
----
@Override
public void init(Map<String, Object> params) {
    WindowParams.DISABLE_AUTO_REFRESH.set(params, true);
}
----

In this case, the screen collection datasources will be loaded only when their `refresh()` method will be called. It can be done by the application code or when the user clicks *Search* in the <<gui_Filter,Filter>> component.
--

[[datasource_creation]]
===== Creating Datasources

Datasource objects can be created both declaratively, using an XML screen descriptor, and programmatically in a controller. Typically, standard implementation of datasources is used, however, you can create your own class that is inherited from a standard one, if necessary.

[[datasource_decl_creation]]
====== Declarative Creation

Typically, datasources are declared in the `dsContext` element of a screen descriptor. Depending on the relative position of declaration elements, datasources of two varieties are created:

* if an element is located directly in `dsContext`, a normal `Datasource` or `CollectionDatasource`, which contains an independently loaded entity or collection, is created;

* if an element is located inside an element of another datasource, `NestedDatasource` is created and the external datasource becomes its parent.

Below is an example of declaring a datasource:

[source, xml]
----
include::{sourcesdir}/gui/datasources_2.xml[]
---- 

In the example above, `carDs` contains one entity instance, `Car`, and nested `allocationsDs` and `repairsDs` contain collections of related entities from the `Car.driverAllocations` and `Car.repairs` attributes, respectively. The `Car` instance together with related entities is set into the datasource from the outside. If this screen is an <<screen_edit,edit screen>>, it happens automatically when opening the screen. The `colorsDs` datasource contains a collection of instances of the `Color` entity, which is loaded by the datasource itself using the specified JPQL <<datasource_query,query>> with the _local <<views,view>>.

Below is the XML scheme. 

`dsContext` – root element.

`dsContext` elements:

* `datasource` – defines a datasource that contains a single entity instance.
+
Attributes:

** `id` – datasource identifier, must be unique for this `DsContext`.

** `class` – Java class of an entity that will be contained in this datasource.

** `view` – name of entity <<views,view>>. If the datasource itself loads instances, then this view will be used during loading. Otherwise, this view makes signals to external mechanisms on how to load an entity for this datasource.

** `allowCommit` – if set to `false`, the `isModified()` method of this datasource always returns `false` and the `commit()` method does nothing. Thus, changes in entities that are contained in the datasource are ignored. By default, it is set to `true`, i.e., changes are tracked and can be saved.

** `datasourceClass` is a <<datasource_custom_class, custom implementation class>>, if necessary.

* `collectionDatasource` – defines a datasource that contains a collection of instances.
+
--
`collectionDatasource` attributes:

** `refreshMode` – a datasource update mode, default is `ALWAYS`. In the `NEVER` mode, when `refresh()` method is invoked, the datasource does not load data and only changes its state to `Datasource.State.VALID`, notifies listeners and sorts available instances. The `NEVER` mode is useful if you need to programmatically fill `CollectionDatasource` with preloaded or created entities. For example:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_3.java[]
---- 

** `softDeletion` – the false value disables the <<soft_deletion,soft deletion>> mode when loading entities, i.e., deleted instances will also be loaded. Default value is `true`.

`collectionDatasource` elements:

** `query` – query to load entities
--

* `groupDatasource` – completely similar to `collectionDatasource`, but creates datasource implementation that is suitable to use in conjunction with the <<gui_GroupTable,GroupTable>> component.

* `hierarchicalDatasource` – similar to `collectionDatasource`, and creates datasource implementation that is suitable to use in conjunction with the <<gui_Tree,Tree>> and <<gui_TreeTable,TreeTable>> components.
+
`hierarchyProperty` is a specific attribute. It specifies an attribute name, upon which a hierarchy is built.

A datasource implementation class is selected implicitly based on the name of the XML element and, as mentioned above, the mutual arrangement of elements. However, if you need to apply a custom datasource, you can explicitly specify its class in the `datasourceClass` attribute.

[[datasource_prog_creation]]
====== Programmatic Creation

If you need to create a datasource in the Java code, it is recommended to use a special class, `DsBuilder`.

The `DsBuilder` instance is parameterized by an invocation chain of its methods in the fluent interface style. If the `master` and `property` parameters are set, then `NestedDatasource` will be created, otherwise – `Datasource` or `CollectionDatasource`.

Example: 

[source, java]
----
include::{sourcesdir}/gui/datasources_4.java[]
---- 

[[datasource_custom_class]]
====== Custom Implementation Classes

If you need to implement a custom mechanism of loading entities, create a custom datasource class inherited from `CustomCollectionDatasource`, `CustomGroupDatasource`, or `CustomHierarchicalDatasource`, and implement the `getEntities()` method.

For example:

[source, java]
----
include::{sourcesdir}/gui/datasources_5.java[]
---- 

To create a custom datasource instance declaratively, specify the custom class name in the `datasourceClass` attribute of the datasource XML element. In case of programmatic creation via `DsBuilder`, specify the class by invoking `setDsClass()` or as a parameter of one of the `build*()` methods.

[[datasource_query]]
===== CollectionDatasourceImpl Queries

The `CollectionDatasourceImpl` class and its subclasses, `GroupDatasourceImpl` and `HierarchicalDatasourceImpl`, are standard implementations of datasources that work with collections of entity instances. These datasources load data via `DataManager` by sending a JPQL queries to the middleware. The format of these queries is described below.

[[datasource_query_results]]
====== Returned values

A query should return entities of the type which is specified at the moment of creating a datasource. In case of declarative creation, the entity type is specified in the `class` attribute of an XML element, if `DsBuilder` is used – in the `setJavaClass()` or `setMetaClass()` method.

For example, a query of the datasource of the `Customer` entity may look as follows:

[source, sql]
----
select c from sales$Customer c
----

or

[source, sql]
----
select o.customer from sales$Order o
----

A query cannot return single attributes or aggregates, for example:

[source, sql]
----
select c.id, c.name from sales$Customer c /* invalid – returns single fields, not the whole Customer object */
----

If you need to execute a query which returns scalar values or aggregates and to display the results in visual components using standard data binding, use <<value_datasources,Value Datasources>>.

[[datasource_query_params]]
====== Query Parameters

A JPQL query in a datasource may contain parameters of several types. A parameter type is determined by a prefix of a parameter name. A prefix is a part of the name before the $ character. The interpretation of the name after $ is described below.

[[datasource_query_params_ds]]
* The `ds` prefix
+
The parameter value is data from another datasource that is registered in the same `DsContext`. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_6.xml[]
---- 
+
In the example above, a query parameter of the `ordersDs` datasource will be a current entity instance located in the `customersDs` datasource.
+
If parameters with the `ds` prefix are used, dependencies between datasources are created automatically. They lead to updating the datasource if its parameter are changed. In the example above, if the selected Customer is changed, the list of its Orders is changed automatically.
+
Please note that in the example of the parameterized query, the left part of the comparison operator is the value of the `o.customer.id` identifier, and the right part – the `Customer` instance that is contained in the `customersDs` datasource. This comparison is valid since when running a query at *Middleware*, the implementation of the <<query,Query>> interface, by assigning values to query parameters, automatically adds entity ID instead of a passed entity instance.
+
A path through the entity graph to an attribute (from which the value should be used) can be specified in the parameter name after the prefix and name of a datasource, for example:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_7.xml[]
---- 
+
or 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_8.xml[]
---- 

[[datasource_query_params_custom]]
* The `custom` prefix.
+
A parameter value will be taken from the `Map<String, Object>` object that is passed into the `refresh()` method of a datasource. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_9.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/datasources_10.java[]
---- 
+
Casting an instance to its identifier, if necessary, is performed similarly to parameters with the `ds` prefix. The path through the entity graph in the parameter name is not supported in this case.

[[datasource_query_params_param]]
* The `param` prefix.
+
A parameter value is taken from the `Map<String, Object>` object that is passed into the `init()` method of a <<screen_controller,controller>>. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_15.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/datasources_18.java[]
----
+
Casting an instance to its identifier, if necessary, is performed similarly to parameters with the `ds` prefix. The path through the entity graph in the parameter name is supported.

[[datasource_query_params_component]]
* The `component` prefix.
+
A parameter value will be a current value of a visual component, which path is specified in the parameter name. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_11.xml[]
---- 
+
The path to a component should include all nested <<frame,frames>>.
+
Casting an instance to its identifier, if necessary, is similar to `ds` parameters. The path through the entity graph in the parameter name is supported as the continuation of the path to a component in this case.
+
[TIP]
====
The datasource will not be refreshed automatically if the component value is changed.
====

[[datasource_query_params_session]]
* The `session` prefix.
+
--
A parameter value will be a value of the <<userSession,user session>> attribute specified in the parameter name.

The value is extracted by the `UserSession.getAttribute()` method, so predefined names of session attributes are also supported. 

** `userId` – ID of the currently registered or substituted user;

** `userLogin` – login of the currently registered or substituted user in lowercase.

Example: 

[source, xml]
----
include::{sourcesdir}/gui/datasources_12.xml[]
---- 

Casting an instance to its identifier, if necessary, is similar to `ds` parameters. In this case, the path through the entity graph in the parameter name is not supported.
--

[[datasource_query_filter]]
====== Query Filter

A datasource query can be modified during the work of the application, depending on conditions entered by the user. This allows you to efficiently filter data at the level of selection from DB.

The easiest way to provide such ability is to connect a special visual component, <<gui_Filter,Filter>>, to a datasource.

If by any reason the use of a universal filter is unwanted, a special XML markup can be embedded into a query text. This will allow to create a resulting query based on values entered by the user into any visual components of the screen.

In this filter the following elements can be used:

* `filter` – a root element of the filter. It can directly contain only one condition.

** `and`, `or` – logical conditions, may contain any number of other conditions and statements. 

** `c` – JPQL statement, which is added into the `where` section. It contains only the text and an optional `join` attribute, which value will be added into a corresponding place of the query. 

Conditions and statements are added into the resulting query only if parameters inside contain values, i.e., they are not `null`.

[WARNING]
====
Use only <<datasource_query_params_custom,custom>>, <<datasource_query_params_param,param>> and <<datasource_query_params_component,component>> parameters in query filters. <<datasource_query_params_ds,ds>> and <<datasource_query_params_session,session>> parameters will not work as expected.
====

Example:

[source, xml]
----
include::{sourcesdir}/gui/datasources_13.xml[]
---- 

In this case, if `state` and `initiator` parameters are passed into the `refresh()` method of a datasource, and a visual component, `barCodeFilterField`, has some value specified, then the resulting query will be as follows:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

If, for example, the `barCodeFilterField` component is empty and only one parameter, initiator, was passed into the `refresh()` method, the query will be as follows:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

[[datasource_query_case_insensitive]]
====== Case-Insensitive Search for a Substring

It is possible to use a special feature of JPQL queries execution in datasources, described for the <<query,Query>> interface of the *Middleware* level: for easy creation of case-insensitive search condition of any substring, `(?i)` prefix can be used. However, due to the fact that the query value is usually passed implicitly, the following differences take place:

* The `(?i)` prefix should be specified before a parameter name and not inside the value.

* The parameter value will be automatically converted to lowercase.

* If the parameter value does not have `%` characters, they will be added to the beginning and the end.

Below is an example of how to process the following query:

[source, sql]
----
select c from sales$Customer c where c.name like :(?i)component$customerNameField
----

In this case, the parameter value taken from the `customerNameField` component will be converted to lowercase and will be framed with `%` characters, and then an SQL query with a `lower(C.NAME) like ?` condition will be executed in the database.

Please note that with this search, an index created in the DB by the `NAME` field, will not be used. 

[[value_datasources]]
===== Value Datasources

Value datasources enable execution of queries that return scalar values and aggregates. For example, you can load some aggregated statistics for customers:

[source, sql]
----
select o.customer, sum(o.amount) from demo$Order o group by o.customer
----

Value datasources work with entities of a special type named `KeyValueEntity`. This entity can contain an arbitrary number of attributes which are defined at runtime. So in the example above, the `KeyValueEntity` instances will contain two attributes: the first of type `Customer` and the second of type `BigDecimal`.

Value datasource implementations extend other widely used collection datasource classes and implement a specific interface: `ValueDatasource`. Below is a diagram showing the value datasource implementations and their base classes:

image::ValueDatasources.png[align="center"]

The `ValueDatasource` interface declares the following methods:

* `addProperty()` - as the datasource can return entities with any number of attributes, you have to specify what attributes are expected by using this method. It accepts a name of the attribute and its type in the form of <<datatype,Datatype>> or a Java class. In the latter case, the class should be either an entity class or a class supported by one the datatypes.

* `setIdName()` is an optional method which allows you to define one of the attributes as an identifier attribute of the entity. It means that `KeyValueEntity` instances contained in this datasource will have identifiers obtained from the given attribute. Otherwise, `KeyValueEntity` instances get randomly generated UUIDs.

* `getMetaClass()` returns a dynamic implementation of the `MetaClass` interface that represents the current schema of `KeyValueEntity` instances. It is defined by previous calls to `addProperty()`.

Value datasources can be used declaratively in a screen XML descriptor. There are three XML elements corresponding to the implementation classes:

* `valueCollectionDatasource`
* `valueGroupDatasource`
* `valueHierarchicalDatasource`

XML definition of a value datasource must contain the `properties` element that defines the attributes of `KeyValueEntity` instances that will be contained in the datasource (see the `addProperty()` method description above). The order of `property` elements should conform to the order of result set columns returned by the query. For example, in the following definition the `customer` attribute will get its value from `o.customer` column and the `sum` attribute from `sum(o.amount)` column:

[source, xml]
----
include::{sourcesdir}/gui/value_datasources_1.xml[]
----

Value datasources are designed only for reading data, because `KeyValueEntity` is not persistent and cannot be saved by standard persistence mechanisms.

You can create value datasources either manually or in Studio in the *Datasources* tab of the *Screen designer* page.

image::ValueDatasources_Studio.png[align="center"]

The *Properties* editor allows you to create the datasource attributes of a certain datatype and/or a Java class.

image::ValueDatasources_Studio_properties.png[align="center"]

[[datasource_listeners]]
===== Datasource Listeners

<<datasources,Datasource>> listeners receive notifications of changes in the state of datasources and entities contained in them.

There are four types of listeners. Three of them: `ItemPropertyChangeListener`, `ItemChangeListener` and `StateChangeListener` are defined in the `Datasource` interface and can be used in any datasource. `CollectionChangeListener` is defined in `CollectionDatasource` and can be used only in datasources working with collections of entities.

Example of using datasource listeners:

[source, java]
----
include::{sourcesdir}/gui/datasources_14.java[]
----

The listener interfaces are described below.

* `ItemPropertyChangeListener` is added by the `Datasource.addItemPropertyChangeListener()` method. The listener is invoked when an attribute of an entity contained in the datasource is changed. The modified entity instance itself, the name of changed attribute, old and new values can be obtained from the event object passed to the listener.
+
The `ItemPropertyChangeListener` can be used to react to changes made in an entity instance by UI components, i.e. when a user edits input fields.

* `ItemChangeListener` is added by the `Datasource.addItemChangeListener()` method. The listener is invoked when a selected entity instance returned by the `Datasource.getItem()` method is changed.
+
For `Datasource`, it happens when another instance (or `null`) is set to the datasource with `setItem()` method.
+
For `CollectionDatasource`, this listener is invoked when a selected element is changed in a linked visual component. For example, it may be a selected table row, tree element or item in a drop-down list.

* `StateChangeListener` is added by the `Datasource.addStateChangeListener()` method. The listener is invoked when a state of the datasource is changed. The datasource can be in one of three states corresponding to the `Datasource.State` enumeration:
+
--
** `++NOT_INITIALIZED++` – datasource has just been created.

** `INVALID` – the whole <<dsContext,DsContext>>, which this datasource is related to, is created.

** `VALID` – datasource is ready: `Datasource` contains an entity instance or null, `CollectionDatasource` – collection of instances or an empty collection.

Receiving a notification about changes in datasource state may be important for complex <<screen_edit,editors>>, which consist of several <<frame,frames>> where it is difficult to trace the moment of setting an edited entity into the datasource. In this case, `StateChangeListener` can be used for the delayed initialization of certain screen elements:

[source, java]
----
include::{sourcesdir}/gui/datasources_17.java[]
---- 
--

* `CollectionChangeListener` is added by the `CollectionDatasource.addCollectionChangeListener()` method. The listener is invoked when a entity collection, which is stored in the datasource, is changed. The event object provides the `getOperation()` method returning value of type `CollectionDatasource.Operation`: `REFRESH`, `CLEAR`, `ADD`, `REMOVE`, `UPDATE`. It indicates the operation that caused the collection changes.

[[dsContext]]
===== DsContext

All datasources that are created declaratively are registered in the `DsContext` object which belongs to a screen. A reference to `DsContext` can be obtained using the `getDsContext()` method of a screen controller or via <<screen_controller_injection>>.

`DsContext` is designed for the following tasks:

. Organizes dependencies between datasources when navigation through a record set in one datasource (i.e. changing a "current" instance with the `setItem()` method) causes a related datasource to be updated. These dependencies allow you to organize master-detail relationships between visual components on screens.
+
Dependencies between datasources are organized using <<datasource_query,query parameters>> with the `ds$` prefix.

. Collects all changed entity instances and sends them to Middleware in a single invocation of `DataManager.commit()`, i.e. to save them into the database in a single transaction.
+
--
As an example, let's assume that some screen allows a user to edit an instance of the `Order` entity and a collection of `OrderLine` instances belonging to it. The `Order` instance is located in `Datasource`; the `OrderLine` collection – in nested `CollectionDatasource`, which is created using the `Order.lines` attribute.

If a user changes some attribute of `Order` and creates a new instance, `OrderLine`, then, when a screen is committed to <<dataManager,DataManager>>, two instances – changed `Order` and new `OrderLine` – will be sent simultaneously. After that, they will together be merged into one <<entityManager,persistent context>> and saved into the database on the transaction commit. It allows you to not specify cascade parameters on the ORM level and avoid the problems mentioned in the <<oneToMany_annotation, @OneToMany>> annotation description.

As a result of committing the transaction, `DsContext` receives a set of saved instances from Middleware (in the case of optimistic locking they, at least, have an increased value of the `version` attribute), and sets these instances in datasources replacing old ones. It allows you to work with the latest instances immediately after committing without an extra datasource refresh that produces queries to Middleware and the database.
--

. Declares two listeners: `BeforeCommitListener` and `AfterCommitListener`. They receive notifications before and after committing modified instances. `BeforeCommitListener` enables to supplement a collection of entities sent to <<dataManager,DataManager>> to save arbitrary entities in the same transaction. A collection of saved instances that are returned from `DataManager` can be obtained after commit in the `AfterCommitListener` listener.
+
This mechanism is required if some entities, with which a screen works, are not under control of datasources, but are created and changed directly in the controller code. For example, a visual component, <<gui_FileUploadField,FileUploadField>>, after uploading a file, creates a new entity instance, `FileDescriptor`, which can be saved together with other screen entities by adding to `CommitContext` in `BeforeCommitListener`.
+
In the following example, a new instance of `Customer` will be sent to Middleware and saved to the database together with other modified screen entities when the screen is committed:
+
[source, java]
----
include::{sourcesdir}/gui/dscontext_1.java[]
---- 

[[dataSupplier]]
===== DataSupplier

`DataSupplier` – interface, through which the datasources refer to Middleware for loading and saving entities. The standard implementation simply delegates to <<dataManager,DataManager>>. A screen can define its implementation of the `DataSupplier` in `dataSupplier` attribute of the `window` element.

A reference to `DataSupplier` can be obtained either by injection into a screen controller or through the `DsContext` or `Datasource` instances. In both cases, an own implementation is returned if defined for the screen.

[[gui_Action]]
==== Actions. The Action Interface

++++
<div class="manual-live-demo-container">
    <a href="http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/components/Action.html" class="api-docs-btn" target="_blank">API DOCS</a>
</div>
++++

`Action` is an interface that abstracts an action (in other words, some function) from a visual component. It is particularly useful when the same action can be invoked from different visual components ((for example, from button and table context menu). In addition, this interface allows you to provide the action with additional properties, such as name, flags of accessibility and visibility, etc.

Below are the `Action` interface methods:

* `actionPerform()` is invoked by a visual component associated with this action. An instance of the caller is passed to the method.

* `getId()` returns an identifier of the action. The identifier is usually set by a constructor of a class that implements `Action` and does not change throughout the lifecycle of the created action object.

* Methods for getting and setting `caption`, `description`, `shortcut`, `icon`, `enabled`, `visible` properties. Typically, all these properties are used by related visual components to set their own corresponding properties.

* `addPropertyChangeListener()`, `removePropertyChangeListener()` methods used to add and remove listeners which handle changes to the abovementioned properties. A listener receives notification of `java.beans.PropertyChangeEvent` type, which contains the name of the changed property, its old and new values.

* `refreshState()` - a method that can be implemented in a particular action class to initialize the abovementioned properties in accordance to some external factors, such as user rights. It is usually invoked in constructors of implementing classes or from related visual components.

* `addOwner()`, `removeOwner()`, `getOwner()`, `getOwners()` – methods used to control relation between the action and visual components.

It is recommended to implement actions using the <<declarative_actions,declarative creation>> or by inheriting from the <<baseAction,BaseAction>> class. Furthermore, there is a set of <<standard_actions,standard actions>> applicable for tables and picker components. You can also derive action classes from standard actions to modify their behavior or to intercept events.

Visual components associated with an action can be of two types:

* Visual component with a single action implements the `Component.ActionOwner` interface. These are <<gui_Button,Button>> and <<gui_LinkButton,LinkButton>>.
+
Action is linked to the component by the invocation of the `ActionOwner.setAction()` component method. At this point, the component replaces its properties with corresponding properties of the action (see components overview for details).

* Visual component containing several actions implements the `Component.ActionsHolder` interface. These are `Window`, `Frame`, <<gui_Table,Table>> and its inheritors, <<gui_Tree,Tree>>, <<gui_PopupButton,PopupButton>>, <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>.
+
The `ActionsHolder.addAction()` method is used to add actions to the component. Implementation of this method in the component checks whether it already contains an action with the same identifier. If yes, then the existing action will be replaced with the new one. Therefore, it is possible, for example, to declare a standard action in a screen descriptor and then create a new one in the controller with overridden methods and add it to the component.

[[declarative_actions]]
===== Declarative Creation of Actions

You can specify a set of <<gui_Action,actions>> in an XML screen descriptor for any component that implements the `Component.ActionsHolder` interface, including the entire screen or frame. This is done in the `actions` element, which contains nested `action` elements.

The `action` element can have the following attributes:

* `id` − identifier, which should be unique within the `ActionsHolder` component.

* `caption` – action name.

* `description` – action description.

* `enable` – accessibility flag (`true` / `false`).

* `icon` – action icon.

* `invoke` - name of the controller method to be invoked. The method should be `public` `void`, and either not have arguments or have one argument of the `Component` type. If the method has a `Component` argument, then an instance of the visual component that launches this action will be passed to it when invoked.

* `shortcut` - keyboard shortcut for invocation.
+
--
Shortcut values can be hard-coded in the XML descriptor. Possible modifiers, `ALT`, `CTRL`, `SHIFT`, are separated by the "-" character. For example:

[source, xml]
----
<action id="create" shortcut="ALT-N"/>
----

To avoid the hard code, you can use the predefined shortcut aliases from the list below, for example:

[source, xml]
----
<action id="edit" shortcut="${TABLE_EDIT_SHORTCUT}"/>
----
** `TABLE_EDIT_SHORTCUT`

** `COMMIT_SHORTCUT`

** `CLOSE_SHORTCUT`

** `FILTER_APPLY_SHORTCUT`

** `FILTER_SELECT_SHORTCUT`

** `NEXT_TAB_SHORTCUT`

** `PREVIOUS_TAB_SHORTCUT`

** `PICKER_LOOKUP_SHORTCUT`

** `PICKER_OPEN_SHORTCUT`

** `PICKER_CLEAR_SHORTCUT`

Another option is to use the full qualified name of the `Config` interface and method which returns shortcut:

[source, xml]
----
<action id="remove" shortcut="${com.haulmont.cuba.client.ClientConfig#getTableRemoveShortcut}"/>
----
--

* `visible` – visibility flag (`true` / `false`).

The examples of declaration are provided below.

* Declaring actions at the screen level: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_1.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/actions_2.java[]
----
+
In the example above, an action with `sayHelloAction` identifier and a name from <<message_packs,message pack>> is declared. This action is bound with a button, which caption will be set to the action name. The action will invoke the `sayHello()` controller method when clicking on the button, or when pressing the ALT-T shortcut if at that moment the screen has input focus.

* Declaring actions for <<gui_PopupButton,PopupButton>>: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_3.xml[]
---- 

* Declaring actions for <<gui_Table,Table>>: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_4.xml[]
----
+
In this example `copy` and `changePassw` actions are declared in addition to `create` and `edit` standard actions of the table. These actions invoke corresponding methods of the controller. In addition, the `trackSelection="true"` attribute is specified for them, which means that the action and corresponding button become disabled if no row is selected in the table. It is useful if the action is intended to be executed over a currently selected table row.
+
An optional `openType` attribute can be specified for create and edit actions to define edit screen opening mode, as described for the `setOpenType()` method of the <<createAction,CreateAction>> class.

* Declaring <<gui_PickerField,PickerField>> actions: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_5.xml[]
----
+
In the example above, the standard `lookup` action and an additional `show` action invoking the `showColour()` method of the controller, are declared for the `PickerField` component. Since `PickerField` buttons that display actions use icons instead of captions, the caption attribute is explicitly set to an empty string, otherwise action name and button caption would be set to the action identifier. The `description` attribute allows you to display a tooltip when hovering over the action button.

You can obtain references to any declared actions in the screen controller either directly by <<screen_controller_injection,injection>>, or from components that implement the `Component.ActionsHolder` interface. This can be useful to set action properties programmatically. For example: 

[source, java]
----
include::{sourcesdir}/gui/actions_6.java[]
---- 

[[standard_actions]]
===== Standard Actions

Standard <<gui_Action,actions>> are classes that implement the `Action` interface and are intended to solve common tasks, such as invocation of an edit screen for an entity selected in a table. Standard actions have strictly defined identifiers; therefore, for the declaration of a standard action in XML, it is enough to specify its identifier.

There are two types of standard actions:

* <<list_actions,Actions over collections>> of entities that are displayed in tables or trees.

* <<picker_actions,Picker field actions>>.

[[list_actions]]
====== Standard Actions over Collection

For inheritors of `ListComponent` (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>> and <<gui_Tree,Tree>>) the set of standard actions is defined in `ListActionType` enumeration; their implementation classes are located in `com.haulmont.cuba.gui.components.actions` package. 

The example of using standard actions in a table: 

[source, xml]
----
include::{sourcesdir}/gui/listActions_1.xml[]
----

These actions are described in details below.

[[createAction]]
*CreateAction*

`CreateAction` – action with *create* identifier. It is intended to create new entity instance and open its edit screen. If the edit screen successfully commits a new instance to the database, `CreateAction` adds this new instance to the table data source and makes it selected.

The following specific methods are defined in the `CreateAction` class: 

* `setOpenType()` allows you to specify new entity edit screen open mode. `++THIS_TAB++` by default. 
+
Since it is quite often required to open edit screens in another mode (typically, `DIALOG`), you can specify an `openType` attribute with desired value in the `action` element when using declarative creation of the `create` action. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/createAction_1.xml[]
----

* `setWindowId()` allows you to specify the identifier of the entity edit screen. By default, `++{entity_name}.edit++` is used, for example `sales$Customer.edit`.

* `setWindowParams()` allows you to set edit screen parameters passed into its `init()` method. The parameters can be further used directly in the <<datasource_query_params_param,datasource query>> via the `param$` prefix or <<screen_controller_injection,injected>> into the screen controller using the `@WindowParam` annotation.

* `setWindowParamsSupplier()` is different from `setWindowParams()` in that it allows you to get parameter values right before the action is invoked. Supplied parameters are merged with ones set by the `setWindowParams()` method and can override them. For example:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_5.java[]
----

* `setInitialValues()` allows you to set initial values of attributes of the entity being created. It takes a `Map` object, where keys are attribute names, and values are attribute values. For example:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_2.java[]
----
+
An example of `setInitialValues()` usage is also provided in the section of <<init_values_in_CreateAction,development recipes>>.

* `setInitialValuesSupplier()` is different from `setInitialValues()` in that it allows you to get values right before the action is invoked. Supplied values are merged with ones set by the `setInitialValues()` method and can override them. For example:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_4.java[]
----

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_6.java[]
----

* `afterCommit()` is invoked by the action after the new entity has been successfully committed and the edit screen has been closed. This method does not have implementation and can be overridden in inheritors to handle this event.

* `setAfterCommitHandler()` allows you to provide a handler which will be called after the new entity has been successfully committed and the edit screen has been closed. This handler can be used instead of overriding `afterCommit()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_3.java[]
---- 

* `afterWindowClosed()` is the last method invoked by the action after closing the edit screen regardless of whether the new entity has been committed or not. This method does not have implementation and can be overridden in inheritors to handle this event.

* `setAfterWindowClosedHandler()` allows you to provide a handler which will be called after closing the edit screen regardless of whether the new entity has been committed or not. This handler can be used instead of overriding `afterWindowClosed()` to avoid creating the action subclass. 

[[editAction]]
*EditAction*

`EditAction` is an action with *edit* identifier, intended to open an edit screen for a selected entity instance. If the edit screen successfully commits the instance to the database, then `EditAction` updates this instance in the table datasource.

The following specific methods are defined in the `EditAction` class: 

* `setOpenType()` allows you to specify entity edit screen open mode. `++THIS_TAB++` by default. 
+
Since it is quite often required to open edit screens in another mode (typically `DIALOG`), you can specify `openType` attribute with desired value in the `action` element when creating the action declaratively. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/editAction_1.xml[]
---- 

* `setWindowId()` allows you to specify entity edit screen identifier. `++{entity_name}.edit++` is used by default, for example, `sales$Customer.edit`.

* `setWindowParams()` allows you to set edit screen parameters, passed to its `init()` method. The parameters can be further used directly in the <<datasource_query_params_param,datasource query>> via the `param$` prefix or <<screen_controller_injection,injected>> into the screen controller using the `@WindowParam` annotation.

* `setWindowParamsSupplier()` is different from `setWindowParams()` in that it allows you to get parameter values right before the action is invoked. Supplied parameters are merged with ones set by the `setWindowParams()` method and can override them. For example:
+
[source, java]
----
include::{sourcesdir}/gui/editAction_4.java[]
----

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/editAction_5.java[]
----

*  `afterCommit()` is invoked by the action after the entity has been successfully committed and the edit screen has been closed. This method does not have implementation and can be overridden in inheritors to handle this event. 

* `setAfterCommitHandler()` allows you to provide a handler which will be called after the new entity has been successfully committed and the edit screen has been closed. This handler can be used instead of overriding `afterCommit()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/editAction_2.java[]
---- 

* `afterWindowClosed()` is the last method invoked by the action after closing the edit screen regardless of whether the edited entity has been committed or not. This method does not have implementation and can be overridden in inheritors to handle this event.

* `setAfterWindowClosedHandler()` allows you to provide a handler which will be called after closing the edit screen regardless of whether the new entity has been committed or not. This handler can be used instead of overriding `afterWindowClosed()` to avoid creating the action subclass. 

* `getBulkEditorIntegration()` provides a possibility of bulk editing for the table records. The table should have the `multiselect` attribute enabled. The <<gui_BulkEditor,BulkEditor>> component will be opened, if multiple table lines are selected when the `EditAction` is called.
+
--
The returned `BulkEditorIntegration` instance can be further modified by the following methods:

* `setOpenType()`,

* `setExcludePropertiesRegex()`,

* `setFieldValidators()`,

* `setModelValidators()`,

* `setAfterEditCloseHandler()`.
--
+
[source, java]
----
include::{sourcesdir}/gui/editAction_3.java[]
----

[[removeAction]]
*RemoveAction*

`RemoveAction` - action with *remove* identifier, intended to remove a selected entity instance.

The following specific methods are defined in the `RemoveAction` class: 

* `setAutocommit()` allows you to control the moment of entity removal from the database. By default `commit()` method is invoked after triggering the action and removing the entity from the datasource. As result, the entity is removed from the database. You can set `autocommit` property into false using `setAutocommit()` method or corresponding parameter of the constructor. In this case you will need to explicitly invoke the datasource `commit()` method to confirm the removal after removing the entity from the datasource.
+
The value of `autocommit` does not affect datasources in the `Datasource.CommitMode.PARENT` mode, i.e. the datasources that provide <<composition_annotation,composite>> entities editing.

* `setConfirmationMessage()` allows you to set message text for the removal confirmation dialog.

* `setConfirmationTitle()` allows you to set removal confirmation dialog title.

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_2.java[]
----

*  `afterRemove()` is invoked by the action after the entity has been successfully removed. This method does not have implementation and can be overridden. 

* `setAfterRemoveHandler()` allows you to provide a handler which will be called after the new entity has been successfully removed. This handler can be used instead of overriding `afterRemove()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_1.java[]
----  

[[refreshAction]]
*RefreshAction*

`RefreshAction` - an action with *refresh* identifier. It is intended to update (reload) entities collection. When triggered, it invokes `refresh()` method of a <<datasources,datasource>> associated with the corresponding component.

The following specific methods are defined in the `RefreshAction` class:

* `setRefreshParams()` allows you to set parameters passed into the `CollectionDatasource.refresh()` method to be used in the <<datasource_query,query>>. By default, no parameters are passed.

* `setRefreshParamsSupplier()` is different from `setRefreshParams()` in that it allows you to get parameter values right before the action is invoked. Supplied parameters are merged with ones set by the `setRefreshParams()` method and can override them. For example:
+
[source, java]
----
include::{sourcesdir}/gui/refreshAction_1.java[]
----

[[addAction]]
*AddAction*

`AddAction` – action with *add* identifier, intended for selecting an existing entity instance and adding it to the collection. When triggered, opens entities <<screen_lookup,lookup screen>>.

The following specific methods are defined in the `AddAction` class:

* `setOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.
+
Since it is often required to open the lookup screens in a different mode (usually `DIALOG`), the `openType` attribute can be specified in the action element, when creating the `add` action declaratively. This eliminates the need to get a reference to the action in the controller and set this property programmatically. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/addaction_1.xml[]
----

* `setWindowId()` allows you to specify entity selection screen identifier. `++{entity_name}.lookup++` by default, for example, `sales$Customer.lookup`. If such screen does not exist, attempts to open `++{entity_name}.browse++` screen, for example, `sales$Customer.browse`.

* `setWindowParams()` allows you to set selection screen parameters, passed into its `init()` method. The parameters can be further used directly in the <<datasource_query_params_param,datasource query>> via the `param$` prefix or <<screen_controller_injection,injected>> into the screen controller using the `@WindowParam` annotation.

* `setWindowParamsSupplier()` is different from `setWindowParams()` in that it allows you to get parameter values right before the action is invoked. Supplied parameters are merged with ones set by the `setWindowParams()` method and can override them. For example:
+
[source, java]
----
include::{sourcesdir}/gui/addaction_2.java[]
----

* `setHandler()` allows you to set an object implementing `Window.Lookup.Handler` interface which will be passed to the selection screen. By default, `AddAction.DefaultHandler` object is used.

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/addaction_3.java[]
----

[[excludeAction]]
*ExcludeAction*

`ExcludeAction` - an action with *exclude* identifier. It allows a user to exclude entity instances from a collection without removing them from the database. The class of this action is an inheritor of `RemoveAction`, however, when triggered it invokes `excludeItem()` of `CollectionDatasource` instead of `removeItem()`. In addition, for an entity in a nested datasource, the `ExcludeAction` disconnects the link with the parent entity. Therefore this action can be used for editing one-to-many associations.

The following specific methods are defined in the `ExcludeAction` class in addition to `RemoveAction`:

* `setConfirm()` – flag to show the removal confirmation dialog. You can also set this property via the action constructor. By default it is set to `false`.

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/excludeAction.java[]
----

[[excelAction]]
*ExcelAction*

`ExcelAction` - an action with *excel* identifier, intended to export table data into XLS and download the resulting file. You can add this action only to <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>> and <<gui_TreeTable,TreeTable>> components.

When creating the action programmatically, you can set the `display` parameter with an `ExportDisplay` interface implementation for file download. Standard implementation is used by default.

The following specific methods are defined in the `ExcelAction` class:

* `setFileName()`  - sets the Excel file name without extension.

* `getFileName()` - returns the Excel file name without extension.

* `setBeforeActionPerformedHandler()` allows you to provide a handler which will be invoked by the action before its execution. The method should return `true` to proceed with the execution and `false` to abort. For example:
+
[source, java]
----
include::{sourcesdir}/gui/excelAction.java[]
----

[[picker_actions]]
====== Standard Actions of the Picker Field

For <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>> and <<gui_SearchPickerField,SearchPickerField>> components, a set of standard actions is defined in the `PickerField.ActionType` enumeration. Implementations are inner classes of the `PickerField` interface, which are described in details below. 

The example of standard actions usage in a picker component: 

[source, xml]
----
include::{sourcesdir}/gui/pickerActions_1.xml[]
---- 

[[lookupAction]]
*LookupAction*

`LookupAction` – action with *lookup* identifier, intended for selecting an entity instance and setting it as the component's value. When triggered, it opens an entities <<screen_lookup,lookup screen>>.

The following specific methods are defined in the `LookupAction` class:

* `setLookupScreenOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.

* `setLookupScreen()` allows you to specify entity selection screen identifier. `++{entity_name}.lookup++` by default, for example, `sales$Customer.lookup`. If such screen does not exist, attempts to open `++{entity_name}.browse++` screen, for example, `sales$Customer.browse`.

* `setLookupScreenParams()` allows you to set selection screen parameters, passed into its `init()` method.

* `afterSelect()` is invoked by the action after the selected instance is set as the component's value. This method does not have implementation and can be overridden.

* `afterCloseLookup()` is the last method invoked by the action after closing the lookup screen regardless of whether an instance has been selected or not. This method does not have implementation and can be overridden.

[[clearAction]]
*ClearAction*

`ClearAction` - an action with *clear* identifier, intended for clearing (i.e. for setting to `null`) the value of the component.

[[openAction]]
*OpenAction*

`OpenAction` - action with *open* identifier, intended for opening an edit screen for the entity instance which is the current value of the component.

The following specific methods are defined in the `OpenAction` class:

* `setEditScreenOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.

* `setEditScreen()` allows you to specify entity edit screen identifier. `++{entity_name}.edit++` screen is used by default, for example, `sales$Customer.edit`.

* `setEditScreenParams()` allows you to set edit screen parameters, passed to its `init()`method.

* `afterWindowClosed()` is invoked by the action after closing the edit screen. This method does not have implementation and can be overridden in inheritors to handle this event. 

[[baseAction]]
===== BaseAction

`BaseAction` is a base class for <<gui_Action,actions>> implementation. It is recommended to derive custom actions from it when <<declarative_actions,declarative actions creation>> functionality is insufficient.

When creating a custom action class, you should implement `actionPerform()` method and pass action identifier to the `BaseAction` constructor. You can override any property getters: `getCaption()`, `getDescription()`, `getIcon()`, `getShortcut()`, `isEnabled()`, `isVisible()`. Standard implementations of these methods return values set by setter methods, except the `getCaption()` method. If the action name is not explicitly set by `setCaption()` method, it retrieves message using action identifier as key from the the <<message_packs,localized message pack>> corresponding to the action class package. If there is no message with such key, then the key itself, i.e. the action identifier, is returned.

Alternatively, you can use the fluent interface for setting properties and providing a lambda expression for handling the action: see `withXYZ()` methods.

`BaseAction` can change its `enabled` and `visible` properties depending on user <<permissions,permissions>> and current context.

`BaseAction` is visible if the following conditions are met: 

* `setVisible(false)` method was not called;

* there is no `*hide*` UI permission for this action.

The action is enabled if the following conditions are met: 

* `setEnabled(false)` method was not called;

* there are no `*hide*` or read-only UI permissions for this action;

* `isPermitted()` method returns true;

* `isApplicable()` method returns true. 

Usage examples:

* <<gui_Button,Button>> action: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_1.java[]
----
+
In this example, the `helloBtn` button caption will be set to the string located in the message pack with the `hello` key. You can override the `getCaption()` action method to initialize button name in a different way.

* Action of a programmatically created <<gui_PickerField,PickerField>>: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_2.java[]
----
+
In this example an anonymous `BaseAction` derived class is used to set the action of the picker field button. The button caption is not displayed, as an icon with a description, which pops up when hovering mouse cursor, is used instead.

* <<gui_Table,Table>> action: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_3.java[]
----
+
In this example, the `HelloAction` class is declared, and its instance is added to the table's actions list. The action is enabled for users who have `*myapp.allow-greeting*` security permission and only when a single table row is selected. The latter is possible because BaseAction's `target` property is automatically assigned to the action when it is added to a `ListComponent` descendant (`Table` or `Tree`).

* If you need an action, which becomes enabled when one or more table rows are selected, use BaseAction's descendant - `ItemTrackingAction`, which adds default implementation of `isApplicable()` method: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_4.java[]
---- 

[[dialogs_and_notifications]]
==== Dialogs and Notifications

Dialogs and notifications can be used to display messages to users.

Dialogs have a title with a closing button and are always displayed in the center of the application main window. Notifications can be displayed both in the center and in the corner of the window, and can automatically disappear.

[[dialogs]]
===== Dialogs

General-purpose dialogs::
+
--
General-purpose dialogs are invoked by `showMessageDialog()` and `showOptionDialog()` methods of the `Frame` interface. This interface is implemented by <<screen_controller,screen controller>>, so these methods can be invoked directly in the controller code.

[[dialogs_showMessageDialog]]
* `showMessageDialog()` is intended to display a message. The method has the following parameters:

** `title` – dialog title.

** `message` - message. For HTML type (see below), you can use HTML tags for formatting the message. When using HTML, make sure you escape data loaded from the database to avoid code injection in web client. You can use `\n` characters for line breaks in non-HTML messages.

** `messageType` – message type. Possible types:

*** `CONFIRMATION`, `++CONFIRMATION_HTML++` – confirmation dialog. 

*** `WARNING`, `++WARNING_HTML++` – warning dialog.
+
The difference in message types is reflected in desktop user interface only.
+
Message type can be set with parameters:
+
**** `width` - the dialog width,
+
**** `modal` - if the dialog is modal,
+
**** `maximized` - if the dialog should be maximized across the screen,
+
**** `closeOnClickOutside` - if the dialog can be closed by clicking on area outside the dialog.
+
An example of showing a dialog:
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_1.java[]
----

[[dialogs_showOptionDialog]]
* `showOptionDialog()` is intended to display a message and buttons for user actions. In addition to parameters described for `showMessageDialog()`, the method takes an array or a list of actions. A button is created for each dialog action. After a button is clicked, the dialog closes invoking `actionPerform()` method of the corresponding action.
+
It is convenient to use anonymous classes derived from `DialogAction` for buttons with standard names and icons. Five types of actions defined by the `DialogAction.Type` enum are supported: `OK`, `CANCEL`, `YES`, `NO`, `CLOSE`. Names of corresponding buttons are extracted from the <<main_message_pack,main message pack>>.
+
Below is an example of a dialog invocation with `Yes` and `No` buttons and with a caption and messages taken from the message pack of the current screen: 
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_2.java[]
----
+
The `Status` parameter of `DialogAction` is used to assign a special visual style for a button representing the action. `Status.PRIMARY` highlights the corresponding button and makes it selected. The `Status` parameter can be omitted, in this case default highlighting is applied. If multiple actions with `Status.PRIMARY` are passed to the `showOptionDialog`, only the first action's button will get the `cuba-primary-action` style and focus.
--

[[dialogs_fileUploadDialog]]
File upload dialog::
+
--
The `FileUploadDialog` window provides the base functionality for loading files into the <<file_upload,temporary storage>>. It contains the drop zone for drag-and-dropping files from outside of the browser and the upload button.

image::gui_fileUploadDialog.png[align="center"]

The dialog is opened with the `openWindow()` method, in case of successful upload it is closed with `COMMIT_ACTION_ID`. You can track the close action of the dialog with `CloseListener` or `CloseWithCommitListener` and use the `getFileId()` and `getFileName()` methods to get the UUID and the name of uploaded file. Then you can create a `FileDescriptor` for referencing the file from the data model objects or implement any other logic.

[source, java]
----
include::{sourcesdir}/gui/dialogs_3.java[]
----
--

[[notifications]]
===== Notifications

Notifications can be invoked using `showNotification()` method of the `Frame` interface. This interface is implemented by <<screen_controller,screen controller>>, so this method can be invoked directly from the controller code.

`showNotification()` method takes the following parameters:

* `caption` - notification text. In case of HTML-type (see below), you can format message text using HTML-tags. When using HTML, don't forget to escape data to prevent code injection in the web-client. You can use `\n` characters for line breaks in non-HTML messages.

* `description` – an optional description displayed under the caption. You can also use `\n` character or HTML-formatting.

* `type` – notification type. Possible values:

** `TRAY`, `++TRAY_HTML++` - a notification is displayed in the bottom right corner of the application and disappears automatically.

** `HUMANIZED`, `++HUMANIZED_HTML++` – a standard notification displayed in the center of the screen, disappears automatically.

** `WARNING`, `++WARNING_HTML++` – a warning. Disappears when clicked.

** `ERROR`, `++ERROR_HTML++` – a notification about an error. Disappears when clicked.

Examples of invoking a notification: 

[source, java]
----
include::{sourcesdir}/gui/notifications_1.java[]
---- 

[[background_tasks]]
==== Background Tasks

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=normal-progressbar" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Background tasks mechanism is designed for performing tasks at the client tier asynchronously without blocking the user interface.

In order to use background tasks, do the following:

. Define a task as an inheritor of the `BackgroundTask` abstract class. Pass a link to a screen controller which will be associated with the task and the task timeout to the task constructor.
+
Closing the screen will interrupt the tasks associated with it. Additionally, the task will be interrupted automatically after the specified timeout.
+
Actual actions performed by the task are implemented in the <<background_tasks_run,run()>> method.

. Create an object of `BackgroundTaskHandler` class controlling the task by passing the task instance to the `handle()` method of the `BackgroundWorker` bean. A link to `BackgroundWorker` can be obtained by an injection in a <<screen_controller,screen controller>>, or through the `AppBeans` class.

. Run the task by invoking the `execute()` method of `BackgroundTaskHandler`.

Example:

[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Detailed information about methods is provided in JavaDocs for `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler` classes. 

Please note the following:

* `BackgroundTask<T, V>` is a parameterized class:

** `T` − the type of objects displaying task progress. Objects of this type are passed to the task's `progress()` method during an invocation of `TaskLifeCycle.publish()` in the working thread.

** `V` − task result type passed to the `done()` method. It can also be obtained by invoking `BackgroundTaskHandler.getResult()` method, which will wait for a task to complete.

* `canceled()` method is invoked only during a controlled cancellation of a task, i.e. when `cancel()` is invoked in the `TaskHandler`.

* `handleTimeoutException()` is invoked when the task timeout expires. If the window where the task is running closes, the task is stopped without a notification.

[[background_tasks_run]]
* `run()` method of a task should support external interruptions. To ensure this, we recommend checking the `TaskLifeCycle.isInterrupted()` flag periodically during long processes and stopping execution when needed. Additionally, you should not silently discard `InterruptedException` (or any other exception) - instead you should either exit the method correctly or not handle the exception at all.
+
** `isCancelled()` method returns `true` if a task was interrupted by calling the `cancel()` method.
+
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_2.java[]
----

* `BackgroundTask` objects are stateless. If you did not create fields for temporary data when implementing task class, you can start several parallel processes using a single task instance.

* `BackgroundHandler` object (its `execute()` method) can only be started once. If you need to restart a task frequently, use `BackgroundTaskWrapper` class.

* Use `BackgroundWorkWindow` or `BackgroundWorkProgressWindow` classes with a set of static methods to show a modal window with progress indicator and *Cancel* button. You can define progress indication type and allow or prohibit cancellation of the background task for the window.

* If you need to use certain values of visual components in the task thread, you should implement their acquisition in `getParams()` method, which runs in the UI thread once, when a task starts. In the run() method, these parameters will be accessible via the `getParams()` method of the `TaskLifeCycle` object.

* If any exception occurs, the framework invokes `BackgroundTask.handleException()` method in the UI thread, which can be used to display the error.

* Background tasks are affected by <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> and <<cuba.backgroundWorker.timeoutCheckInterval,cuba.backgroundWorker.timeoutCheckInterval>> application properties.

[WARNING]
====
In Web Client, background tasks are implemented using HTTP push provided by the Vaadin framework. See https://vaadin.com/wiki/-/wiki/Main/Working+around+push+issues for information on how to set up your web servers for this technology.
====

[TIP]
====
If you don't use background tasks, but want to update UI state from a non-UI thread, use methods of the `UIAccessor` interface. You should get a reference to `UIAccessor` using the `BackgroundWorker.getUIAccessor()` method in the UI thread, and after that you can invoke its `access()` and `accessSynchronously()` methods from a background thread to safely read or modify the state of UI components.
====

[[gui_themes]]
==== Themes

Themes are used to manage the visual presentation of the application.

[[web_theme]]
===== Themes in Web Applications

A theme consists of link:http://sass-lang.com[SCSS] files and other resources like images.

[[web_theme_usage]]
====== Using Existing Themes

The platform includes two ready to use themes: Halo and Havana. By default, the application will use the one specified in the <<cuba.web.theme,cuba.web.theme>> application property. The user may select the other theme in the standard *Help* > *Settings* screen. If you want to disable the option of selecting themes, register the `settings` screen in the <<screens.xml,web-screens.xml>> file of your project and set the `changeThemeEnabled = false` parameter for it:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_1.xml[]
---- 

[[web_theme_extension]]
====== Extending an Existing Theme

A platform theme can be modified in the project. In the modified theme, you can:

* Change branding images.

* Add icons to use them in visual components. See the <<gui_icons,>> section below.

* Create new styles for visual components and use them in the <<gui_attr_stylename,stylename>> attribute. This requires some expertise in CSS.

* Modify existing styles of the visual components.

* Modify common parameters, such as background color, margins, spacing, etc.

Themes are defined in link:http://sass-lang.com[SCSS] files. To modify (extend) a theme in the project, you should create a specific file structure in the *web* module. A convenient way to do this is to use *CUBA Studio*: open the *Project properties* section and click *Create theme extension*. Select the theme you want to extend in the popup window. As a result, the following directory structure will be created in the `modules/web` directory (for Halo theme extension):

[source, plain]
----
include::{sourcesdir}/gui/themes/themes_42.scss[]
----

Apart from that, the <<build.gradle,build.gradle>> script will be complemented with the `buildScssThemes` task, which is executed automatically each time the *web* module is built. The optional <<build.gradle_deployThemes,deployThemes>> task can be used to quickly apply changes in themes to the running application.

[TIP]
====
If your project contains an <<app_components,application component>> with extended theme, and you want this extension to be used for the whole project, then you should create theme extension for the project too. For more details on how to inherit the component's theme, see the <<web_theme_inheritance>> section.
====

[[web_theme_extension_branding]]
Changing branding::
+
--
You can configure some branding properties, such as icons, login and main application window captions, and the website icon (`favicon.ico`).

To use custom images, replace default ones in the `modules/web/themes/halo/branding` directory.

To set window captions and the login window welcome text, edit *Project properties* in CUBA Studio and click *Branding* at the bottom of the page. Set window captions and the login window welcome text using the appropriate links.

These parameters are saved in the <<main_message_pack,main message pack>> of the *web* module (i.e the `modules/web/<root_package>/web/messages.properties` file and its variants for different locales). Message packs allow you to use different image files for different user locales. The sample `messages.properties` file:

[source, plain]
----
include::{sourcesdir}/gui/themes/themes_43.scss[]
----

The path to `favicon.ico` is not specified since it must be located in the root directory of the theme.
--

[[web_theme_extension_fonts]]
Adding fonts::
+
--
You can add custom fonts to your web theme. To add a font family, import it in the first line of the `styles.scss` file, for example:

[source, properties]
----
@import url(http://fonts.googleapis.com/css?family=Roboto);
----
--

[[web_theme_extension_styles]]
Creating new styles::
+
--
Consider the example of setting the yellow background color to the field displaying the customer's name.

In an XML descriptor, the <<gui_FieldGroup,FieldGroup>> component is defined:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_20.xml[]
----

The `field` elements of `FieldGroup` do not have the <<gui_attr_stylename,stylename>> attribute, therefore we have to set the field's style name in the controller:

[source, java]
----
include::{sourcesdir}/gui/themes/themes_21.java[]
----

In the `halo-ext.scss` file, add the new style definition to the `halo-ext` mixin:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_22.scss[]
----

After rebuilding the project, the fields will look as follows:

image::gui_themes_fieldgroup_1.png[align="center"]
--

Modifying existing styles of the visual components::
+
--
To modify style parameters of existing components, add the corresponding CSS code to the `halo-ext` mixin of the `halo-ext.scss` file. Use developer tools of your web browser to find out CSS classes assigned to the elements of visual components. For example, to display the application menu items in bold, the contents of the `halo-ext.scss` file should be as follows:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_6.scss[]
----
--

[[web_theme_extension_common]]
Modifying common parameters::
+
--
Themes contain a number of SCSS variables that control application background colour, component size, margins and other parameters.

Below is the example of a Halo theme extension, since it is based on link:https://vaadin.com/valo[Valo] theme from *Vaadin*, and provides the widest range of options for customization.

The `themes/halo/halo-ext-defaults.scss` file is intended for overriding theme variables. Most of the Halo variables correspond to those described in the link:https://vaadin.com/api/valo[Valo documentation]. Below are the most common variables:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_4.scss[]
---- 

The sample `halo-ext-defaults.scss` for a theme with a dark background and slightly minimized margins is provided below:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_5.scss[]
----
--

[[web_theme_migration]]
Migration from Havana to feature-rich Halo theme::
+
--
Halo theme is more extensible and supports some new visual components, such as <<gui_DataGrid,DataGrid>> or <<gui_SideMenu,SideMenu>>. If you want to use these components and keep your components library up-to-date, it is recommended to use the Halo theme. At the same time, if you want to keep the old Havana enterprise look, you can use the following variables in `halo-ext-defaults.scss`:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_23.scss[]
----
--

Changing the application header::
+
--
Halo theme supports the <<cuba.web.useInverseHeader,cuba.web.useInverseHeader>> property, which controls the colour of the application header. By default, this property is set to `true`, which sets a dark (inverse) header.You can make a light header without any changes to the theme, simply by setting this property to `false`.
--

[[web_theme_creation]]
====== Creating a Custom Theme

You can create one or several application themes in the project and give the users an opportunity to select the most appropriate one. Creating new themes also allows you to override the variables in the `++*-theme.properties files++`, which define a few server-side parameters:

--
* Default dialog window size.

* Default input field width.

* Dimensions of some components (<<gui_Filter,Filter>>, <<gui_FileMultiUploadField,FileMultiUploadField>>).

* Correspondence between icon names and constants of the `com.vaadin.server.FontAwesome` enumeration for using *Font Awesome* in standard actions and screens of the platform, if <<cuba.web.useFontIcons,cuba.web.useFontIcons>> is enabled.
--

Creating a new theme::
+
--
Below is the example of creating a Halo-based Facebook theme, which resembles the interface of a popular social network.

. In CUBA Studio, open *Project Properties* section and click *Create custom theme*. Set the theme name - `facebook`, select `halo` as the base theme and click *Create*. The new theme directory will be created in the project:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_25.scss[]
----
+
The `styles.scss` file contains the list of your themes:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_7.scss[]
----
+
The `facebook.scss` file:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_8.scss[]
----
+
The `app-component.scss` file inside `com.haulmont.cuba`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_24.scss[]
----

. Modify the theme variables in `facebook-defaults.scss`. You can do it in Studio by clicking *Manage theme > Edit Facebook theme variables* or in IDE:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_9.scss[]
----

. The `facebook-theme.properties` file in the `src` directory of the *web* module can be used to override the server-side theme variables from the `halo-theme.properties` file of the platform.

. The new theme has been automatically added to the `web-app.properties` file:
+
[source, properties]
----
cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties /com/company/application/web/facebook-theme.properties
---- 
+
The <<cuba.themeConfig,cuba.themeConfig>> property defines which themes will be available for the user in the *Settings* menu of an application.

. Rebuild the application and start the server. Now the user will see the application in Facebook theme on first login, and will be able to choose between Facebook, Halo and Havana in the *Help* > *Settings* menu.
--

Modifying server-side theme parameters::
+
--
In Halo theme, *Font Awesome* icons are used for standard actions and platform screens by default (if <<cuba.web.useFontIcons,cuba.web.useFontIcons>> is enabled). In this case, you can replace a standard icon by setting the required mapping between the icon and the font element name in `<your_theme>-theme.properties` file. For example, to use "plus" icon for the `create` action in the new Facebook theme, the `facebook-theme.properties` file should contain the following:

[source, properties]
----
@include=halo-theme.properties

cuba.web.icons.create.png = font-icon:PLUS
----

The fragment of the standard users browser screen in the Facebook theme with the modified `create` action:

image::gui_theme_facebook_1.png[align="center"]
--

[[web_theme_inheritance]]
====== Using Themes from Application Components

If your project contains an <<app_components,application component>> with a custom theme, you can use this theme for the whole project.

To inherit the theme as is, simply add it to the <<cuba.themeConfig,cuba.themeConfig>> application property:

[source, plain]
----
cuba.web.theme = {theme-name}
cuba.themeConfig = havana-theme.properties halo-theme.properties /com/company/{app-component-name}/{theme-name}-theme.properties
----

In case you want to override some variables from the parent theme, you need to create a theme extension in your project first.

In the following example we will use the `facebook` theme from the <<web_theme_creation>> section.

. Follow the steps to create the `facebook` theme for you app component.

. Install the app component using Studio menu as described in the <<app_components_sample>> section.

. Extend the `halo` theme in the project that uses your application component.

. By means of your IDE, rename all `halo` occurrences in `themes` directory, including file names, to `facebook` in order to get the following structure:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_28.scss[]
----

. The `app-component.scss` file aggregates theme modifications of the application component. During the SCSS build process, the Gradle plugin automatically finds the app components and imports them in the generated `modules/web/build/themes-tmp/VAADIN/themes/{theme-name}/app-components.scss` file.
+
By default `app-component.scss` does not include variables modifications from `{theme-name}-ext-defaults`. To include variables modifications to app component bundle, you should import it manually in `app-component.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_29.scss[]
----
+
At this stage the `facebook` theme is already imported from the app component to the project.

. Now you can use `facebook-ext.scss` and `facebook-ext-defaults.scss` files inside the `com.company.application` package to override variables from app component's theme and customize it for the concrete project.

. Add the following properties to the `web-app.properties` file to make the `facebook` theme available in the *Settings* menu of the application. Use the relative path to reference `facebook-theme.properties` from the app component.
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_30.scss[]
----

[TIP]
====
In case of any trouble with themes building check `modules/web/build/themes-tmp` directory. It contains all the files and generated `app-component.scss` includes, thus enabling you to investigate SCSS compilation problems.
====

[[web_theme_reusable]]
====== Creating a Reusable Theme

Any theme can be packed and reused without an <<web_theme_inheritance,application component>>. To create a theme package, you need to create a Java project from scratch and bundle it in a single JAR file. Follow the steps below to create a distribution of `facebook` theme from the previous examples.

. Create a new project with the following structure in IDE. It will be a simple Java project that consists of SCSS files and theme properties:
+
--
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_31.scss[]
----

This sample theme project can be downloaded from https://github.com/cuba-labs/halo-facebook[GitHub].

* `build.gradle` script:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_32.groovy[]
----

* `settings.gradle` file:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_33.groovy[]
----

* `app-component.scss` file:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_34.scss[]
----

* `halo-facebook.scss` file:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_35.scss[]
----

* `halo-facebook-defaults.scss` file:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_36.css[]
----

* `halo-facebook-theme.properties` file:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_37.scss[]
----
--

. Build and install the project with the Gradle task:
+
[source, plain]
----
gradle assemble install
----

. Add the theme to your CUBA-based project as a Maven dependency in two configurations: themes and compile, by modifying you `build.gradle` file:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_38.groovy[]
----
+
If you install the theme locally, don't forget to add `mavenLocal()` to the list of repositories: open the *Advanced* tab of *Project Properties* section in Studio and check the *Use local Maven repository* checkbox.

. To inherit this theme and modify it in your project, you have to extend this theme. Extend the `halo` theme and rename `themes/halo` folder to `themes/halo-facebook`:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_39.scss[]
----

. Modify `styles.scss` file:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_40.scss[]
----

. The last step is to define `halo-facebook-theme.properties` file in `web-app.properties` file:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_41.scss[]
----

Now, you can choose `halo-facebook` theme from *Help* > *Settings* menu or set the default theme using `cuba.web.theme` application property.

[[desktop_theme]]
===== Themes in Desktop Applications

The base theme for desktop applications is `Nimbus`.

To add any changes to the standard theme, you need to create a `res.nimbus` package in the `com.sample.sales.desktop` package of the *desktop* module. Theme files will be stored in the `res.nimbus` package.

image::gui_themes_desktop_structure.png[align="center"]

The `icons` folder contains icon files, the `nimbus.xml` file contains the description of the theme style.

The <<app_properties,properties file>> of a desktop application should have `cuba.desktop.resourceLocations` property defined (defines a set of folders containing the style files): 

[source, properties]
----
cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res
----

Below are examples of common tasks.

Adding an icon::
+
--
If you need to add a new icon to a desktop application, for example an icon for a button, you should create a `res.nimbus.icons` package within the `com.sample.sales.desktop` package of the *desktop* module and put the corresponding icon there.

image::gui_themes_example4.png[align="center"]

Description of a <<gui_Button,button>> in the <<screen_xml_glossentry,descriptor>> with a path to an icon set in the <<gui_attr_icon,icon>> attribute:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_10.xml[]
----

Below you can see a button with the attention.png icon.

image::gui_themes_example5.png[align="center"]
--

Redefining default values of theme properties::
+
--
For example, let us change text field background color for mandatory fields.

The `nimbus.xml` file with the following content should be created in the `res.nimbus` package:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_11.xml[]
---- 

The `ui-defaults` element redefines the values of platform theme properties set by default.

The `ui-defaults` element includes both the properties contained in a standard `Nimbus` (http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html) theme and the properties created in the CUBA platform.

In this example, we redefined the value of the CUBA property – `cubaRequiredBackground`, which stores the background color for required fields. This change will affect all required input fields.
--

Creating a style for an element using standard tools::
+
--
Let's consider an example of highlighting a text in bold.

To create a style like that you need to define `style` element in the theme file `nimbus.xml` in the following way:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_12.xml[]
---- 

`style` element can also contain other elements which can define different properties: `background`, `foreground`, `icon`.

You should add <<gui_attr_stylename,stylename>> attribute with the name of the created style into the description of the corresponding label in an <<screen_xml_glossentry,xml-descriptor>>.

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_13.xml[]
---- 

In such way the style will be applied only to the labels that have <<gui_attr_stylename,stylename>> attribute with the value of `boldlabel`.
--

Creating a custom style::
+
--
If standard style adjustment capabilities are insufficient, you can create a custom style.

Let us create a custom style that will be applied to the <<gui_Button,Button>> component. With this style, the the button caption will be underlined.

First, create a decorator class `UnderlinedLabelDecorator`:

[source, java]
----
include::{sourcesdir}/gui/themes/themes_14.java[]
---- 

Define a custom style in `nimbus.xml`:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_15.xml[]
---- 

The `component` attribute of the `style` element contains the name of the component that the style with the name `button-underlined` can be applied to.

The `custom` element should contain a path to the decorator class defined above.

When creating an XML element for a button that should have the custom style, specify the style name in the `stylename` attribute:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_16.xml[]
---- 

The button with the custom style:

image::gui_themes_example6.png[align="center"]
--

[[gui_icons]]
==== Icons

Image files used in the <<gui_attr_icon,icon>> properties for <<gui_Action,actions>> and visual components, e.g. <<gui_Button,Button>>, can be added to your theme extension.

For example, to add an icon to the Halo theme extension, you have to add the image file to the `modules/web/themes/halo` directory described in the <<web_theme_extension>> section (it is recommended to create a subfolder):

[source, plain]
----
themes/
  halo/
    icons/
      cool-icon.png
----

In the following sections, we consider using the icons in visual components and adding icons from arbitrary font libraries.

[[icon_set]]
===== Icon Sets

Icon sets allow you to decouple usage of icons in visual components from real paths to images in theme or font element constants. They also simplify overriding of icons used in the UI inherited from application components.

Icon sets are enumerations with items corresponding to icons. An icon set must implement the `Icons.Icon` interface which has one parameter: a string which denotes the source of an icon, for example, `font-icon:CHECK` or `icons/myawesomeicon.png`. To obtain the source, use the `Icons` bean provided by the platform.

Icon sets should be created in the *gui* module to be accessible from *desktop* and *web* modules. If only *web* module is used, the icon set can be created in the *web* module. All names of icon set items should match the regexp: `[A-Z]_`, i.e. they should contain only upper-case letters and underscores.

For example:

[source, java]
----
public enum MyIcon implements Icons.Icon {

    // adding new icon
    COOL_ICON("icons/cool-icon.png"),

    // overriding a CUBA default icon
    OK("icons/my-ok.png");

    protected String source;

    MyIcon(String source) {
        this.source = source;
    }

    @Override
    public String source() {
        return source;
    }
}
----

Icon sets should be registered in <<cuba.iconsConfig,cuba.iconsConfig>> application property, e.g:

.web-app.properties
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.MyIcon
----

[TIP]
====
To make the icon set from an application component accessible in the target project, this property should be added to the <<app-component.xml,component descriptor>>.
====

Now you can use the icons from this icon set simply by its name declaratively in screen XML descriptor:

[source, xml]
----
<button icon="COOL_ICON"/>
----

or programmatically in the screen controller:

[source, java]
----
button.setIconFromSet(MyIcon.COOL_ICON);
----

The following prefixes allow you to use icons from different sources in declarative way:

* `theme` - the icon will be served from the current theme directory, for example, `web/themes/halo/awesomeFolder/superIcon.png`:
+
[source, xml]
----
<button icon="theme:awesomeFolder/superIcon.png"/>
----

* `file` - the icon will be served from file system:
+
[source, xml]
----
<button icon="file:D:/superIcon.png"/>
----

* `classpath` - icon will be served from classpath, for example, `com/company/demo/web/superIcon.png`
+
[source, xml]
----
<button icon="classpath:/com/company/demo/web/superIcon.png"/>
----

There is one predefined icon set provided by the platform - `CubaIcon`. It includes almost full `FontAwesome` icon set and CUBA-specific icons. These icons can be selected in Studio icon editor:

image::icon_set.png[align="center"]

[[icon_provider]]
===== Using Icons from Other Font Libraries

To enhance the theme extension, you may need to create icons and embed them into fonts, as well as use any external icons library.

. In the *web* module create the `enum` class implementing `com.vaadin.server.FontIcon` interface for the new icons:
+
[source, java]
----
include::{sourcesdir}/gui/add_icons_enum.java[]
----

. Add new styles to the theme extension. We recommend creating a special subfolder `fonts` in the main folder of theme extension, for example, `modules/web/themes/halo/com.company.demo/fonts`. Put the styles and font files in their own subfolders, for example, `fonts/icomoon`.
+
Files of fonts are represented by the following extensions:
+
** `.eot`,
+
** `.svg`,
+
** `.ttf`,
+
** `.woff`.
+
The set of fonts `icomoon` from an open library, used in this example, consists of 4 joint used files: `icomoon.eot`, `icomoon.svg`, `icomoon.ttf`, `icomoon.woff`.

. Create a file with styles that includes `@font-face` and a CSS class with the icon style. Below is an example of the `icomoon.scss` file, where `IcoMoon` class name corresponds to the value returned by `FontIcon#getFontFamily` method:
+
[source, css]
----
include::{sourcesdir}/gui/add_icons_icomoon.scss[]
----

. Create a reference to the file with font styles in `halo-ext.scss` or other file of theme extension:
+
[source, css]
----
include::{sourcesdir}/gui/add_icons_halo-ext.scss[]
----

. Then create new <<icon_set,icon set>> which is an enumeration implementing the `Icons.Icon` interface:
+
[source, java]
----
include::{sourcesdir}/gui/IcoMoonIcon.java[]
----

. Create new `IconProvider`.
+
--
For managing custom icon sets CUBA platform provides the mechanism that consists of `IconProvider` and `IconResolver`.

`IconProvider` is a marker interface that exists only in the *web* module and can provide resources (`com.vaadin.server.Resource`) by the icon path.

The `IconResolver` bean obtains all beans that implement `IconProvider` interface and iterates over them to find the one that can provide a resource for the icon.

There are two `IconResolver` interfaces and two corresponding implementations for *desktop* and *web* modules. They both are facade beans designed for resolving module-specific icon objects by the icon paths:

* `com.vaadin.server.Resource` in the *web* module,
* `javax.swing.Icon` for the *desktop* module.

In order to use this mechanism, you should create your implementation of `IconProvider`:

[source, java]
----
include::{sourcesdir}/gui/IcoMoonIconProvider.java[]
----

Here we explicitly assign order for this bean with `@Order annotation`.
--

. Register you icon set in the application properties file:
+
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.IcoMoonIcon
----

Now you can use new icons by direct reference to their class and `enum` element in XML-descriptor of the screen:

[source, xml]
----
include::{sourcesdir}/gui/add_icons_usage.xml[]
----

or in the Java controller:

[source, java]
----
include::{sourcesdir}/gui/add_icons_usage.java[]
----

As a result, new icons are added to the buttons:

image::add_icons.png[align="center"]

Overriding icons with icon sets::
+
--
The mechanism of icon sets enables you to override icons from other sets. In order to do this, you should create and register a new icon set (enumeration) with the same icons (options) but with different icon paths (`source`). In the following example the new `MyIcon` enum is created to override the standard icons from `CubaIcon` set.

. The default icon set:
+
[source, java]
----
include::{sourcesdir}/gui/CubaIcon.java[]
----

. The new icon set:
+
[source, java]
----
include::{sourcesdir}/gui/MyIcon.java[]
----

. Register the new icon set in `web-app.properties`:
+
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.MyIcon
----

Now, the new *OK* icon will be used instead of the standard one:

[source, java]
----
include::{sourcesdir}/gui/overridden_icon.java[]
----

In case you need to ignore redefinitions, you still can use the standard icons by using the path to an icon instead of the option name:

[source, xml]
----
<button caption="Created" icon="icons/create.png"/>
----

or

[source, java]
----
button.setIcon(CubaIcon.CREATE_ACTION.source());
----
--

[[gui_web]]
==== Web Client Specifics

Implementation of the generic user interface of the *Web Client* <<app_tiers,block>> is based on the *Vaadin* framework. The main classes available in the web client infrastructure are described below.

.Web Client Infrastructure Classes
image::WebClientInfrastructure.png[align="center"]

* `App` - the central class of the application infrastructure. Contains links to `Connection` and other infrastructure objects. Only one instance of `App` exists for a given HTTP session. You can get a reference to the `App` instance by using the `App.getInstance()` static method. If you want to customize functionality of `App` in your project, create a class extending `DefaultApp` in the root package of your *web* module and register it in <<spring.xml, web-spring.xml>> as the `cuba_App` bean, for example:
+
[source, xml]
----
<bean name="cuba_App" class="com.company.sample.web.MyApp" scope="vaadin"/>
----

* `Connection` is an interface providing functionality of connecting to middleware and holding a <<userSession,user
session>>. `ConnectionImpl` is a standard implementation of this interface.

* `ExceptionHandlers` class contains a collection of <<exceptionHandlers,client-level exception handlers>>.

* `AppUI` is a platform class inherited from `com.vaadin.ui.UI` class. There is one instance of this class for each open tab of a web browser. Contains a link to a `TopLevelWindow` implementation – either a login window or main window, depending on the connection state. You can get a reference to the `AppUI` for the current browser tab by using the `AppUI.getCurrent()` static method.

* `AppLoginWindow` – the window displayed before a user logs in. You can customize the login window by extending `AppLoginWindow` or create completely new one by extending <<abstractWindow,AbstractWindow>> and implementing the `TopLevelWindow` marker interface. In Studio, go to the *Screens* section and click *Create login window*. If you override the `init()` method, make sure you invoke `super.init(params)`.

* `AppMainWindow` – main application window displayed after a user logs in. You can customize the main window by extending `AppMainWindow` or create completely new one by extending `AbstractMainWindow` and defining desired layout in XML descriptor. In Studio, go to the *Screens* section and click *Create main window*. If you override the `init()` method, make sure you invoke `super.init(params)`.
+
You can control certain main window parameters without redefining the default implementation using the following application properties:
+
--
** <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> - enables creation of <<folders_pane,folders pane>>.

** <<cuba.web.appWindowMode,cuba.web.appWindowMode>> – sets default mode for the main window: tabbed or single screen (`TABBED` or `SINGLE`). Users can change the mode later using *Help* > *Settings* screen.

** <<cuba.web.maxTabCount,cuba.web.maxTabCount>> – when the main window is in the tabbed mode, this property sets the maximum number of tabs that a user can open. The default value is 7.
--

* `WindowManager` - the central class implementing application screens management logic. `openWindow()`, `openEditor()`, `showMessageDialog()` and other methods of the `Frame` interface implemented by screen <<screen_controller,controllers>> delegate to the window manager. `WindowManager` class is located in the platform's common *gui* module and is abstract. The *web* module has a dedicated `WebWindowManager` class that implements web client specifics. You can get a reference to `WindowManager` from any `Window` implementation (e.g. a screen controller), or via the `WindowManagerProvider` bean.

If you want to handle the browser *Back* button, implement the `CubaHistoryControl.HistoryBackHandler` interface in your `TopLevelWindow` (login and/or main windows). Its `onHistoryBackPerformed()` method is invoked instead of standard browser behavior if the <<cuba.web.allowHandleBrowserHistoryBack,cuba.web.allowHandleBrowserHistoryBack>> application property is set to true.

[[webComponentsHelper]]
===== Working with Vaadin Components

In order to work directly with Vaadin components that implement interfaces of the <<gui_vcl,visual components library>> in Web Client, use the following methods of the `Component` interface:

* `unwrap()` – retrieves an underlying Vaadin component for a given CUBA component.

* `unwrapComposition()` - retrieves a Vaadin component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as <<gui_Button,Button>>, this method returns the same object as `unwrap()` - `com.vaadin.ui.Button`. For complex components, such as <<gui_Table,Table>>, `unwrap()` will return the corresponding object - `com.vaadin.ui.Table`, while `unwrapComposition()` will return `com.vaadin.ui.VerticalLayout`, which contains the table together with <<gui_ButtonsPanel,ButtonsPanel>> and `RowsCount` defined with it.

The methods accept a class of the underlying component to be returned, for example:

[source, java]
----
com.vaadin.ui.TextField vTextField = textField.unwrap(com.vaadin.ui.TextField.class);
----

You can also use the `unwrap()` and `getComposition()` static methods of the `WebComponentsHelper` class, passing a CUBA component into them.

Please note that if a screen is located in the project's *gui* module, you can only work with generalized interfaces of CUBA components. In order to use `unwrap()` you should either put the entire screen into the *web* module, or use the <<companions,controller companions>> mechanism.

[[main_window_layout]]
===== Main Window Layout

The mechanism described below allows you to design the application main window layout with CUBA Generic UI technology by creating an XML-descriptor and Java controller, and using <<gui_vcl,UI components>> and <<datasources,data sources>>. 

The main window is defined by a specific screen with `mainWindow` identifier. Its controller should be derived from the `AbstractMainWindow` class. 

The following special components may be used in the main window in addition to the standard UI components:

* `AppMenu` - main application menu.

* `FoldersPane` - application and search <<folders_pane,folders panel>>.

*  `AppWorkArea` - work area, the required component for opening screens in the `++THIS_TAB++`, `++NEW_TAB++` and `++NEW_WINDOW++` modes. 

* `UserIndicator` - the field which displays the name of the current user, as well as enables selecting substituted users, if any.
+
--
The `setUserNameFormatter()` method allows you to represent the user's name in a format different from the `User` instance name:

[source, java]
----
include::{sourcesdir}/gui/main_window.java[]
----

image::userIndicator.png[align="center"]
--

* `NewWindowButton` - the button which opens a new main window in a separate browser tab.

* `LogoutButton` - the application logout button.

* `TimeZoneIndicator` - the label displaying the current user's <<timeZone,time zone>>.

* `FtsField` - the full text search field.

In order to define the special components, add the `xmlns:main` namespace to the screen: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_1.xml[]
----

The `AppWorkArea` component is designed to show application screens. If the <<cuba.web.appWindowMode,cuba.web.appWindowMode>> application property is `TABBED` (default), the work area shows a TabSheet with open screens. Otherwise a single open screen is shown. The <<cuba.web.mainTabSheetMode,cuba.web.mainTabSheetMode>> and <<cuba.web.managedMainTabSheetMode,cuba.web.managedMainTabSheetMode>> application properties define how the tabs content is handled when the tabs are switched. When no screens are opened, the work area shows components defined in the `initialLayout` internal element:

[source, xml]
----
include::{sourcesdir}/gui/main_window_2.xml[]
---- 

The initial screen layout (`initialLayout`) is removed from `AppWorkArea` when the first application screen is opened, and added back when all screens are closed. You can add `AppWorkArea.StateChangeListener` to handle changing the work area between the initial layout and application screens. Such listener can, for example, refresh the initial layout data. 

The platform provides 2 standard main window implementations. XML descriptor of the default main window with horizontal menu on top is available in `/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml`, its corresponding controller class is `AppMainWindow`. Another available template contains the <<gui_SideMenu, vertical side menu>>.

The standard implementation can be extended in the project, like any other application screen. Example of an extending screen:

[source, xml]
----
include::{sourcesdir}/gui/main_window_3.xml[]
----

This screen should be registered in <<screens.xml,web-screens.xml>> file with the `mainWindow` identifier.

The easiest way to extend the main screen is provided by CUBA Studio: click *New* on the GENERIC UI tab of the navigation panel and choose the template for the new main screen in the *Generic UI templates* visual designer. The new `ext-mainwindow.xml` file will be created in the Web module and automatically registered in `web-screens.xml`.

CUBA Platform provides 2 standard main window layout templates: with horizontal menu and with the <<gui_SideMenu, side menu>>. The standard main window implementation may be fully replaced with a custom one. For example:

[source, xml]
----
include::{sourcesdir}/gui/main_window_4.xml[]
---- 

The resulting main window is shown below: 

image::main_window_1.png[align="center"]

The same main window with an open screen: 

image::main_window_2.png[align="center"]

The <<cuba.web.showBreadCrumbs,cuba.web.showBreadCrumbs>> application property allows you to hide the navigation panel (breadcrumbs) above the opened screen.

[[web_login]]
===== Web Login

This section describes how the web client authentication works and how to extend it in your project. For information about authentication on the middle tier, see <<login>>.

Implementation of the login procedure of the Web Client block has the following mechanisms:

- `Connection` implemented by `ConnectionImpl`.
- `LoginProvider` implementations.
- `HttpRequestFilter` implementations.

.Login mechanisms of the Web Client
image::WebLoginStructure.png[align="center"]

The main interface of Web login subsystem is `Connection` which contains the following key methods:

- *login()* - authenticates a user, starts a session and changes the state of the connection.
- *logout()* - log out of the system.
- *substituteUser()* - substitute a user in the current session with another user. This method creates a new *UserSession* instance, but with the same session ID.
- *getSession()* - get the current user session.

After successful login, *Connection* sets *UserSession* object to the attribute of `VaadinSession` and sets `SecurityContext`. The *Connection* object is bound to `VaadinSession` thus it cannot be used from non-UI threads, it throws *IllegalConcurrentAccessException* in case of `login/logout` call from a non UI thread.

Usually, login is performed from the `AppLoginWindow` screen that supports login with login/password and "remember me" credentials.

The default implementation of `Connection` is `ConnectionImpl`, which delegates login to a chain of `LoginProvider` instances. A `LoginProvider` is a login module that can process a specific `Credentials` implementation, also it has a special `supports()` method to allow the caller to query if it supports a given `Credentials` type.

.Standard user login process
image::WebLoginProcedure.png[align="center"]

Standard user login process:

* Users enter their username and password.

* Web client block creates a `LoginPasswordCredentials` object passing the login and password to its constructor and invokes `Connection.login()` method with this credentials.

* `Connection` uses chain of `LoginProvider` objects. There is `LoginPasswordLoginProvider` that works with `LoginPasswordCredentials` instances. It hashes the password using the `getPlainHash()` method of `PasswordEncryption` bean and invokes `AuthenticationService.login(Credentials)`.

* If the authentication is successful, the created `AuthenticationDetails` instance with the active <<userSession,UserSession>> is passed back to `Connection`.

* `Connection` creates a `ClientUserSession` wrapper and sets it to `VaadinSession`.

* `Connection` creates a `SecurityContext` instance and sets it to `AppContext`.

* `Connection` fires `StateChangeEvent` that triggers UI update and leads to the `AppMainWindow` initialization.

All `LoginProvider` implementations must:

* Authenticate user using `Credentials` object.
* Start a new user session with `AuthenticationService` or return another active session (for instance, anonymous).
* Return authentication details or null if it cannot login user with this `Credentials` object, for instance, if the login provider is disabled or is not properly configured.
* Throw `LoginException` in case of incorrect `Credentials` or pass `LoginException` from the middleware to the caller.

[[web_http_filter]]
`HttpRequestFilter` - marker interface for beans that will be automatically added to the application filter chain as HTTP filter: https://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html. You can use it to implement additional authentication, pre- and post-processing of request and response.

You can expose additional `Filter` if you create Spring Framework component and implement `HttpRequestFilter` interface:
[source, java]
----
include::{sourcesdir}/gui/web_customHttpFilter.java[]
----

Please note that the minimal implementation has to delegate execution to `FilterChain` otherwise your application will not work. By default, filters added as `HttpRequestFilter` beans will not receive requests to `VAADIN` directory and other paths specified in `cuba.web.cubaHttpFilterBypassUrls` app property.

[[built_in_login_providers]]
Built-in login providers::
+
--
The platform contains the following implementations of `LoginProvider` interface:

- `AnonymousLoginProvider` - provides anonymous login for non-logged-in users.
- `LoginPasswordLoginProvider` - delegates login to `AuthenticationService` with `LoginPasswordCredentials`.
- `RememberMeLoginProvider`- delegates login to `AuthenticationService` with `RememberMeCredentials`.
- `LdapLoginProvider` - performs authentication using LDAP and logs in users with `ExternalUserCredentials`.
- `ExternalUserLoginProvider` - can be used from event handlers to perform login as provided user name.

All the implementations create an active user session using `AuthenticationService.login()`.

You can override any of them using Spring Framework mechanisms.
--

[[web_login_events]]
Events::
+
--
Standard implementation of `Connection` - `ConnectionImpl` fires the following application <<events, events>> during login procedure:

- `BeforeLoginEvent` / `AfterLoginEvent`
- `LoginFailureEvent`
- `UserConnectedEvent` / `UserDisconnectedEvent`
- `UserSessionStartedEvent` / `UserSessionFinishedEvent`
- `UserSessionSubstitutedEvent`

Event handlers of `BeforeLoginEvent` and `LoginFailureEvent` may throw `LoginException` to cancel login process or override the original login failure exception.

For instance, you can permit login to Web Client only for users with login that includes a company domain using `BeforeLoginEvent`.

[source, java]
----
include::{sourcesdir}/gui/web_beforeLoginEventListener.java[]
----

Additionally, the standard application class - `DefaultApp` fires the following events:

- `AppInitializedEvent` - fired after `App` initialization, performed once per HTTP session.
- `AppStartedEvent` - fired on the first request processing of an `App` right before login as anonymous user. Event handlers may login the user using the `Connection` object bound to `App`.
- `AppLoggedInEvent` - fired after UI initialization of `App` when a user is logged in.
- `AppLoggedOutEvent` - fired after UI initialization of `App` when a user is logged out.
- `SessionHeartbeatEvent` - fired on heartbeat requests from a client web browser.

`AppStartedEvent` can be used to implement SSO login with third-party authentication system, for instance Jasig CAS. Usually, it is used together with a custom `HttpRequestFilter` bean that should collect and provide additional authentication data.

Let's assume that we will automatically log in users if they have a special cookie value - `PROMO_USER`.

[source, java]
----
include::{sourcesdir}/gui/web_appStartedEventListener.java[]
----

Thus if users have "PROMO_USER" cookie and open the application, they will be automatically logged in as `promoUserLogin`.

If you want to perform additional actions after login and UI initialization you could use `AppLoggedInEvent`. Keep in mind that you have to check if a user is authenticated or not in event handlers, all the events are fired for `anonymous` user as well.

--

[[web_login_extension_points]]
Extension points::
+
--
You can extend login mechanisms using the following types of extension points:

- `Connection` - replace existing `ConnectionImpl`.
- `HttpRequestFilter` - implement additional `HttpRequestFilter`.
- `LoginProvider` implementations - implement additional or replace existing `LoginProvider`.
- Events - implement event handler for one of the available <<web_login_events,events>>.

You can replace existing beans using Spring Framework mechanisms, for instance by registering a new bean in Spring XML config of the *web* module.

[source, xml]
----
<bean id="cuba_LoginPasswordLoginProvider"
      class="com.company.demo.web.CustomLoginProvider"/>
----

--

[[web_login_obsolete]]
Obsolete/Deprecated::
+
--

Custom implementation of the `CubaAuthProvider` interface can be enabled by setting the following application properties:

[source, properties]
----
cuba.web.externalAuthentication = true
cuba.web.externalAuthenticationProviderClass = com.company.sample.web.MyAuthProvider
----

The following components are now deprecated:

- `CubaAuthProvider` and its implementations are available in compatibility mode. Use events, `LoginProvider` and `HttpRequestFilter` instead.
- `LdapAuthProvider` has been replaced with `LdapLoginProvider` that can be enabled as described here: <<ldap_basic,LDAP integration>>
- `IdpAuthProvider` has been replaced with `IdpLoginProvider` that can be enabled as described here: <<sso,IDP SSO>>

Do not use these components. They will be removed in the next major version of the platform.
--

[[gui_desktop]]
==== Desktop Client Specifics

Implementation of the generic user interface in the *Desktop Client* <<app_tiers,block>> is based on *Java Swing*. The main classes available in the desktop client infrastructure are described below.

.Classes of the Desktop Client Infrastructure
image::DesktopClientInfrastructure.png[align="center"]

* `App` – central class of the desktop application infrastructure. Contains links to `Connection` and main `TopLevelFrame`, as well as methods for initialization and retrieval of application settings.
+
In your application, you should create a custom class – inheritor of `App` and override the following methods:

** `getDefaultAppPropertiesConfig()` - should return a string where all <<app_properties_files,application properties files>> should be listed separated by spaces: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_1.java[]
---- 

** `getDefaultHomeDir()` - should return path to the folder, where temporary and work files should be stored. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_2.java[]
---- 

** `getDefaultLogConfig()` - should return name of the *Logback* configuration file, if it is defined for the project. For example:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_3.java[]
---- 
+
Additionally, for your custom class inheriting from the `App` you should define `main()` method in the following way: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_4.java[]
---- 

* `Connection` - is a class that provides the functionality of connecting to middleware and storing a <<userSession,user session>>. 

* `LoginDialog` – the dialog to enter credentials. In your application you can create an inheritor of `LoginDialog` and redefine the `createLoginDialog()` method of the `App` class to use it.

* `TopLevelFrame` – inheritor of `JFrame`, which is the top level window. The application has at least one instance of this class created when application is started and containing the main menu. This instance is returned by the `getMainFrame()` method of the `App` class.
+
When a user detaches tabs from the main window or a <<gui_TabSheet,TabSheet>> (see `detachable` attribute), additional instances of `TopLevelFrame` that do not contain main menu are created.

* `WindowManager` - the central class implementing application screens management logic. `openEditor()`, `showMessageDialog()` and other methods of the `Frame` interface implemented by screen <<screen_controller,controllers>> delegate to the window manager. `WindowManager` class is located in the platform's common *gui* module and is abstract. The *desktop* desktop module has a dedicated `DesktopWindowManager` class that implements desktop client specifics.
+
Typically, `WindowManager` is not used in the application code directly.

* `ExceptionHandlers` - contains a collection of <<exceptionHandlers,client-level exception handlers>>.

[[desktopComponentsHelper]]
===== Working with Swing Components

In order to work directly with Swing components that implement interfaces of the <<gui_vcl,visual components library>> in Desktop Client, use the following methods of the `Component` interface:

* `unwrap()` – retrieves an underlying Swing component for a given CUBA component.

* `unwrapComposition()` - retrieves a Swing component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as <<gui_Button,Button>>, this method returns the same object as `unwrap()` - `javax.swing.JButton`. For complex components, such as <<gui_Table,Table>>, `unwrap()` will return the corresponding `org.jdesktop.swingx.JXTable` instance, while `unwrapComposition()` will return an instance of `javax.swing.JPanel`, which contains a table together with <<gui_ButtonsPanel,ButtonsPanel>> and `RowsCount` defined with it.

The methods accept a class of the underlying component to be returned, for example:

[source, java]
----
javax.swing.JButton jButton = button.unwrap(javax.swing.JButton.class);
----

You can also use the `unwrap()` and `getComposition()` static methods of the `DesktopComponentsHelper` class, passing a CUBA component into them.

Please note that if a screen is located in the project's *gui* module, you can only work with generalized interfaces of CUBA components. In order to use `unwrap()` you should either put the entire screen in the *desktop* module, or use the <<companions,controller companions>> mechanism.

[[own_components]]
==== Custom Visual Components

This section contains an overview of different ways of creating custom web UI components in CUBA applications. The practical tutorial of using these approaches is located in the <<own_component_samples>> section.

A new component can be created with the following technologies:

. On the basis of a Vaadin add-on.
+
--
This is the simplest method. The following steps are required to use an add-on in your application:

** Add a dependency to the add-on artifact to <<build.gradle,build.gradle>>.

** Create the *web-toolkit* module in your project. This module contains a GWT widgetset file and allows you to create client-side parts of visual components.

** Include the add-on widgetset to the widgetset of your project.

** If the component's look does not fit the application theme, create a theme extension and define some CSS for the new component.

See an example in the <<vaadin_addon_sample>> section.
--

. As a wrapper of a JavaScript library.
+
--
This method is recommended if you already have a pure JavaScript component that does what you need. To use it in your application, you need to do the following:

** Create a server-side Vaadin component in the *web* module. A server component defines an API for server code, access methods, event listeners, etc. The server component must extend the `AbstractJavaScriptComponent` class. Note that the *web-toolkit* module with a widgetset is not required when integrating a JavaScript component.

** Create a JavaScript connector. A connector is a function that initializes the JavaScript component and is responsible for interaction between JavaScript and the server-side code.

** Create a state class. Its public fields define what data are sent from the server to the client. The class must extend `JavaScriptComponentState`.

See an example in the <<js_library_sample>> section.
--

. As a resource from link:https://www.webjars.org/[WebJar]. See the section <<using_webjars, below>> for details.

. As a new link:http://www.gwtproject.org[GWT] component.
+
--
This is the recommended method of creating completely new visual components. The following steps are required to create and use a GWT component in your application:

** Create the *web-toolkit* module.

** Create a client-side GWT widget class.

** Create a server-side Vaadin component.

** Create a component state class that defines what data are sent between the client and the server.

** Create a connector class that links the client code with the server component.

** Create an RPC interface that defines a server API that is invoked from the client.

See an example in the <<gwt_component_sample>> section.
--

There are three levels of integration of a new component into the platform.

* On the first level, the new component becomes available as a native Vaadin component. An application developer can use this component in screen controllers directly: create a new instance and add it to an <<webComponentsHelper,unwrapped>> container. All methods of creating new components described above give you a component on this level of integration.

* On the second level, the new component is integrated into CUBA Generic UI. In this case, from an application developer perspective, it looks the same as a standard component from the visual components library. The developer can define the component in a screen XML descriptor or create it through `ComponentsFactory` in a controller. See an example in the <<vaadin_addon_sample_gui>> section.

* On the third level, the new component is available on the Studio components palette and can be used in the WYSIWYG layout editor. See an example in the <<own_component_in_studio>> section.

[[using_webjars]]
===== Using WebJars

This method allows you to use various JS libraries packaged into JAR files and deployed on link:http://search.maven.org/[Maven Central]. The following steps are required to use a component from a WebJar in your application:

** Add dependency to the `compile` method of *web* module:
+
[source, groovy]
----
compile 'org.webjars.bower:jrcarousel:1.0.0'
----

** Create the *web-toolkit* module.

** Create a client-side GWT widget class and implement the `native` JSNI method for creating the component.

** Create a server-side component class with `@WebJarResource` annotation.
+
--
This annotation should be used only with `ClientConnector` inheritors (which are classes of UI components from the *web-toolkit* module usually).

The value of the `@WebJarResource` annotation, or the resource definition, should follow one of the two possible templates:

. `<webjar_name>:<sub_path>`, for example:
+
[source, java]
----
@WebJarResource("pivottable:plugins/c3/c3.min.css")
----

. `<webjar_name>/<resource_version>/<webjar_resource>`, for example:
+
[source, java]
----
@WebJarResource("jquery-ui/1.12.1/jquery-ui.min.js")
----

The annotation value can have one or more (String array) WebJar resource String definitions:

[source, java]
----
@WebJarResource({
        "jquery-ui:jquery-ui.min.js",
        "jquery-fileupload:jquery-fileupload.min.js",
        "jquery-fileupload:jquery-fileupload.min.js"
})
public class CubaFileUpload extends CubaAbstractUploadComponent {
    ...
}
----

Specifying the WebJar version is not required, as due to Maven version resolution strategy the WebJar with the higher version will be used automatically.

[[using_webjars_overridePath]]
Optionally, you can specify a directory inside `VAADIN/webjars/` from which the static resources will be served. Thus you can override WebJar resources by placing new versions of resources in this directory. To set the path, use the `overridePath` property of the `@WebJarResource` annotation, for example:

[source, java]
----
@WebJarResource(value = "pivottable:plugins/c3/c3.min.css", overridePath = "pivottable")
----
--

** Add new component to the screen.

[[pluggable_component_factories]]
==== Pluggable Component Factories

The pluggable component factories mechanism extends the standard component creation procedure and allows you to create different edit fields in <<gui_FieldGroup, FieldGroup>>, <<gui_Table, Table>> and <<gui_DataGrid, DataGrid>>. It means that application components or your project itself can provide custom strategies that will create non-standard components and/or support custom data types.

An entry point to the mechanism is the `ComponentsFactory.createComponent(ComponentGenerationContext)` method. It works as follows:

* Tries to find `ComponentGenerationStrategy` implementations. If at least one strategy exists, then:
** Iterates over strategies according to the `org.springframework.core.Ordered` interface.
** Returns the first created not `null` component.

`ComponentGenerationStrategy` implementations are used to create UI components. A project can contain any number of such strategies.

`ComponentGenerationContext` is a class which stores the following information that can be used when creating a component:

* `metaClass` - defines the entity for which the component is created.
* `property` - defines the entity attribute for which the component is created.
* `datasource` - a datasource.
* `optionsDatasource` - a datasource that can be used to show options.
* `xmlDescriptor` - an XML descriptor which contains additional information, in case the component is declared in an XML descriptor.
* `componentClass` - a component class for which a component is created, e.g. `FieldGroup`, `Table`, `DataGrid`.

There are two built-in component strategies:

* `DefaultComponentGenerationStrategy` - used to create a component according to the given `ComponentGenerationContext` object. Has the order value `ComponentGenerationStrategy.LOWEST_PLATFORM_PRECEDENCE` (1000).
* `DataGridEditorComponentGenerationStrategy` - used to create a component according to the given `ComponentGenerationContext` object for a DataGrid Editor. Has the order value `ComponentGenerationStrategy.HIGHEST_PLATFORM_PRECEDENCE + 30` (130).

The sample below shows how to replace the default *FieldGroup* component generation for a certain attribute of a specific entity.

[source, java]
----
include::{sourcesdir}/gui/pluggable_field_factories1.java[]
----

[WARNING]
====
Pay attention that overriding existing generation strategies may produce errors in case of changing returned component type, because some screen controllers may have code that expects a certain component type.


For example, in case of using the strategy above, the following injection will produce the exception:

[source, java]
----
@Named("fieldGroup.date")
private DateField dateField;
----

If you try to open such screen you will get the following exception:

----
IllegalArgumentException: Can not set com.haulmont.cuba.gui.components.DateField field com.company.sales.web.order.OrderEdit.dateField to com.haulmont.cuba.web.gui.components.WebDatePicker
----

====

The sample below shows how to define a `ComponentGenerationStrategy` for a specific <<datatype,datatype>>.

[source, java]
----
include::{sourcesdir}/gui/pluggable_field_factories2.java[]
----

[[shortcuts]]
==== Keyboard Shortcuts

This section provides a list of keyboard shortcuts used in the generic user interface of the application. All the <<app_properties,application properties>> listed below belong to the `ClientConfig` interface and can be used in Web Client and Desktop Client application blocks. 

* Main application window.

** *CTRL-SHIFT-PAGE_DOWN* – switch to the next tab. Defined by the `cuba.gui.nextTabShortcut` property.

** *CTRL-SHIFT-PAGE_UP* – switch to the previous tab. Defined by the `cuba.gui.previousTabShortcut` property.

* Folders panel.

** *ENTER* – open the selected <<folders_pane,folder>>.

** *SPACE* - select/deselect the focused folder.

** *ARROW UP*, *ARROW DOWN* - switch between folders.

** *ARROW LEFT*, *ARROW RIGHT* - collapse/expand a folder with subfolders or jump to the owning folder.

* Screens.

** *ESCAPE* – close the current <<abstractWindow,screen>>. Defined by the `cuba.gui.closeShortcut` property.

** *CTRL-ENTER* – close the current <<abstractEditor,editor>> and save the changes. Defined by the `cuba.gui.commitShortcut` property.

* Standard actions for list components (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). In addition to these application properties, a shortcut for a particular action can be set by calling it's `setShortcut()` method.

** *CTRL-\* – call the <<createAction,CreateAction>>. Defined by the `cuba.gui.tableShortcut.insert` property.

** *CTRL-ALT-\* – call the <<addAction,AddAction>>. Defined by the `cuba.gui.tableShortcut.add` property.

** *ENTER* – call the <<editAction,EditAction>>. Defined by the `cuba.gui.tableShortcut.edit` property.

** *CTRL-DELETE* – call the <<removeAction,RemoveAction>> and <<excludeAction,ExcludeAction>>. Defined by the `cuba.gui.tableShortcut.remove` property.

* Drop-down lists (<<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>).

** *SHIFT-DELETE* – clear the value.

* Standard actions for lookup fields (<<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>). In addition to these application properties, a shortcut for a particular action can be set by calling its `setShortcut()` method.
+
--
** *CTRL-ALT-L* – call the <<lookupAction,LookupAction>>. Defined by the `cuba.gui.pickerShortcut.lookup`.

** *CTRL-ALT-O* – call the <<openAction,OpenAction>>. Defined by the `cuba.gui.pickerShortcut.open` property.

** *CTRL-ALT-C* – call the <<clearAction,ClearAction>>. Defined by the `cuba.gui.pickerShortcut.clear` property.

In addition to these shortcuts, lookup fields support action calls with CTRL-ALT-1, CTRL-ALT-2 and so on, depending on the number of actions. If you click CTRL-ALT-1 the first action in the list will be called; clicking CTRL-ALT-2 calls the second action, etc. The CTRL-ALT combination can be replaced with any other combination specified in `cuba.gui.pickerShortcut.modifiers` property.
--

* <<gui_Filter,Filter>> component.

** *SHIFT-BACKSPACE* – open the filter selection popup. Defined by the `cuba.gui.filterSelectShortcut` property.

** *SHIFT-ENTER* – apply the selected filter. Defined by the `cuba.gui.filterApplyShortcut` property.
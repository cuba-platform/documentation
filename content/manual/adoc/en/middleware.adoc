[[middleware]]
=== Middleware Components

The following figure shows the main components of the CUBA application middle tier.

.Components of the Middle Tier
image::Middleware.png[align="center"]

<<services,Services>> are <<container, container>>-managed components that form the application boundary and provide the interface to the client <<app_tiers,tier>>. Services may contain the business logic themselves or delegate the execution to managed beans.

<<managed_beans,Managed beans>> are container-managed components that contain the business logic of the application. They are called by services, other beans or via the optional <<jmx, JMX>> interface.

<<persistence,Persistence>> is the infrastructure interface to access the data storage functionality: <<orm,ORM>> and <<transactions,transactions>> management. 

[[services]]
==== Services

Services form the layer that defines a set of Middleware operations available to the client <<app_tiers,tier>>. In other words, a service is an entry point to the Middleware business logic. In a service, you can manage <<transactions,transactions>>, check user <<permissions,permissions>>, work with the database or delegate execution to other <<managed_beans,managed beans>> of the middle tier.

Below is a class diagram which shows the components of a service:

image::MiddlewareServices.png[align="center"]

The service interface is located in the *global* module and is available for both middle and client tiers. At runtime, a proxy is created for the service interface on the client tier. The proxy provides invocation of service bean methods using Spring HTTP Invoker mechanism.

The service implementation bean is located in the *core* module and is available on the middle tier only.

`ServiceInterceptor` is called automatically for any service method using Spring AOP. It checks the availability of the user session for the current thread, and transforms and logs exceptions if the service is called from the client tier.

[[service_creation]]
===== Creating a Service

The name of service interface should end with `Service`, the names of implementation class – with `ServiceBean`.

The following steps are required for creating a service:

. Create the service interface in the *global* <<app_modules,module>>, as the service interface must be available at all <<app_tiers,tiers>>), and specify the service name in it. It is recommended to specify the name in the following format: `++{project_name}_{interface_name}++`. For example:
+
[source, java]
----
include::{sourcesdir}/middleware/service_1.java[]
----

. Create the service class in the *core* module and add the `@org.springframework.stereotype.Service` annotation to it with the name specified in the interface: 
+
[source, java]
----
include::{sourcesdir}/middleware/service_2.java[]
----

The service class, being a <<managed_beans,managed bean>>, should be placed inside the package tree with the root specified in the `context:component-scan` element of the <<spring.xml,spring.xml>> file. In this case, the `spring.xml` file contains the element:

[source, xml]
----
include::{sourcesdir}/middleware/service_3.xml[]
----

which means that the search for annotated beans for this application block will be performed starting with the `com.sample.sales` package.

If different services or other Middleware components require calling the same business logic, it should be extracted and encapsulated inside an appropriate <<managed_beans,managed bean>>. For example:

[source, java]
----
include::{sourcesdir}/middleware/service_7_1.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/service_7_2.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/service_7_3.java[]
----

[[service_import]]
===== Using a Service

In order to call a service, the corresponding proxy object should be created in the client block of the application. There is a special factory that creates service proxies: for the Web Client block, it is `WebRemoteProxyBeanCreator`, for Web Portal – `PortalRemoteProxyBeanCreator`, for Desktop Client – `RemoteProxyBeanCreator`.

The proxy object factory is configured in <<spring.xml,spring.xml>> of the corresponding client block and contains service names and interfaces.

For example, to call the `++sales_OrderService++` service from the web client in the *sales* application, add the following code into the `web-spring.xml` file of the *web* module:

[source, xml]
----
include::{sourcesdir}/middleware/service_4.xml[]
----

All imported services should be declared in the single `remoteServices` property in the `map/entry` elements.

[TIP]
====
CUBA Studio automatically registers services in all client blocks of the project.
====

From the application code perspective, the service's proxy object at the client level is a standard Spring bean and can be obtained either by injection or through `AppBeans` class. For example:

[source, java]
----
include::{sourcesdir}/middleware/service_5.java[]
----

or

[source, java]
----
include::{sourcesdir}/middleware/service_6.java[]
----

[[dataService]]
===== DataService

`DataService` provides a facade for calling <<dataManager,DataManager>> middleware implementation from the client tier. The usage of `DataService` interface in the application code is not recommended. Instead, use `DataManager` directly on both middle and client tiers.

[[data_store]]
==== Data Stores

A usual way of working with data in CUBA applications is manipulating entities - either declaratively through <<datasources,datasources>> and data-aware visual components, or programmatically via <<dataManager,DataManager>> or <<entityManager,EntityManager>>. The entities are mapped to data in a data store, which is usually a relational database. An application can connect to multiple data stores so its <<data_model,data model>> will contain entities mapped to data located in different databases.

An entity can belong only to a single data store. You can display entities from different data stores on a single UI screen, and `DataManager` will ensure they will be dispatched to appropriate data stores on save. Depending on the entity type, `DataManager` selects a registered data store represented by an implementation of the `DataStore` interface and delegates loading and saving entities to it. When you control transactions in your code and work with entities via `EntityManager`, you have to specify explicitly what data store to use. See the <<persistence,Persistence>> interface methods and <<transactions_decl,@Transactional>> annotation parameters for details.

The platform contains a single implementation of the `DataStore` interface called `RdbmsStore`. It is designed to work with relational databases through the <<orm,ORM>> layer. You can implement `DataStore` in your project to provide integration, for example, with a non-relational database or an external system having REST interface.

In any CUBA application, there is always the main data store which contains system and security entities and where the users log in. When we mention a database in this manual, we always mean the main data store if not explicitly stated otherwise. The main data store must be a relational database connected through a JDBC data source. The main data source is located in JNDI and should have a name specified in the <<cuba.dataSourceJndiName,cuba.dataSourceJndiName>> application property, which is `jdbc/CubaDS` by default.

Additional data store names should be specified in the <<cuba.additionalStores,cuba.additionalStores>> application property. If the additional store is `RdbmsStore`, you should provide the following properties for it:

* `cuba.dataSourceJndiName_{store_name}` - JNDI name of the corresponding JDBC data source.
* `cuba.dbmsType_{store_name}` - type of the data store DBMS.
* `cuba.persistenceConfig_{store_name}` - location of the data store `persistence.xml` file.

If you implement the `DataStore` interface in your project, specify the name of the implementation bean in the `cuba.storeImpl_{store_name}` application property.

For example, if you need to work with two additional data stores: `db1` (a PostgreSQL database) and `mem1` (an in-memory storage implemented by some project bean), specify the following application properties in the `app.properties` file of your *core* module:

[source,properties]
----
cuba.additionalStores = db1, mem1
cuba.dataSourceJndiName_db1 = jdbc/db1
cuba.dbmsType_db1 = postgres
cuba.persistenceConfig_db1 = com/company/sample/db1-persistence.xml
cuba.storeImpl_mem1 = sample_InMemoryStore
----

The `cuba.additionalStores` and `cuba.persistenceConfig_db1` properties should also be specified in the property files of all used application blocks (`web-app.properties`, `portal-app.properties`, etc.).

[TIP]
====
CUBA Studio allows you to set up additional data stores on the *Project properties > Advanced* tab. It automatically creates all required application properties and JDBC data sources, as well as maintains additional `persistence.xml` files. After that, you can select a data store for an entity in the *Data store* field of the entity designer. You will also be able to select  a data store when using the *Generate model* wizard for creation of new entities mapped to an existing database schema.
====

[[cross_datastore_ref]]
References between entities from different data stores::
+
--
<<dataManager,DataManager>> can automatically maintain TO-ONE references between entities from different data stores, if they are properly defined. For example, consider the case when you have `Order` entity in the main data store and `Customer` entity in an additional data store, and you want to have a reference from `Order` to `Customer`. Then do the following:

* In the `Order` entity, define an attribute with the type of the `Customer` identifier. The attribute should be annotated with `@SystemLevel` to exclude it from various lists available to users, like attributes in <<gui_Filter,Filter>>:
+
[source,java]
----
@SystemLevel
@Column(name = "CUSTOMER_ID")
private Long customerId;
----

* In the `Order` entity, define a non-persistent reference to `Customer` and specify the `customerId` attribute as "related":
+
[source,java]
----
@Transient
@MetaProperty(related = "customerId")
private Customer customer;
----

* Include non-persistent `customer` attribute to appropriate <<views,views>>.

After that, when you load `Order` with a view including `customer` attribute, `DataManager` automatically loads related `Customer` from the additional data store. The loading of collections is optimized for performance: after loading a list of orders, the loading of references from the additional data store is done in batches. The size of the batch is defined by the <<cuba.crossDataStoreReferenceLoadingBatchSize,cuba.crossDataStoreReferenceLoadingBatchSize>> application property.

When you commit an entity graph which includes `Order` with `Customer`, `DataManager` saves the instances via corresponding `DataStore` implementations, and then saves the identifier of the customer in the order's `customerId` attribute.

Cross-datastore references are also supported by the <<gui_Filter,Filter>> component.

[TIP]
====
CUBA Studio automatically maintains the set of attributes for cross-datastore references when you select an entity from a different data store as an association.
====
--

[[persistence]]
==== The Persistence Interface

The `Persistence` interface is designed to be an entry point to the data storage functionality provided by the <<orm,ORM>> layer.

The interface has the following methods:

* `createTransaction()`, `getTransaction()` – obtain the interface for managing <<transactions,transactions>>. The methods can accept a <<data_store,data store>> name. If it is not provided, the main data store is assumed.

* `callInTransaction()`, `runInTransaction()` - execute an action in a new transaction with or without return value. The methods can accept a <<data_store,data store>> name. If it is not provided, the main data store is assumed.

* `isInTransaction()` – checks if there is an active transaction the moment.

* `getEntityManager()` – returns an <<entityManager,EntityManager>> instance bound to the current transaction. The method can accept a <<data_store,data store>> name. If it is not provided, the main data store is assumed.

* `isSoftDeletion()` – allows you to determine if the <<soft_deletion,soft deletion>> mode is active.

* `setSoftDeletion()` – enables or disables the soft deletion mode. Setting this property affects all newly created `EntityManager` instances. Soft deletion is enabled by default.

* `getDbTypeConverter()` – returns the <<dbTypeConverter,DbTypeConverter>> instance for the main database or for an additional data store.

* `getDataSource()` – returns the `javax.sql.DataSource` instance for the main database or for an additional data store.
+
[WARNING]
====
For all `javax.sql.Connection` objects obtained through `getDataSource().getConnection()` method the `close()` method should be called in the `finally` section after using the connection. Otherwise, the connection will not be returned to the pool. Over time, the pool will overflow and the application will not be able to execute database queries.
====

* `getTools()` – returns an instance of the `PersistenceTools` interface (see below).

[[persistenceTools]]
===== PersistenceTools

<<managed_beans,Managed bean>> containing helper methods related to data storage functionality. It can be obtained either by calling the `Persistence.getTools()` method or like any other bean, through injection or the `AppBeans` class.

The `PersistenceTools` bean has the following methods:

* `getDirtyFields()` – returns a collection of entity attribute names that have been changed since the last load of the instance from the DB. For new instances an empty collection is returned.

* `isLoaded()` – determines if the specified instance attribute was loaded from the DB. The attribute may not be loaded, if it was not present in the <<views,view>> specified when loading the instance. 
+
This method only works for instances in the <<entity_states,Managed>> state.

* `getReferenceId()` – returns an ID of the related entity without loading it from the DB.
+
Let us suppose that an `Order` instance was loaded in the <<persistence_context, persistent context>> and it is necessary to get the ID value of the `Customer` instance related to this `Order`. A call to the `order.getCustomer().getId()` method will execute the DB query to load the `Customer` instance, which in this case is unnecessary, because the value of the Customer ID is also located in the `Order` table as a foreign key. Whereas the execution of
+
[source, java]
----
include::{sourcesdir}/middleware/persistencetools_1.java[]
----
+
will not send any additional queries to the database.
+
This method works only for instances in the <<entity_states,Managed>> state.

The `PersistenceTools` bean can be <<bean_extension,overridden>> in your application to extend the set of default helper methods. An example of working with the extended interface is shown below: 

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_2.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_3.java[]
----

[[dbTypeConverter]]
===== DbTypeConverter

The interface containing methods for conversion between <<data_model,data model>> attribute values and parameters/results of JDBC queries. An object of this interface can be obtained through the <<persistence,Persistence.getDbTypeConverter()>> method. 

The `DbTypeConverter` interface has the following methods:

* `getJavaObject()` – converts the result of the JDBC query into a type suitable for assigning to entity attribute.

* `getSqlObject()` – converts the value of the entity attribute into a type suitable for assigning to the JDBC query parameter.

* `getSqlType()` – returns a `java.sql.Types` constant that corresponds to the passed entity attribute type.

[[orm]]
==== ORM Layer

Object-Relational Mapping is the technology for linking relational database tables to programming language objects. 

Benefits of using ORM::: 

* Enables working with a relational DBMS by means of Java objects manipulation.
* Simplifies programming by eliminating routine writing of SQL queries.
* Simplifies programming by letting you load and save entire object graphs with one command.
* Ensures easy porting of the application to different DBMS.
* Enables use of a concise object query language – <<jpql, JPQL>>.

Shortcomings:::

* Requires understanding of how ORM works.
* Makes direct optimization of SQL and use of the DBMS specifics difficult.

CUBA uses the ORM implementation based on the *EclipseLink* framework.

[[entityManager]]
===== EntityManager

`EntityManager` – main ORM interface for working with <<data_model,persistent entities>>.

[TIP]
====
See <<dm_vs_em>> for information on differences between EntityManager and <<dataManager,DataManager>>.
====

Reference to `EntityManager` may be obtained via the <<persistence,Persistence>> interface by calling its `getEntityManager()` method. The retrieved instance of `EntityManager` is bound to the current <<transactions,transaction>>, i.e. all calls to `getEntityManager()` as part of one transaction return one and the same instance of `EntityManager`. After the end of the transaction using the corresponding `EntityManager` instance is impossible.

An instance of `EntityManager` contains a _persistence context_ – a set of instances loaded from the database or newly created. The persistence context is a data cache within a transaction. `EntityManager` automatically flushes to the database all changes made in its persistence context on the transaction commit or when the `EntityManager.flush()` method is called.

The `EntityManager` interface used in CUBA applications mainly copies the standard link:http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html[javax.persistence.EntityManager] interface. Let us have a look at its main methods:

* `persist()` – adds a <<entity_states,new instance>> of the entity to the persistence context. When the transaction is committed a corresponding record is created in DB using SQL `INSERT`.

* `merge()` – copies the state of <<entity_states,detached instance>> to the persistence context the following way: an instance with the same identifier gets loaded from DB and the state of the passed Detached instance is copied into it and then the loaded Managed instance is returned. After that you should work with the returned Managed instance. The state of this entity will be stored in DB using SQL `UPDATE` on transaction commit.

* `remove()` – removes an object from the database, or, if <<soft_deletion,soft deletion>> mode is turned on, sets `deleteTs` and `deletedBy` attributes.
+
If the passed instance is in Detached state, `merge()` is performed first.

* `find()` – loads an entity instance by its identifier. 
+
--
When forming a request to the database the system considers the <<views,view>> which has been passed as a parameter to this method. As a result, the persistence context will contain a graph of objects with all view attributes loaded.
--

* `createQuery()` – creates a `Query` or `TypedQuery` object for executing a <<query,JPQL query>>.

* `createNativeQuery()` – creates a `Query` object to execute an <<nativeQuery,SQL query>>.

* `reload()` – reloads the entity instance with the provided <<views,view>>.

* `isSoftDeletion()` – checks if the `EntityManager` is in <<soft_deletion,soft deletion>> mode.

* `setSoftDeletion()` – sets <<soft_deletion,soft deletion>> mode for this `EntityManager`.

* `getConnection()` – returns a `java.sql.Connection`, which is used by this instance of `EntityManager`, and hence by the current transaction. Such connection does not need to be closed, it will be closed automatically when the transaction is complete.

* `getDelegate()` – returns `javax.persistence.EntityManager` provided by the ORM implementation. 

Example of using `EntityManager` in a <<services,service>>:

[source, java]
----
include::{sourcesdir}/middleware/entityManager_1.java[]
----

[[em_partial_entities]]
Partial entities::
+
--
By default, in EntityManager, a view affects only reference attributes, i.e. all local attributes are loaded.

You can force EntityManager to load _partial_ entities if you set the `loadPartialEntities` attribute of the view to true. If the loaded entity is <<entity_cache,cached>>, this view attribute is ignored and the entity will still be loaded with all local attributes.
--

[[entity_states]]
===== Entity States

New:: 
+
--
An instance which has just been created in memory: `Car car = new Car()`.

A new instance may be passed to `EntityManager.persist()` to be stored to the database, in which case it changes its state to Managed.
--

Managed:: 
+
--
An instance loaded from the database, or a new one passed to `EntityManager.persist()`. Belongs to a `EntityManager` instance, i.e. is contained in its persistence context.

Any changes of the instance in Managed state will be saved to the database when the transaction that the `EntityManager` belongs to is committed.
--

Detached:: 
+
--
An instance loaded from the database and detached from its persistence context (as a result of the transaction end or serialization).

The changes applied to a Detached instance will be saved to the database only if this instance becomes Managed by being passed to `EntityManager.merge()`.
--

[[lazy_loading]]
===== Lazy Loading

Lazy loading (loading on demand) enables delayed loading of linked entities, i.e. they get loaded when their properties are accessed for the first time.

Lazy loading generates more database queries than <<eager_fetching, eager fetching>>, but it is stretched in time.

* For example, in case of lazy loading of a list of N instances of entity A, each containing a link to an instance of entity B, will require N+1 requests to DB.

* In most cases, minimizing the number of requests to the database results in less response time and database load. The platform uses the mechanism of <<views,views>> to achieve this. Using view allows ORM to create only one request to the database with table joining for the above mentioned case.

Lazy loading works only for instances in <<entity_states,Managed>> state, i.e. within the transaction which loaded the instance.

[[query]]
===== Executing JPQL Queries

The `Query` interface is designed to execute <<jpql,JPQL>> queries. The reference to it may be obtained from the current `EntityManager` instance by calling `createQuery()` method. If the query is supposed to be used to load entities, we recommend calling `createQuery()` with the result type as a parameter. This will create a `TypedQuery` instance.

The methods of `Query` mainly correspond to the methods of the standard JPA link:http://docs.oracle.com/javaee/7/api/javax/persistence/Query.html[javax.persistence.Query] interface. Let us have a look at the differences.

* `setParameter()` – sets a value to a query parameter. If the value is an entity instance, implicitly converts the instance into its identifier. For example: 
+
[source, java]
----
include::{sourcesdir}/middleware/jpqlquery_1.java[]
----
+
Note that the entity is passed as a parameter while comparison in the query is done using identifier.
+
A variant of the method with `implicitConversions = false` does not perform such conversion.

* `setView()`, `addView()` – define a <<views,view>> which is used to load data.

* `getDelegate()` – returns an instance of `javax.persistence.Query`, provided by the ORM implementation.

If a <<views,view>> is set for a query, then by default the query has `FlushModeType.AUTO`, which affects the case when the current persistence context contains changed entity instances: these instances will be saved to the database prior to the query execution. In other words, ORM first synchronizes the state of entities in the persistence context and in the database, and only after that runs the query. It guarantees that the query results contain all relevant instances, even if they have not been saved to the database explicitly yet. The downside of this is that you will have an implicit flush, i.e. execution of SQL update statements for all currently changed entity instances, which may affect performance.

If a query is executed without a view, then by default the query has `FlushModeType.COMMIT`, which means that the query will not cause a flush,  and the query results will not respect the contents of the current persistence context.

In most cases ignoring the current persistence context is acceptable, and is a preferred behavior because it doesn't lead to extra SQL updates. But there is the following issue when using views: if there is a changed entity instance in the persistence context, and you execute a query with a view and `FlushModeType.COMMIT` loading the same instance, the changes will be lost. That is why we use `FlushModeType.AUTO` by default when running queries with views.

You can also set flush mode explicitly using the `setFlushMode()` method of the `Query` interface. It will override the default settings described above.

[[jpql_functions]]
====== JPQL Functions

The table below describes the JPQL functions supported and not supported by CUBA Platform.

[cols="1,1,5",width="100%"]
|===
|Function |Support |Query

//Aggregate functions with scalar expression

.2+|Aggregate Functions

|Supported

m|SELECT AVG(o.quantity) FROM app$Order o

|_Not supported: aggregate functions with scalar expression (EclipseLink feature)_

m|_SELECT AVG(o.quantity)/2.0 FROM app$Order o_

_SELECT AVG(o.quantity * o.price) FROM app$Order o_

//ALL, ANY, SOME

|ALL, ANY, SOME

|Supported

m|SELECT emp FROM app$Employee emp WHERE emp.salary > ALL (SELECT m.salary FROM app$Manager m WHERE m.department = emp.department)

//Arithmetic Functions (INDEX, SIZE, ABS, SQRT, MOD)

|Arithmetic Functions (INDEX, SIZE, ABS, SQRT, MOD)

|Supported

m|SELECT w.name FROM app$Course c JOIN c.studentWaitlist w WHERE c.name = 'Calculus' AND INDEX(w) = 0

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND SIZE(c.studentWaitlist) = 1

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND ABS(c.time) = 10

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND SQRT(c.time) = 10.5

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND MOD(c.time, c.time1) = 2

//CASE Expression

.2+|CASE Expressions in UPDATE query

|Supported

m|SELECT e.name, f.name, CONCAT(CASE WHEN f.annualMiles > 50000 THEN 'Platinum ' WHEN f.annualMiles > 25000 THEN 'Gold ' ELSE '' END, 'Frequent Flyer')
  FROM app$Employee e JOIN e.frequentFlierPlan f

|_Not supported: CASE in UPDATE query_

m|_UPDATE app$Employee e SET e.salary = CASE e.rating WHEN 1 THEN e.salary * 1.1 WHEN 2 THEN e.salary * 1.05 ELSE e.salary * 1.01 END_

//Date Functions (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP)

|Date Functions (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP)

|Supported

m|SELECT e FROM app$Order e WHERE e.date = CURRENT_DATE

//EclipseLink Functions (CAST, REGEXP, EXTRACT)

.2+|EclipseLink Functions (CAST, REGEXP, EXTRACT)

|Supported

m|SELECT EXTRACT(YEAR FROM e.createTs) FROM app$MyEntity e WHERE EXTRACT(YEAR FROM e.createTs) > 2012

  SELECT e FROM app$MyEntity e WHERE e.name REGEXP '.*'

  SELECT CAST(e.number text) FROM app$MyEntity e WHERE e.path LIKE CAST(:ds$myEntityDs.id text)

|_Not supported: CAST in GROUP BY clause_

m|_SELECT e FROM app$Order e WHERE e.amount > 100 GROUP BY CAST(e.orderDate date)_

//Entity Type Expression

.2+|Entity Type Expression

|Supported: entity type passed as a parameter

m|SELECT e FROM app$Employee e WHERE TYPE(e) IN (:empType1, :empType2)

|_Not supported: direct link to an entity type_

m|_SELECT e FROM app$Employee e WHERE TYPE(e) IN (app$Exempt, app$Contractor)_

//Function Invocation

.2+|Function Invocation

|Supported: function result in comparison clauses

m|SELECT u FROM sec$User u WHERE function('DAYOFMONTH', u.createTs) = 1

|_Not supported: function result as is_

m|_SELECT u FROM sec$User u WHERE function('hasRoles', u.createdBy, u.login)_

//IN

|IN

|Supported

m|SELECT e FROM Employee e, IN(e.projects) p WHERE p.budget > 1000000

//IS EMPTY collection

|IS EMPTY collection

|Supported

m|SELECT e FROM Employee e WHERE e.projects IS EMPTY

//KEY/VALUE

|KEY/VALUE

|_Not supported_

m|_SELECT v.location.street, KEY(i).title, VALUE(i) FROM app$VideoStore v JOIN v.videoInventory i WHERE v.location.zipcode = '94301' AND VALUE(i) > 0_

//Literals
.2+|Literals

|Supported

m|SELECT e FROM app$Employee e WHERE e.name = 'Bob'

  SELECT e FROM app$Employee e WHERE e.id = 1234

  SELECT e FROM app$Employee e WHERE e.id = 1234L

  SELECT s FROM app$Stat s WHERE s.ratio > 3.14F

  SELECT s FROM app$Stat s WHERE s.ratio > 3.14e32D

  SELECT e FROM app$Employee e WHERE e.active = TRUE

|_Not supported: date and time literals_

m|_SELECT e FROM app$Employee e WHERE e.startDate = {d'2012-01-03'}_

  _SELECT e FROM app$Employee e WHERE e.startTime = {t'09:00:00'}_

  _SELECT e FROM app$Employee e WHERE e.version = {ts'2012-01-03 09:00:00.000000001'}_

//MEMBER OF

.2+|MEMBER OF

|Supported: fields or query results

m|SELECT d FROM app$Department d WHERE (select e from app$Employee e where e.id = :eParam) MEMBER OF e.employees

|_Not supported: literals_

m|_SELECT e FROM app$Employee e WHERE 'write code' MEMBER OF e.codes_

//NEW in SELECT

|NEW in SELECT

|_Not supported_

m|_SELECT NEW com.acme.example.CustomerDetails(c.id, c.status, o.count) FROM app$Customer c JOIN c.orders o WHERE o.count > 100_

//NULLIF/COALESCE

|NULLIF/COALESCE

|Supported

m|SELECT NULLIF(emp.salary, 10) FROM app$Employee emp

  SELECT COALESCE(emp.salary, emp.salaryOld, 10) FROM app$Employee emp

//NULLS FIRST, NULLS LAST in order by

|NULLS FIRST, NULLS LAST in order by

|Supported

m|SELECT h FROM sec$GroupHierarchy h ORDER BY h.level DESC NULLS FIRST

//String Functions (CONCAT, SUBSTRING, TRIM, LOWER, UPPER, LENGTH, LOCATE)

.2+|String Functions (CONCAT, SUBSTRING, TRIM, LOWER, UPPER, LENGTH, LOCATE)

|Supported

m|SELECT x FROM app$Magazine x WHERE CONCAT(x.title, 's') = 'JDJs'

  SELECT x FROM app$Magazine x WHERE SUBSTRING(x.title, 1, 1) = 'J'

  SELECT x FROM app$Magazine x WHERE LOWER(x.title) = 'd'

  SELECT x FROM app$Magazine x WHERE UPPER(x.title) = 'D'

  SELECT x FROM app$Magazine x WHERE LENGTH(x.title) = 10

  SELECT x FROM app$Magazine x WHERE LOCATE('A', x.title, 4) = 6

  SELECT x FROM app$Magazine x WHERE TRIM(TRAILING FROM x.title) = 'D'

|_Not supported: TRIM with trim char_

m|_SELECT x FROM app$Magazine x WHERE TRIM(TRAILING 'J' FROM x.title) = 'D'_

//Subquery
.2+|Subquery

|Supported

m|SELECT goodCustomer FROM app$Customer goodCustomer WHERE goodCustomer.balanceOwed < (SELECT AVG(c.balanceOwed) FROM app$Customer c)

|_Not supported: path expression instead of entity name in subquery's FROM_

m|_SELECT c FROM app$Customer c WHERE (SELECT AVG(o.price) FROM c.orders o) > 100_

//TREAT
.2+|TREAT

|Supported

m|SELECT e FROM app$Employee e JOIN TREAT(e.projects AS app$LargeProject) p WHERE p.budget > 1000000

|_Not supported: TREAT in WHERE clauses_

m|_SELECT e FROM Employee e JOIN e.projects p WHERE TREAT(p as LargeProject).budget > 1000000_

|===


[[query_case_insensitive]]
====== Case-Insensitive Substring Search

You can use the `(?i)` prefix in the value of the query parameters to conveniently specify conditions for case insensitive search by any part of the string. For example, look at the query:

[source, jpql]
----
select c from sales$Customer c where c.name like :name
----

If you pass the string `(?i)%doe%` as a value of the `name` parameter, the search will return `John Doe`, if such record exists in the database, even though the case of symbols is different. This will happen because ORM will run the SQL query with the condition `lower(C.NAME) like ?`.

It should be kept in mind that such search will not use index on the name field, even if such exists in the database.

[[jpql_macro]]
====== Macros in JPQL

JPQL query text can include macros, which are processed before the query is executed. They are converted into the executable JPQL and can additionally modify the set of query parameters.

The macros solve the following problems:

* Provide a workaround for the limitation of JPQL which makes it impossible to express the condition of dependency of a given field on current time (i.e. expressions like "current_date -1" do not work).

* Enable comparing `Timestamp` type fields (the date/time fields) with a date.

Let us consider them in more detail:

@between:: 
+
--
Has the format `++@between(field_name, moment1, moment2, time_unit)++` or `++@between(field_name, moment1, moment2, time_unit, user_timezone)++`, where

* `++field_name++` is the name of the compared attribute. 

* `moment1`, `moment2` – start and end points of the time interval where the value of `++field_name++` should fall into. Each of the points should be defined by an expression containing `now` variable with an addition or subtraction of an integer number.

* `++time_unit++` – defines the unit for time interval added to or subtracted from `now` in the time point expressions and time points rounding precision. May be one of the following: `year`, `month`, `day`, `hour`, `minute`, `second`.

* `++user_timezone++` - an optional argument that defines the current user's <<timeZone, time zone>> to be considered in the query.

The macro gets converted to the following expression in JPQL: `++field_name >= :moment1 and field_name < :moment2++`

Example 1. Customer was created today: 

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now, now+1, day)
----

Example 2. Customer was created within the last 10 minutes:

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now-10, now, minute)
----

Example 3. Documents dated within the last 5 days, considering current user time zone:

[source, jpql]
----
select d from sales$Doc where @between(d.createTs, now-5, now, day, user_timezone)
----
--

@today:: 
+
--
Has the format `++@today(field_name)++` or `++@today(field_name, user_timezone)++` and helps to define a condition checking that the attribute value falls into the current date. Essentially, this is a special case of the `@between` macro.

Example. Customer was created today: 

[source, jpql]
----
select d from sales$Doc where @today(d.createTs)
----
--

@dateEquals:: 
+
--
Has the format `++@dateEquals(field_name, parameter)++` or `++@dateEquals(field_name, parameter, user_timezone)++` and allows you to define a condition checking that `++field_name++` value (in `Timestamp` format) falls into the date passed as `parameter`.

Example: 

[source, jpql]
----
select d from sales$Doc where @dateEquals(d.createTs, :param)
----
--

@dateBefore:: 
+
--
Has the format `++@dateBefore(field_name, parameter)++` or `++@dateBefore(field_name, parameter, user_timezone)++` and allows you to define a condition checking that `++field_name++` value (in `Timestamp` format) is smaller than the date passed as `parameter`.

Example: 

[source, jpql]
----
select d from sales$Doc where @dateBefore(d.createTs, :param, user_timezone)
----
--

@dateAfter:: 
+
--
Has the format `++@dateAfter(field_name, parameter)++` or `++@dateAfter(field_name, parameter, user_timezone)++` and allows you to define a condition that the date of the `++field_name++` value (in `Timestamp` format) is more or equal to the date passed as `parameter`.

Example: 

[source, jpql]
----
select d from sales$Doc where @dateAfter(d.createTs, :param)
----
--

@enum:: 
+
--
Allows you to use a fully qualified enum constant name instead of its database identifier. This simplifies searching for enum usages throughout the application code.

Example: 

[source, jpql]
----
select r from sec$Role where r.type = @enum(com.haulmont.cuba.security.entity.RoleType.SUPER) order by r.name
----
--

[[nativeQuery]]
===== Running SQL Queries

ORM enables execution of SQL queries returning either the lists of individual fields or entity instances. To do this, create a `Query` or `TypedQuery` object by calling one of the `EntityManager.createNativeQuery()` methods.

If individual columns are selected, the resulting list will include the rows as `Object[]`. For example:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_1.java[]
----

If a single column or aggregate function is selected, the result list will contain these values directly:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_3.java[]
----

If the resulting entity class is passed to `EntityManager.createNativeQuery()` along with the query text, `TypedQuery` is returned, and ORM attempts to map the query results to entity attributes. For example:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_2.java[]
----

Keep in mind when using SQL, that the columns corresponding to entity attributes of `UUID` type are returned as `UUID` or as `String` depending on the DBMS in use:

* *HSQLDB* – `String`
* *PostgreSQL* – `UUID`
* *Microsoft SQL Server* – `String`
* *Oracle* – `String`
* *MySQL* – `String`

Parameters of this type should also be passed either as `UUID` or using their string representation, depending on the DBMS. To ensure that your code does not depend on the DBMS specifics, use `DbTypeConverter`. It provides methods to convert data between Java objects and JDBC parameters and results.

Native queries support positional and named parameters. Positional parameters are marked in the query text with ? followed by the parameter number starting from 1. Named parameters are marked with the number sign (#). See the examples above.

Behavior of SQL queries returning entities and modifying queries (`update`, `delete`) in relation to the current persistence context is similar to that of <<query,JPQL queries>> described above.

[[entity_listeners]]
===== Entity Listeners

_Entity Listeners_ are designed to react to the entity instances lifecycle events on <<app_tiers,Middleware>>.

A listener is a class implementing one or several interfaces from the `com.haulmont.cuba.core.listener` package. The listener will react to events corresponding to the implemented interfaces.

BeforeDetachEntityListener::
+
--
`onBeforeDetach()` method is called before the object is detached from <<entityManager,EntityManager>> on transaction commit. 

This listener can be used for populating non-persistent entity attributes before sending it to the client tier.
--

BeforeAttachEntityListener::
+
--
`onBeforeAttach()` method is called before the object is attached to the persistence context as a result of `EntityManager.merge()` operation.

This listener can be used, for example, to populate persistent entity attributes before saving it to the database.
--

BeforeInsertEntityListener::
`onBeforeInsert()` method is called before a record is inserted into the database. All kinds of operations can be performed with the current <<entityManager,EntityManager>> available within this method.

AfterInsertEntityListener::
`onAfterInsert()` is called after a record is inserted into database, but before transaction commit. This method does not allow modifications of the current persistence context, however, database modifications can be done using <<queryRunner,QueryRunner>>.

BeforeUpdateEntityListener::
`onBeforeUpdate()` method is called before a record is updated in the database. All kinds of operations can be performed with the current <<entityManager,EntityManager>> available within this method. 

AfterUpdateEntityListener::
`onAfterUpdate()` method is called after a record was updated in the database, but before transaction commit. This method does not allow modifications of the current persistence context, however, database modifications can be done using <<queryRunner,QueryRunner>>.

BeforeDeleteEntityListener::
`onBeforeDelete()` method is called before a record is deleted from the database (in the case of <<soft_deletion,soft deletion>> – before updating a record). All kinds of operations can be performed with the current <<entityManager,EntityManager>> available within this method.

AfterDeleteEntityListener::
`onAfterDelete()` method is called after a record is deleted from the database (in the case of <<soft_deletion,soft deletion>> – before updating a record), but before transaction commit. This method does not allow modifications of the current persistence context, however, database modifications can be done using <<queryRunner,QueryRunner>>.

An entity listener should be a <<managed_beans, managed bean>>, so you can use injection. For example:

[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_1.java[]
----

An entity listener can be specified for an entity in two ways:

* Statically – the bean names of listeners are listed in <<listeners_annotation,@Listeners>> annotation on the entity class.
+
[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_2.java[]
----

* Dynamically – the bean name of the listener is passed to the `addListener()` method of the `EntityListenerManager` bean. See an example in this section: <<app_start_recipe>>.

Only one listener instance of a certain type is created for all instances of a particular entity class, therefore listener must not have a state.

If several listeners of the same type (for example from annotations of entity class and its parents and also added dynamically) were declared for an entity, they will be invoked in the following order:

. For each ancestor, starting from the most distant one, dynamically added listeners are invoked first, followed by statically assigned listeners.
. Once parent classes are processed, dynamically added listeners for the given class are invoked first, followed by statically assigned.

[TIP]
====
If you need to do some calculations and update attributes of _multiple_ entity instances at once on transaction commit, consider using a <<transaction_listeners,transaction listener>>.
====

[[transactions]]
==== Transaction Management

This section covers various aspects of transaction management in CUBA applications.

[[transactions_prog]]
===== Programmatic Transaction Management

Programmatic transaction management is done using the `com.haulmont.cuba.core.Transaction` interface. A reference to it can be obtained via the `createTransaction()` or `getTransaction()` methods of the <<persistence,Persistence>> infrastructure interface.

The `createTransaction()` method creates a new transaction and returns the `Transaction` interface. Subsequent calls of `commit()`, `commitRetaining()`, `end()` methods of this interface control the created transaction. If at the moment of creation there was another transaction, it will be suspended and resumed after the completion of the newly created one.

The `getTransaction()` method either creates a new transaction or attaches to an existing one. If at the moment of the call there is an active transaction, then the method completes successfully, but subsequent calls of `commit()`, `commitRetaining()`, `end()` have no influence on the existing transaction. However calling `end()` without a prior call to `commit()` will mark current transaction as `RollbackOnly`.

Examples of programmatic transaction management:

[source, java]
----
include::{sourcesdir}/middleware/transactions_1.java[]
----

`Transaction` interface has also the `execute()` method accepting an action class or a lambda expression. The action will be performed in the transaction. This enables organizing transaction management in functional style, for example:

[source, java]
----
include::{sourcesdir}/middleware/transactions_2.java[]
----

Keep in mind that `execute()` method of a given instance of `Transaction` may be called only once because the transaction ends after the action code is executed.

[[transactions_decl]]
===== Declarative Transaction Management

Any method of the Middleware <<managed_beans,managed bean>> may be annotated with `@org.springframework.transaction.annotation.Transactional`, which will automatically create a transaction when the method is called. Such method does not require invoking `Persistence.createTransaction()`, you can immediately get `EntityManager` and work with it.

`@Transactional` annotation supports a number of parameters, including:

* `propagation` - transaction creation mode. The `REQUIRED` value corresponds to `getTransaction()`, the `REQUIRES_NEW` value – to `createTransaction()`. The default value is `REQUIRED`.
+
[source, java]
----
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void doSomething() {
}
----

* `value` - <<data_store,data store>> name. If omitted, the main data store is assumed. For example:
+
[source, java]
----
@Transactional("db1")
public void doSomething() {
}
----

Declarative transaction management allows you to reduce the amount of http://en.wikipedia.org/wiki/Boilerplate_code[boilerplate code], but it has the following drawback: transactions are committed outside of the application code, which often complicates debugging because it conceals the moment when changes are sent to the database and the entities become <<entity_states,Detached>>. Additionally, keep in mind that declarative markup will only work if the method is called by the container, i.e. calling a transaction method from another method of the same object will not start a transaction.

With this in mind, we recommend using declarative transaction management only for simple cases like a <<services,service>> method reading a certain object and returning it to the client. 

[[transactions_interaction]]
===== Examples of Transactions Interaction

Rollback of a Nested Transaction::
+
--
If a nested transaction was created via `getTransaction()` and rolled back, then commit of the enclosing transaction will be impossible. For example: 

[source, java]
----
include::{sourcesdir}/middleware/transactions_3.java[]
----

If the transaction in `methodB()` is created with `createTransaction()` instead, then rolling it back will have no influence on the enclosing transaction in `methodA()`.
--

Reading and Modifying Data in a Nested Transaction::
+
--
Let us first have a look at a dependent nested transaction created using `getTransaction()`: 

[source, java]
----
include::{sourcesdir}/middleware/transactions_4.java[]
----

Now, let us have a look at the same example with an independent nested transaction created with `createTransaction()`:

[source, java]
----
include::{sourcesdir}/middleware/transactions_5.java[]
----

In the last example, the exception at point (8) will only occur if the entity supports optimistic locking, i.e. if it implements `Versioned` interface.
--

[[transaction_params]]
===== Transaction Parameters

[[transaction_timeout]]
Transaction Timeout::
+
--
You can set a timeout in seconds for created transaction. When the timeout is exceeded, the transaction is interrupted and rolled back. Transaction timeout effectively limits the maximum duration of a database request.

When transactions are managed programmatically, the timeout is specified by passing `TransactionParams` object to the `Persistence.createTransaction()` method. For example:

[source, java]
----
include::{sourcesdir}/middleware/transactions_6.java[]
----

In case of declarative transactions management, use the `timeout` parameter of the `@Transactional` annotation:

[source, java]
----
include::{sourcesdir}/middleware/transactions_7.java[]
----

The default timeout can be defined using the <<cuba.defaultQueryTimeoutSec,cuba.defaultQueryTimeoutSec>> application property.
--

[[transaction_read_only]]
Read-only Transactions::
+
--
A transaction can be marked as read-only if it is intended only for reading data from the database. For example, all `load` methods of <<dataManager,DataManager>> use read-only transactions by default. Read-only transactions yield better performance because the platform does not execute code that handles possible entity modifications. `BeforeCommit` <<transaction_listeners,transaction listeners>> are not invoked as well.

[WARNING]
====
If the persistence context of a read-only transaction contains modified entities, `IllegalStateException` will be thrown on attempt to commit the transaction. It means that you should mark a transaction as read-only only when you are sure that it doesn't modify any entity.
====

When transactions are managed programmatically, the read-only sign is specified by passing `TransactionParams` object to the `Persistence.createTransaction()` method. For example:

[source, java]
----
include::{sourcesdir}/middleware/transactions_8.java[]
----

In case of declarative transactions management, use the `readOnly` parameter of the `@Transactional` annotation:

[source, java]
----
include::{sourcesdir}/middleware/transactions_9.java[]
----
--

[[transaction_listeners]]
===== Transaction Listeners

Transaction listeners are designed to react on transaction lifecycle events. Unlike <<entity_listeners,entity listeners>>, they are not tied to an entity type and invoked for each transaction.

A listener is a <<managed_beans,managed bean>> implementing one or both `BeforeCommitTransactionListener` and `AfterCompleteTransactionListener` interfaces.

BeforeCommitTransactionListener::
+
--
`beforeCommit()` method is called before transaction commit after all <<entity_listeners,entity listeners>> if the transaction is not read-only. The method accepts a current <<entityManager,EntityManager>> and a collection of entities in the current persistence context.

The listener can be used to enforce complex business rules involving multiple entities. In the following example, the `amount` attribute of the `Order` entity must be calculated based on `discount` value located in the order, and `price` and `quantity` of `OrderLine` entities constituted the order.

[source,java]
----
include::{sourcesdir}/middleware/tx_listener_1.java[]
----
--

AfterCompleteTransactionListener::
+
--
`afterComplete()` method is called after transaction is completed. The method accepts a parameter indicating whether the transaction was successfully committed and a collection of detached entities contained in the persistence context of the completed transaction.

Usage example:

[source,java]
----
include::{sourcesdir}/middleware/tx_listener_2.java[]
----
--

[[entity_cache]]
==== Entity and Query Cache

Entity Cache::
+
--
Entity cache is provided by EclipseLink <<orm,ORM>> framework. It stores recently read or written entity instance in memory, which minimizes database access and improves the application performance.

Entity cache is used only when you retrieve entities by ID, so queries by other attributes still run on the database. However, these queries can be simpler and faster if related entities are in cache. For example, if you query for Orders together with related Customers and do not use cache, the SQL query will contain a JOIN for customers table. If Customer entities are cached, the SQL query will select only orders, and related customers will be retrieved from the cache.

In order to turn on entity cache, set the following properties in the <<app_properties_files,app.properties>> file of your *core* module:

* `eclipselink.cache.shared.sales$Customer = true` - turns on caching of `sales$Customer` entity.

* `eclipselink.cache.size.sales$Customer = 500` - sets cache size for `sales$Customer` to 500 instances. Default size is 100.

The fact of whether an entity is cached affects the <<views,fetch mode>> chosen by the platform for loading entity graphs. If a reference attribute is a cacheable entity, the fetch mode is always `UNDEFINED`, which allows ORM to retrieve the reference from the cache instead of executing queries with JOINs or separate batch queries.

The platform provides entity cache coordination in <<cluster_mw_server,middleware cluster>>. When a cached entity is updated or deleted on one cluster node, the same cached instance on other nodes (if any) will be invalidated, so the next operation with this instance will read a fresh state from the database.
--

Query Cache::
+
--
Query cache stores identifiers of entity instances returned by JPQL queries, so it naturally complements the entity cache.

For example, if entity cache is enabled for an entity (say, `sales$Customer`), and you execute the query `select c from sales$Customer c where c.grade = :grade` for the first time, the following happens:

* ORM runs the query on the database.

* Loaded `Customer` instances are placed to the entity cache.

* A mapping of the query text and parameters to the list of identifiers of the returned instances is placed to the query cache.

When you execute the same query with the same parameters the second time, the platform finds the query in the query cache and loads entity instances from the entity cache by identifiers. No database operations are needed.

Queries are not cached by default. You can specify that a query should be cached on different layers of the application:

* Using `setCacheable()` method of the <<query,Query>> interface when working with <<entityManager,EntityManager>>.

* Using `setCacheable()` method of the `LoadContext.Query` interface when working with <<dataManager,DataManager>>.

* Using `setCacheable()` method of the `CollectionDatasource` interface or `cacheable` XML attribute when working with <<datasources,datasources>>.

[WARNING]
====
Use cacheable queries only if entity cache is enabled for the returned entity. Otherwise on every query entity instances will be fetched from the database by their identifiers one by one.
====

Query cache is invalidated automatically when <<orm,ORM>> performs creation, update or deletion of instances of the corresponding entities. The invalidation works across the <<cluster_mw,middleware cluster>>.

The `app-core.cuba:type=QueryCacheSupport` JMX-bean can be used to monitor the cache state and to evict cached queries manually. For example, if you have modified an instance of the `sales$Customer` entity directly in the database, you should evict all cached queries for this entity using the `evict()` operation with `sales$Customer` argument.

The following application properties affect the query cache:

* <<cuba.queryCache.enabled,cuba.queryCache.enabled>>

* <<cuba.queryCache.maxSize,cuba.queryCache.maxSize>>
--

[[system_authentication]]
==== System Authentication

When executing user requests, the Middleware program code always has access to the information on the current user via the <<userSessionSource,UserSessionSource>> interface. This is possible because the corresponding <<securityContext,SecurityContext>> object is automatically set for the current thread when a request is received from the client tier.

However, there are situations when the current thread is not associated with any system user, for example, when calling a bean's method from the <<scheduled_tasks_spring,scheduler>>, or via the JMX interface. In case the bean modifies entities in the database, it will require information on who is making changes, i.e., authentication.

This kind of authentication is called "system authentication" as it requires no user participation – the application middle layer simply creates or uses an existing user session and sets the corresponding `SecurityContext` object for the current thread.

The following methods can be used to provide the system authentication for a code block:

* Make use of the `com.haulmont.cuba.security.app.Authentication` bean:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_1.java[]
----

* Add the `@Authenticated` annotation to the bean method:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_2.java[]
----

The second case uses the `Authentication` bean implicitly, via the `AuthenticationInterceptor` object, which intercepts calls of all bean methods with the `@Authenticated` annotation.

In the examples above, the user session will be created on behalf of the user, whose login is specified in the <<cuba.jmxUserLogin,cuba.jmxUserLogin>> application property. If authentication on behalf of another user is required, pass the login of the desired user to the `begin()` method of the first variant.

[WARNING]
====
If current thread has an active user session assigned at the time of `Authentication.begin()` execution, it will not be replaced. Therefore the code will be executed with the existing session and the subsequent call to the `end()` method will not clear the thread.

For example, if a bean is in the same JVM as the Web Client block, to which the user is currently connected, the call of the JMX bean method from the Web Client built-in <<jmx_console,JMX console>> will be executed on behalf of the currently logged in user, regardless of the system authentication.
====

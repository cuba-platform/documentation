[[common_components]]
=== Общие компоненты

В данной главе рассмотрены компоненты платформы, общие для всех <<app_tiers,уровней>> приложения.

[[data_model]]
==== Модель данных

Предметная область моделируется в приложении с помощью взаимосвязанных классов Java, называемых классами сущностей или просто сущностями. 

Сущности подразделяются на две категории:

* Персистентные – экземпляры таких сущностей хранятся в таблицах базы данных с помощью <<orm,ORM>>.

* Неперсистентные – экземпляры существуют только в оперативной памяти, или сохраняются где-то с помощью иных механизмов.

Сущности характеризуются своими атрибутами. Атрибут соответствует полю класса и паре методов доступа (get / set) к полю. Чтобы атрибут был неизменяемым (read only), достаточно не создавать метод set. 

Персистентные сущности могут включать в себя атрибуты, не хранящиеся в БД. В случае неперсистентного атрибута можно не создавать поле класса, ограничившись методами доступа.

Класс сущности должен удовлетворять следующим требованиям: 

* Наследоваться от одного из базовых классов, предоставляемых платформой (см. <<base_entity_classes,ниже>>).

* Мметь набор полей и методов доступа, соответствующих атрибутам сущностей.

* Класс и его поля (или методы доступа при отсутствии для атрибута соответствующего поля) должны быть определенным образом <<entity_annotations,аннотированы>> для предоставления нужной информации фреймворкам <<jpa,JPA>> (в случае персистентной сущности) и <<metadata_framework,метаданных>>.

Поддерживаются следующие типы атрибутов сущностей:

* `java.lang.String`

* `java.lang.Boolean`

* `java.lang.Integer`

* `java.lang.Long`

* `java.lang.Double`

* `java.math.BigDecimal`

* `java.util.Date`

* `java.sql.Date`

* `java.sql.Time`

* `java.util.UUID`

* `byte[]`

* `enum`

* Cущность

Базовые классы сущностей (см. ниже) переопределяют `equals()` и `hashCode()` таким образом, что экземпляры сущностей сравниваются по их идентификаторам. То есть экземпляры одного класса считаются равными, если равны их идентификаторы.

[[base_entity_classes]]
===== Базовые классы сущностей

Рассмотрим базовые классы и интерфейсы сущностей более подробно.

[[entity_base_classes]]
image::EntityClasses.png[align="center"]

* `Instance` – декларирует базовые методы работы с объектами предметной области:

** Получение ссылки на мета-класс объекта.

** Генерация имени экземпляра.

** Чтение/установка значений атрибутов по имени.

** Добавление слушателей, получающих уведомления об изменениях атрибутов.

* `Entity` – дополняет `Instance` понятием идентификатора сущности, причем `Entity` не определяет тип идентификатора, оставляя эту возможность наследникам.

* `AbstractInstance` – реализует логику работы со слушателями изменения атрибутов.
+
[WARNING]
====
`AbstractInstance` хранит слушателей в коллекции `WeakReference`, т.е. при отсутствии внешних ссылок на добавленного слушателя, он будет немедленно уничтожен сборщиком мусора. Как правило, слушателями изменения атрибутов являются <<gui_vcl,визуальные компоненты>> и <<datasources,источники данных>> UI, на которые всегда имеются ссылки из других объектов, поэтому проблема исчезновения слушателей не возникает. Однако если слушатель создается прикладным кодом и на него никто не ссылается естественным образом, необходимо кроме добавления в `Instance` сохранить его в некотором поле объекта.
====

* `BaseGenericIdEntity` - базовый класс персистентных и неперсистентных сущностей. Реализует `Entity`, но не специфицирует тип идентификатора (то есть первичного ключа) сущности.

* `EmbeddableEntity` - базовый класс персистентных встраиваемых сущностей.

Ниже рассмотрены базовые классы, от которых рекомендуется наследовать сущности. Неперсистентные сущности наследуются от тех же классов, что и персистентные. Фреймворк определяет, является ли сущность персистентной или нет по файлу, в котором зарегистрирован класс: <<persistence.xml>> или <<metadata.xml>>.

StandardEntity::
Наследуйте от `StandardEntity`, если необходим стандартный набор свойств сущности: первичный ключ типа UUID, экземпляры должны содержать информацию о том, кто и когда создал и изменил их, необходима оптимистичная блокировка и мягкое удаление.
+
--
image::EntityClasses_Standard.png[align="center"]

* `HasUuid` – интерфейс сущностей имеющих глобальные уникальные идентификаторы

* `Versioned` – интерфейс сущностей, поддерживающих <<optimistic_locking,оптимистичную блокировку>>

* `Creatable` – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда ее создал

* `Updatable` – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда изменял экземпляр в последний раз

* `SoftDelete` – интерфейс сущностей, поддерживающих <<soft_deletion,мягкое удаление>>
--

BaseUuidEntity::
Наследуйте от `BaseUuidEntity` если необходима сущность с идентификатором типа UUID, но не нужны все остальные свойства `StandardEntity`. Интерфейсы `Creatable`, `Versioned` и др. можно выборочно реализовать в конкретном классе сущности.
+
image::EntityClasses_Uuid.png[align="center"]

BaseLongIdEntity::
Наследуйте от `BaseLongIdEntity` или `BaseIntegerIdEntity` если необходима сущность с идентификатором типа `Long` или `Integer`. Интерфейсы `Creatable`, `Versioned` и др. можно выборочно реализовать в конкретном классе сущности. Рекомендуется реализовать `HasUuid`, так как это позволяет платформе в некоторых случаях работать с сущностью более оптимально, а кроме того, сущность получает уникальный идентификатор в распределенном окружении.
+
image::EntityClasses_Long.png[align="center"]

BaseStringIdEntity::
Наследуйте от `BaseStringIdEntity` если необходима сущность с идентификатором типа `String`. Интерфейсы `Creatable`, `Versioned` и др. можно выборочно реализовать в конкретном классе сущности. Рекомендуется реализовать `HasUuid`, так как это позволяет платформе в некоторых случаях работать с сущностью более оптимально, а кроме того, сущность получает уникальный идентификатор в распределенном окружении. В конкретном классе сущности, унаследованной от `BaseStringIdEntity`, необходимо задать атрибут-идентификатор типа `String` и добавить ему <<jpa,JPA>>-аннотацию `@Id`.
+
image::EntityClasses_String.png[align="center"]

BaseIdentityIdEntity::
Наследуйте от `BaseIdentityIdEntity` если необходимо отобразить сущность на таблицу с первичным ключом типа IDENTITY. Интерфейсы `Creatable`, `Versioned` и др. можно выборочно реализовать в конкретном классе сущности. Рекомендуется реализовать `HasUuid`, так как это позволяет платформе в некоторых случаях работать с сущностью более оптимально, а кроме того, сущность получает уникальный идентификатор в распределенном окружении. Атрибут `id` сущности (т.е. методы getId/setId) будут иметь тип `IdProxy`, который предназначен для использования вместо реального идентификатора, пока он не сгенерирован базой данных на вставке записи.
+
image::EntityClasses_Identity.png[align="center"]

BaseGenericIdEntity::
Наследуйте напрямую от `BaseGenericIdEntity` если необходимо отобразить сущность на таблицу с композитным первичным ключом. В этом случае в классе сущности необходимо создать поле встраиваемого типа, представляющего композитный ключ, и аннотировать его <<jpa,JPA>>-аннотацией `@EmbeddedId`.

[[entity_annotations]]
===== Аннотации сущностей

В данном разделе описаны все поддерживаемые платформой аннотации классов и атрибутов сущностей. 

Аннотации пакета `javax.persistence` обеспечивают работу <<jpa,JPA>>, аннотации пакетов `++com.haulmont.*++` предназначены для управления <<metadata_framework,метаданными>> и другими механизмами платформы. 

Если для аннотации указано только простое имя класса, подразумевается что это класс платформы, расположенный в одном из пакетов `++com.haulmont.*++`

[[entity_class_annotations]]
====== Аннотации класса

[[embeddable_annotation]]
@Embeddable::
+
--
See http://docs.oracle.com/javaee/7/api/javax/persistence/Embeddable.html[javax.persistence.Embeddable].

Определяет встраиваемую сущность, экземпляры которой хранятся вместе с владеющей сущностью в той же таблице.

Для задания имени сущности требуется применение аннотации <<metaclass_annotation,@MetaClass>>.
--

[[enableRestore_annotation]]
@EnableRestore::
Указывает, что экземпляры данной сущности доступны для восстановления после <<soft_deletion,мягкого удаления>> в специальном экране `core$Entity.restore`, доступном через пункт *Administration > Data Recovery* главного меню.

[[entity_annotation]]
@Entity::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Entity.html[javax.persistence.Entity].

Объявляет класс сущностью модели данных.

Параметры:

* `name` - имя сущности, обязательно должно начинаться с префикса, отделенного знаком `$`. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.

Пример:

[source, java]
----
@Entity(name = "sales$Customer")
----
--

[[extends_annotation]]
@Extends::
Указывает, что данная сущность является расширением и должна повсеместно использоваться вместо базовой. См. <<extension,Расширение функциональности>>.

[[discriminatorColumn_annotation]]
@DiscriminatorColumn::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/DiscriminatorColumn.html[javax.persistence.DiscriminatorColumn].

Используется для определения колонки БД, отвечающей за различение типов сущностей в случае стратегий наследования `++SINGLE_TABLE++` и `JOINED`.

Параметры:

* `name` - имя колонки-дискриминатора

* `discriminatorType` - тип данных колонки-дискриминатора

Пример:

[source, java]
----
@DiscriminatorColumn(name = "TYPE", discriminatorType = DiscriminatorType.INTEGER)
----
--

[[discriminatorValue_annotation]]
@DiscriminatorValue::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/DiscriminatorValue.html[javax.persistence.DiscriminatorValue].

Определяет значение колонки-дискриминатора для данной сущности. Эта аннотация должна быть помещена на конкретном классе сущности.

Пример:

[source, java]
----
@DiscriminatorValue("0")
----
--

[[inheritance_annotation]]
@Inheritance::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Inheritance.html[javax.persistence.Inheritance].

Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии.

Параметры:

* `strategy` - стратегия, по умолчанию `++SINGLE_TABLE++`
--

[[listeners_annotation]]
@Listeners::
+
--
Определяет список слушателей, предназначенных для реакции на события жизненного цикла экземпляров сущности на <<app_tiers,уровне>> Middleware.

Значением аннотации должна быть строка или массив строк с именами бинов слушателей - см. <<entity_listeners,Entity Listeners>>.

Примеры:

[source, java]
----
@Listeners("sample_UserEntityListener")
----

[source, java]
----
@Listeners({"sample_FooListener","sample_BarListener"})
----
--

[[mappedSuperclass_annotation]]
@MappedSuperclass::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/MappedSuperclass.html[javax.persistence.MappedSuperclass].

Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.
--

[[metaclass_annotation]]
@MetaClass::
+
--
Используется для объявления неперсистентной или <<embeddable_annotation,встраиваемой>> сущности (т.е. когда аннотация `@javax.persistence.Entity` не применима)

Параметры:

* `name` - имя сущности, обязательно должно начинаться с префикса, отделенного знаком `$`. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.

Пример:

[source, java]
----
@MetaClass(name = "sales$Customer")
----
--

[[namePattern_annotation]]
@NamePattern::
+
--
Определяет способ получения имени экземпляра, возвращаемого методом `Instance.getInstanceName()`.

Значением аннотации должна быть строка вида `{0}|{1}`, где

* `{0}` - строка форматирования по правилам `String.format()`, или имя метода данного объекта с префиксом `#`. Метод должен возвращать `String` и не иметь параметров.

* `{1}` - разделенный запятыми список имен полей класса, соответствующий формату `{0}`. В случае использования в `{0}` метода список полей все равно необходим, так как по нему формируется <<views,представление>> `++_minimal++`.

Примеры:

[source, java]
----
@NamePattern("%s|name")
----

[source, java]
----
@NamePattern("#getCaption|login,name")
----
--

[[postConstruct_entity_annotation]]
@PostConstruct::
Данная аннотация может быть указана для метода класса. Такой метод будет вызван сразу после создания экземпляра сущности через <<metadata,Metadata.create()>>. Это удобно, если для инициализации экземпляра сущности требуется вызов каких-либо <<managed_beans,бинов>>. Пример см. в <<init_values_in_class,Инициализация полей сущности>>.

[[primaryKeyJoinColumn_annotation]]
@PrimaryKeyJoinColumn::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/PrimaryKeyJoinColumn.html[javax.persistence.PrimaryKeyJoinColumn].

Используется в случае стратегии наследования `JOINED` для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка.

Параметры:

* `name` - имя колонки внешнего ключа данной сущности

* `referencedColumnName` - имя колонки первичного ключа сущности предка

Пример:

[source, java]
----
@PrimaryKeyJoinColumn(name = "CARD_ID", referencedColumnName = "ID")
----
--

[[systemLevel_annotation]]
@SystemLevel::
Указывает, что данная сущность является системной и не должна быть доступна для выбора пользователем в различных списках сущностей, например, как тип параметра универсального фильтра или тип <<dynamic_attributes,динамического атрибута>>.

[[table_annotation]]
@Table::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Table.html[javax.persistence.Table].

Определяет таблицу базы данных для данной сущности. 

Параметры:

* `name` - имя таблицы

Пример:

[source, java]
----
@Table(name = "SALES_CUSTOMER")
----
--

[[trackEditScreenHistory_annotation]]
@TrackEditScreenHistory::
Указывает, что для данной сущности будет запоминаться история открытия экранов редактирования (`++{имя_сущности}.edit++`) с возможностью отображения в специальном экране `sec$ScreenHistory.browse`, доступном через пункт *Help > History* главного меню.


[[entity_attr_annotations]]
====== Аннотации атрибутов

Аннотации атрибутов устанавливаются на соответствующие поля класса, за одним исключением: если требуется объявить неизменяемый (read only) неперсистентный атрибут `foo`, то достаточно создать метод доступа `getFoo()` и поместить на этот метод аннотацию `@MetaProperty`.

[[caseconversion_annotation]]
@CaseConversion::
+
--
Применяет автоматическую конвертацию регистра к текстовым полям ввода, связанным с аннотированным атрибутом.

Параметры:

* `type` - тип конвертации: `UPPER` (по умолчанию), `LOWER`.

Пример:

[source, java]
----
@CaseConversion(type = ConversionType.UPPER)
@Column(name = "COUNTRY_CODE")
protected String countryCode;
----
--

[[column_annotation]]
@Column::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Column.html[javax.persistence.Column].

Определяет колонку БД, в которой будут храниться значения данного атрибута.

Параметры:

* `name` - имя колонки

* `length` - (необязательный параметр, по умолчанию `255`) - длина колонки. Используется также при формировании <<metadata_framework,метаданных>> и, в конечном счете, может ограничивать максимальную длину вводимого текста в визуальных компонентах, работающих с данным атрибутом. Для отмены ограничения по длине атрибуту необходимо добавить аннотацию <<lob_annotation,@Lob>>.

* `nullable` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `nullable = false` <<jpa,JPA>> контролирует наличие значения поля при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.
--

[[composition_annotation]]
@Composition::
+
--
Указывает на то, что связь является композицией - более тесным вариантом ассоциации. Это означает, что связанная сущность имеет смысл только как часть владеющей сущности, т.е. создается и удаляется вместе с ней.

Например, список пунктов в заказе (класс `Order` содержит коллекцию экземпляров `Item`):

[source, java]
----
@OneToMany(mappedBy = "order")
@Composition
protected List<Item> items;
----

Другой пример - one-to-one отношение:

[source, java]
----
@Composition
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "DETAILS_ID")
protected CustomerDetails details;
----

Указание для связи аннотации `@Composition` позволяет организовать в <<screen_edit,экранах редактирования>> специальный режим коммита источников данных, при котором изменения экземпляров детализирующей сущности сохраняются в базе данных только при коммите основной сущности. Подробнее см. <<composition_recipe,>>.
--

[[embedded_annotation]]
@Embedded::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Embedded.html[javax.persistence.Embedded].

Определяет атрибут типа встраиваемой сущности, в свою очередь аннотированной `@Embeddable`.

Пример:

[source, java]
----
@Embedded
protected Address address;
----
--

[[embeddedParameters_annotation]]
@EmbeddedParameters::
+
--
По умолчанию <<orm,ORM>> не создает экземпляр встроенной сущности если все ее атрибуты равны null в базе данных. Аннотацию `@EmbeddedParameters` можно использовать для указания того, что экземпляр всегда должен создаваться, например:

[source, java]
----
@Embedded
@EmbeddedParameters(nullAllowed = false)
protected Address address;
----
--

[[id_annotation]]
@Id::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Id.html[javax.persistence.Id].

Указывает, что данный атрибут является первичным ключом сущности. Обычно эта аннотация присутствует на поле базового класса, такого как <<base_entity_classes,BaseUuidEntity>>. Использовать эту аннотацию в конкретном классе сущности необходимо только при наследовании от базового класса `BaseStringIdEntity` (то есть при создании сущности со строковым первичным ключом).
--

[[ignoreUserTimeZone]]
@IgnoreUserTimeZone::
+
--
Для атрибутов типа timestamp с аннотацией `@javax.persistence.Temporal.TIMESTAMP` заставляет платформу игнорировать <<timeZone,часовой пояс>> пользователя, если он задан для текущей сессии.
--

[[joinColumn_annotation]]
@JoinColumn::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/JoinColumn.html[javax.persistence.JoinColumn].

Используется для указания колонки БД, определяющей ассоциацию между сущностями. Наличие этой аннотации указывает, что данная сторона отношения является владеющей (owning).

Параметры:

* `name` - имя колонки

Пример:

[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
protected Customer customer;
----
--

[[joinTable_annotation]]
@JoinTable::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/JoinTable.html[javax.persistence.JoinTable].

Используется для указания таблицы связи на ведущей стороне `@ManyToMany` ассоциации.

Параметры:

* `name` - имя таблицы связи

* `joinColumns` - элемент `@JoinColumn`, определяющий колонку таблицы связей, соответствующую первичному ключу ведущей стороны ассоциации (т.е. содержащей аннотацию `@JoinTable`)

* `inverseJoinColumns` - элемент `@JoinColumn`, определяющий колонку таблицы связей, соответствующую первичному ключу ведомой стороны ассоциации

Пример атрибута `customers` класса `Group`, являющегося ведущей стороной ассоциации:

[source, java]
----
@ManyToMany
@JoinTable(name = "SALES_CUSTOMER_GROUP_LINK",
  joinColumns = @JoinColumn(name = "GROUP_ID"),
  inverseJoinColumns = @JoinColumn(name = "CUSTOMER_ID"))
protected Set<Customer> customers;
----

Пример атрибута `groups` класса `Customer`, являющегося ведомой стороной этой же ассоциации:

[source, java]
----
@ManyToMany(mappedBy = "customers")
protected Set<Group> groups;
----
--

[[lob_annotation]]
@Lob::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Lob.html[javax.persistence.Lob].

Указывает, что данный атрибут не имеет ограничений длины. Применяется совместно с аннотацией `@Column`. Если `@Lob` указан, то длина, заданная в `@Column` явно или по умолчанию, игнорируется.

Пример:

[source, java]
----
@Column(name = "DESCRIPTION")
@Lob
private String description;
----
--

[[localizedValue_annotation]]
@LocalizedValue::
+
--
Служит для описания способа получения локализованного значения некоторого изменяющегося атрибута, которое возвращает метод `<<messageTools,MessageTools>>.getLocValue()`.

Параметры:

* `messagePack` - явное указание пакета, из которого будет взято локализованное сообщение, например, `com.haulmont.cuba.core.entity`

* `messagePackExpr` - выражение в терминах пути к атрибуту, хранящему имя пакета, из которого будет взято локализованное сообщение, например `proc.messagesPack`. Путь начинается с атрибута текущей сущности.

Пример аннотации, означающей, что локализованное значение атрибута `state` будет взято из пакета, имя которого хранится в атрибуте `messagesPack` связанной сущности `proc`:

[source, java]
----
@Column(name = "STATE")
@LocalizedValue(messagePackExpr = "proc.messagesPack")
protected String state;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "PROC_ID")
protected Proc proc;
----
--

[[lookup_annotation]]
@Lookup::
+
--
Определяет тип просмотра ссылочных атрибутов.

Параметры:

* `type` - по умолчанию имеет значение `SCREEN`, при котором ссылки открываются через <<screen_lookup,lookup-экран>>. Значение `DROPDOWN` позволяет открывать ссылки в виде выпадающего списка. Если за способ отображения выбран `DROPDOWN`, Studio создаст <<datasources,options datasource>> для выпадающего списка при скаффолдинге экрана редактирования. Таким образом, параметр Lookup type необходимо задать ДО генерации экрана редактирования сущности. Кроме того, компонент <<gui_Filter,Filter>> позволит пользователям выбирать параметры фильтрации также из выпадающего списка вместо lookup-экрана.

* `actions` - определяет действия, которые будут использованы в компоненте `PickerField` в составе `FieldGroup` по умолчанию. Возможные значения: `lookup`, `clear`, `open`.

[source, java]
----
@Lookup(type = LookupType.DROPDOWN, actions = {"open"})
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
protected Customer customer;
----
--

[[manyToMany_annotation]]
@ManyToMany::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/ManyToMany.html[javax.persistence.ManyToMany].

Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации много-ко-многим.

Ассоциация много-ко-многим всегда имеет ведущую сторону и может иметь обратную сторону - ведомую. На ведущей стороне указывается дополнительная аннотация `@JoinTable`, на ведомой стороне - параметр `mappedBy`.

Параметры:

* `mappedBy` - поле связанной сущности, определяющее ассоциацию с ведущей стороны. Необходимо указывать только на ведомой стороне.

* `targetEntity` - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием *Java generics*.

* `fetch` - (необязательный параметр, по умолчанию `LAZY`) - определяет, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.
--

[[manyToOne_annotation]]
@ManyToOne::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/ManyToOne.html[javax.persistence.ManyToOne].

Определяет атрибут-ссылку на сущность с типом ассоциации много-к-одному.

Параметры:

* `fetch` - (по умолчанию `EAGER`) параметр, определяющий, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `optional` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `optional = false` <<jpa,JPA>> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

Например, несколько экземпляров `Order` (заказов) ссылаются на один экземпляр `Customer` (покупателя), в этом случае класс `Order` должен содержать следующее объявление:

[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
protected Customer customer;
----
--

[[metaProperty_annotation]]
@MetaProperty::
+
--
Указывает, что данный атрибут должен быть включен в <<metadata_framework,метаданные>>. Данная аннотация может быть установлена как на поле класса, так и на метод доступа, в случае отсутствия соответствующего атрибуту поля.

Данная аннотация не обязательна для полей, снабженных следующими аннотациями пакета `javax.persistence`: `@Column`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@Embedded`. Такие поля отражаются в метаданных автоматически. Поэтому `@MetaProperty` в основном применяется для определения неперсистентных атрибутов сущностей.

Параметры (опционально):

* `mandatory` - может ли атрибут содержать `null`. При указании `mandatory = true` визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

* `datatype` - явно задает <<datatype,datatype>>, чтобы переопределить datatype задаваемый Java-типом атрибута.

* `related` - задает массив связанных персистентных атрибутов, которые должны быть загружены из БД, если данный атрибут включен во <<views,view>>.

Пример использования для поля:

[source, java]
----
@Transient
@MetaProperty
protected String token;
----

Пример использования для метода:

[source, java]
----
@MetaProperty
public String getLocValue() {
  if (!StringUtils.isBlank(messagesPack)) {
      return AppBeans.get(Messsages.class).getMessage(messagesPack, value);
  } else {
      return value;
  }
}
----
--

[[numberFormat_annotation]]
@NumberFormat::
+
--
Задает формат атрибута типа `Number` (это может быть `BigDecimal`, `Integer`, `Long` или `Double`). Значения такого атрибута будут форматироваться в пользовательском интерфейсе в соответствии с указанными параметрами аннотации:

* `pattern` - паттерн форматирования, задается по правилам, описанным в https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html[DecimalFormat].

* `decimalSeparator` - символ, используемый в качестве разделителя целой и дробной части (опционально).

* `groupingSeparator` - символ, используемый в качестве разделителя групп разрядов (optional).

Если `decimalSeparator` и/или `groupingSeparator` не указаны, фреймворк использует соответствующие значения из format strings для локали текущего пользователя. При форматировании без учета локали в этом случае используются символы из системной локали сервера.

Примеры:

[source, java]
----
@Column(name = "PRECISE_NUMBER", precision = 19, scale = 4)
@NumberFormat(pattern = "0.0000")
protected BigDecimal preciseNumber;

@Column(name = "WEIRD_NUMBER", precision = 19, scale = 4)
@NumberFormat(pattern = "#,##0.0000", decimalSeparator = "_", groupingSeparator = "`")
protected BigDecimal weirdNumber;

@Column(name = "SIMPLE_NUMBER")
@NumberFormat(pattern = "#")
protected Integer simpleNumber;

@Column(name = "PERCENT_NUMBER", precision = 19, scale = 4)
@NumberFormat(pattern = "#%")
protected BigDecimal percentNumber;
----
--

[[onDelete_annotation]]
@OnDelete::
+
--
Определяет политику обработки связи в случае мягкого удаления сущности, содержащей данный атрибут. См. <<soft_deletion,Мягкое удаление>>.

Пример:

[source, java]
----
@OneToMany(mappedBy = "group")
@OnDelete(DeletePolicy.CASCADE)
private Set<Constraint> constraints;
----
--

[[onDeleteInverse_annotation]]
@OnDeleteInverse::
+
--
Определяет политику обработки связи в случае мягкого удаления сущности с обратной стороны ассоциации. См. <<soft_deletion,Мягкое удаление>>.

Пример:

[source, java]
----
@ManyToOne
@JoinColumn(name = "DRIVER_ID")
@OnDeleteInverse(DeletePolicy.DENY)
private Driver driver;
----
--

[[oneToMany_annotation]]
@OneToMany::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/OneToMany.html[javax.persistence.OneToMany].

Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации один-ко-многим.

Параметры:

* `mappedBy` - поле связанной сущности, определяющее ассоциацию

* `targetEntity` - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием *Java generics*.

* `fetch` - (необязательный параметр, по умолчанию `LAZY`) - определяет, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `cascade` - (необязательный параметр, по умолчанию `{}`) - каскадирование операций определяет, какие операции над сущностью должны быть применены к ассоциированным сущностям. Каскадирование на данном уровне не рекомендуется использовать.

Например, несколько экземпляров `Item` (пунктов заказа) ссылаются на один экземпляр `Order` (заказ) с помощью `@ManyToOne` поля `Item.order`, в этом случае класс `Order` может содержать коллекцию экземпляров `Item`:

[source, java]
----
@OneToMany(mappedBy = "order")
protected Set<Item> items;
----
--

[[oneToOne_annotation]]
@OneToOne::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/OneToOne.html[javax.persistence.OneToOne].

Определяет атрибут-ссылку на сущность с типом ассоциации один-к-одному.

Параметры:

* `fetch` - (по умолчанию `EAGER`) параметр, определяющий, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `mappedBy` - поле связанной сущности, определяющее ассоциацию. Требуется устанавливать только на ведомой стороне ассоциации.

* `optional` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `optional = false` <<jpa,JPA>> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

Пример ведущей стороны ассоциации, класс `Driver`:

[source, java]
----
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CALLSIGN_ID")
protected DriverCallsign callsign;
----

Пример ведомой стороны ассоциации, класс `DriverCallsign`:

[source, java]
----
@OneToOne(fetch = FetchType.LAZY, mappedBy = "callsign")
protected Driver driver;
----
--

[[orderBy_annotation]]
@OrderBy::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/OrderBy.html[javax.persistence.OrderBy].

Определяет порядок элементов в атрибуте-коллекции на момент извлечения из базы данных. Данную аннотацию необходимо задавать для упорядоченных коллекций, таких как `List` или `LinkedHashSet` для получения предсказуемого порядка следования элементов.

Параметры:

* `value` - строка, определяющая порядок, в формате:
+
[source, java]
----
orderby_list::= orderby_item [,orderby_item]*
orderby_item::= property_or_field_name [ASC | DESC]
----

Пример:

[source, java]
----
@OneToMany(mappedBy = "user")
@OrderBy("createTs")
protected List<UserRole> userRoles;
----
--

[[temporal_annotation]]
@Temporal::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Temporal.html[javax.persistence.Temporal].

Для атрибута типа `java.util.Date` уточняет тип хранимого значения: дата, время или дата+время.

Параметры:

* `value` - тип хранимого значения: `DATE`, `TIME`, `TIMESTAMP`

Пример:

[source, java]
----
@Column(name = "START_DATE")
@Temporal(TemporalType.DATE)
protected Date startDate;
----
--

[[transient_annotation]]
@Transient::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Transient.html[javax.persistence.Transient].

Указывает, что данное поле не хранится в БД, т.е. является неперсистентным.

Поля поддерживаемых <<jpa,JPA>> типов (см. link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/Basic.html$$[http://docs.oracle.com/javaee/7/api/javax/persistence/Basic.html]) _по умолчанию являются персистентными_, поэтому аннотация `@Transient` обязательна для объявления неперсистентного атрибута такого типа.

Для включения `@Transient` атрибута в метаданные, необходимо также указать аннотацию `<<metaProperty_annotation,@MetaProperty>>`.
--

[[version_annotation]]
@Version::
+
--
См. http://docs.oracle.com/javaee/7/api/javax/persistence/Version.html[javax.persistence.Version].

Указывает, что данное поле хранит версию для поддержки <<optimistic_locking,оптимистичной блокировки>> сущностей.

Применение такого поля необходимо при реализации классом сущности интерфейса `Versioned` (базовый класс `StandardEntity` уже содержит такое поле).

Пример:

[source, java]
----
@Version
@Column(name = "VERSION")
private Integer version;
----
--

[[enum_attributes]]
===== Атрибуты типа enum

В стандартном варианте использования <<jpa,JPA>> для атрибутов типа `enum` в базе данных хранится целое число, получаемое методом `ordinal()` этого перечисления. Такой подход может привести к следующим проблемам при эксплуатации и развитии системы:

* при появлении в БД значения, не равного ни одному `ordinal` значению перечисления, экземпляр сущности нельзя загрузить вообще;

* невозможно ввести новое значение между имеющимися, что актуально при использовании сортировки по значению перечисления (order by).

Чтобы решить эти проблемы, в подходе CUBA предлагается отвязать значение, хранимое в БД, от `ordinal` перечисления. Для этого необходимо поле класса сущности объявлять с типом, хранимым в БД (`Integer` или `String`), а методы доступа (getter / setter) создавать для типа самого перечисления.

Например:

[source, java]
----
include::{sourcesdir}/common/enum_1.java[]
----

При этом сам класс перечисления может выглядеть следующим образом:

[source, java]
----
include::{sourcesdir}/common/enum_2.java[]
----

Для правильного отражения в <<metadata_framework,метаданных>> класс перечисления, используемый в качестве типа атрибута сущности, должен реализовывать интерфейс `EnumClass`.

Как видно из примеров, для атрибута `grade` в БД хранится значение типа `Integer`, задаваемое полем `id` перечисления `CustomerGrade`, а конкретно `10`, `20` или `30`. В то же время прикладной код и метаданные работают с самим типом `CustomerGrade` через методы доступа, которые и осуществляют конвертацию.

При наличии в поле БД значения, не соответствующего ни одному значению перечисления, метод `getGrade()` просто вернет `null`. Для ввода нового значения, например, `HIGHER`, между `HIGH` и `PREMIUM`, достаточно добавить это значение в перечисление с идентификатором `15`, при этом сортировка по полю `Customer.grade` останется верной.

Тип поля `Integer` удобно использовать в случаях, когда необходим упорядоченный список констант, подлежащий сортировке, например, в запросах JPQL и SQL (`>`, `<`, `>=`, `<=`, `order` `by`), кроме того, он имеет незначительное преимущество перед `String` в плане производительности формата хранения и занимаемого места. С другой стороны, значения типа `Integer` сами по себе неочевидны и могут затруднять отладку и интерпретацию результатов запросов, они неудобны в работе с голыми данными и сериализованными форматами. Если отношение упорядочения между константами не требуется, удобнее использовать тип `String`.

Перечисления могут быть созданы в CUBA Studio на вкладке *DATA MODEL* (New -> Enumeration). Чтобы использовать перечисление в качестве атрибута сущности, в редакторе атрибута нужно выбрать `ENUM` в поле *Attribute type* и класс перечисления в поле *Type*. Значениям перечисления могут быть сопоставлены <<enum_localization,локализованные названия>> для отображения в пользовательском интерфейсе приложения.

[[soft_deletion]]
===== Мягкое удаление

Платформа CUBA поддерживает режим "мягкого удаления" данных - когда вместо удаления записей из базы данных они только помечаются определенным образом и становятся недоступными для обычного использования. В дальнейшем такие записи можно либо совсем удалить из БД с помощью отдельной регламентной процедуры, либо восстановить.

Механизм мягкого удаления является "прозрачным" для прикладного программиста - достаточно убедиться, что класс сущности реализует интерфейс `SoftDelete`, и платформа сама нужным образом будет модифицировать запросы и операции с данными.

Режим мягкого удаления имеет следующие преимущества:

* значительно снижается риск потери данных вследствие неверных действий пользователей

* позволяет быстро сделать некоторые записи недоступными, даже если на них имеются ссылки. 
+
Возьмем для примера модель данных `Заказы` - `Покупатели`. Допустим, на некоторого покупателя оформлено несколько заказов, однако нам нужно сделать его недоступным для дальнейшей работы пользователей. Традиционным "жестким" удалением сделать это невозможно, так как для удаления покупателя нам нужно либо удалить все его заказы, либо обнулить в этих заказах ссылки на него (т.е. потерять информацию). При мягком удалении покупателя он становится недоступным для поиска и изменения, однако при просмотре заказов пользователь видит на экране имя покупателя, так как при загрузке связей признак удаления намеренно игнорируется.
+
Описанное поведение является стандартным, но может быть модифицировано с помощью <<delete_policy,политики обработки связей>> при удалении.

Восстановить удалённые сущности можно через экран *Restore Deleted Entities*, по умолчанию доступный в стандартном меню *Administration* приложения. Эта функциональность предназначена для использования администраторами системы, имеющими <<permissions,разрешения>> на все сущности. Её следует использовать с осторожностью, также рекомендуется ограничить доступ к этому экрану для простых пользователей системы.

Отрицательной стороной мягкого удаления является увеличение объема базы данных и потенциальная необходимость дополнительных процедур ее очистки.

[[soft_deletion_usage]]
====== Использование

Для того чтобы экземпляры сущности удалялись мягко, класс сущности должен реализовывать интерфейс `SoftDelete`, а соответствующая таблица БД должна содержать колонки: 

* `DELETE_TS` - когда удалена запись

* `DELETED_BY` - логин пользователя, который удалил запись

Поведение системы по умолчанию - сущности, реализующие `SoftDelete`, удаляются мягко, удаленные сущности не возвращаются запросами и поиском по идентификатору. При необходимости такое поведение можно динамически отключить следующими способами:

* для текущего экземпляра <<entityManager,EntityManager>> - вызовом `setSoftDeletion(false)`

* при запросе данных через <<dataManager,DataManager>> - вызовом у передаваемого объекта `LoadContext` метода `setSoftDeletion(false)`

* на уровне <<datasources,источников данных>> - используя метод `CollectionDatasource.setSoftDeletion(false)` или атрибут `softDeletion="false"` элемента `collectionDatasource` в <<screen_xml,XML-дескрипторе>> экрана.

В режиме мягкого удаления платформа автоматически отфильтровывает удаленные экземпляры при загрузке по идентификатору и по <<jpql,JPQL-запросу>>, а также удаленные элементы связанных сущностей в атрибутах-коллекциях. Однако связанные сущности в единичных (*ToOne) атрибутах загружаются независимо от того, удален связанный экземпляр или нет.

[[delete_policy]]
====== Политика обработки связей

Платформа предоставляет средство обработки связей при удалении сущностей, во многом аналогичное правилам *ON DELETE* внешних ключей в базе данных. Это средство работает на <<app_tiers,уровне>> Middleware и использует аннотации <<onDelete_annotation,@OnDelete>>, <<onDeleteInverse_annotation,@OnDeleteInverse>> атрибутов сущности.

Аннотация `@OnDelete` обрабатывается при удалении той сущности, в которой она встретилась, а не той, на которую указывает аннотированный атрибут (в этом отличие от каскадных удалений на уровне БД).

Аннотация `@OnDeleteInverse` обрабатывается при удалении той сущности, на которую указывает аннотированный атрибут, (т.е. аналогично каскадному удалению на уровне внешних ключей в БД). Эта аннотация полезна при отсутствии в удаляемом объекте атрибута, который нужно проверять при удалении. При этом, как правило, в проверяемом объекте существует ссылка на удаляемый, на этот атрибут и устанавливается аннотация `@OnDeleteInverse`. 

Значением аннотации может быть: 

* `DeletePolicy.DENY` - запретить удаление сущности, если аннотированный атрибут не `null` или не пустая коллекция 

* `DeletePolicy.CASCADE` - каскадно удалить аннотированный атрибут 

* `DeletePolicy.UNLINK` - разорвать связь с аннотированным атрибутом. Разрыв связи имеет смысл указывать только на ведущей стороне ассоциации - той, которая в классе сущности аннотирована `@JoinColumn`. 

Примеры: 

. Запрет удаления при наличии ссылки: при попытке удаления экземпляра `Customer`, на который ссылается хотя бы один `Order`, будет выброшено исключение `DeletePolicyException`.
+
`Order.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
@OnDeleteInverse(DeletePolicy.DENY)
protected Customer customer;
----
+
`Customer.java`
+
[source, java]
----
@OneToMany(mappedBy = "customer")
protected List<Order> orders;
----
+
--
Сообщения в окне исключения могут быть локализованы в <<main_message_pack,главном пакете сообщений>>. Используйте для этого следующие ключи:

* `deletePolicy.caption` - заголовок уведомления.

* `deletePolicy.references.message` - тело сообщения.

* `deletePolicy.caption.sales$Customer` - заголовок уведомления для конкретной сущности.

* `deletePolicy.references.message.sales$Customer` - тело сообщения для конкретной сущности.
--

. Каскадное удаление элементов коллекции: при удалении экземпляра `Role` все экземпляры `Permission` также будут удалены.
+
`Role.java`
+
[source, java]
----
@OneToMany(mappedBy = "role")
@OnDelete(DeletePolicy.CASCADE)
protected Set<Permission> permissions;
----
+
`Permission.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "ROLE_ID")
protected Role role;
----
. Разрыв связи с элементами коллекции: удаление экземпляра `Role` приведет к установке в `null` ссылок со стороны всех входивших в коллекцию экземпляров `Permission`.
+
`Role.java`
+
[source, java]
----
@OneToMany(mappedBy = "role")
protected Set<Permission> permissions;
----
+
`Permission.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "ROLE_ID")
@OnDeleteInverse(DeletePolicy.UNLINK)
protected Role role;
----

Особенности реализации:

. Политика обработки связей реализуется при сохранении данных в БД на уровне Middleware.

. Нужно быть осторожным при использовании `@OnDeleteInverse` с политиками `CASCADE` и `UNLINK`, так как при этом происходит извлечение из БД на сервер приложения всех экземпляров ссылающихся объектов, изменение и затем сохранение.
+
Например, в случае ассоциации `Customer` - `Job` и большого количества работ для одного заказчика, если поставить на атрибут `Job.customer` политику `@OnDeleteInverse(CASCADE)`, то при удалении экземпляра заказчика будет предпринята попытка извлечь и изменить все его работы. Это может привести к перегрузке сервера приложения и БД.
+
С другой стороны, использование `@OnDeleteInverse(DENY)` безопасно, так как при этом производится только подсчет количества ссылающихся объектов, и если оно больше `0`, выбрасывается исключение. Поэтому `@OnDeleteInverse(DENY)` для атрибута `Job.customer` вполне допустимо.

. Политика `UNLINK` не поддерживается для ссылок на коллекции с отношениями one-to-many и many-to-many: при попытке удаления экземпляра сущности на ведущей стороне ассоциации будет выброшено исключение `UnsupportedOperationException`. Пример ошибочной политики:
+
`Owner.java`
+
[source, java]
----
@JoinTable(name = "SAMPLE_OWNER_SUBORDINATE_LINK",
    joinColumns = @JoinColumn(name = "OWNER_ID"),
    inverseJoinColumns = @JoinColumn(name = "SUBORDINATE_ID"))
@OnDelete(DeletePolicy.UNLINK)
@ManyToMany
protected List<Subordinate> subordinate;
----

[[soft_deletion_unique_constr]]
====== Ограничение уникальности на уровне БД

В режиме мягкого удаления для ограничения уникальности некоторого значения необходимо обеспечить существование единственной неудаленной записи с этим значением, и произвольного количества удаленных записей с этим же значением.

Реализуется данная логика путем, специфичным для используемого сервера базы данных:

* Если сервер БД поддерживает частичные (partial) индексы (например, *PostgreSQL*), то ограничение уникальности можно создать следующим образом:
+
[source, sql]
----
create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC) where DELETE_TS is null
----
+
* Если сервер БД не поддерживает частичные индексы (например, *Microsoft SQL Server 2005*), то в уникальный индекс можно включить поле *DELETE_TS*:

[source, sql]
----
create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC, DELETE_TS)
----

[[metadata_framework]]
==== Metadata Framework

Для эффективной работы с <<data_model,моделью данных>> в CUBA-приложениях используется фреймворк метаданных, который:

* предоставляет удобный интерфейс для получения информации о <<entity,сущностях>>, их атрибутах и отношениях между сущностями; а также для навигации по ссылкам

* служит специализированной и более удобной в использовании альтернативой *Java Reflection API*

* регламентирует допустимые типы данных и отношений между сущностями

* позволяет создавать универсальные механизмы работы с данными

[[metadata_interfaces]]
===== Интерфейсы метаданных

Рассмотрим основные интерфейсы метаданных.

.Интерфейсы фреймворка метаданных
image::MetadataFramework.png[align="center"]

`Session`:: 
+
--
Точка входа в фреймворк метаданных. Позволяет получать экземпляры `MetaClass` по имени и по соответствующему классу Java. Обратите внимание на различие методов `getClass()` и `getClassNN()` - первые могут возвращать `null`, вторые нет (NonNull).

Объект `Session` может быть получен через интерфейс инфраструктуры `<<metadata,Metadata>>`.

Пример:

[source, java]
----
@Inject
protected Metadata metadata;
...
Session session = metadata.getSession();
MetaClass metaClass1 = session.getClassNN("sec$User");
MetaClass metaClass2 = session.getClassNN(User.class);
assert metaClass1 == metaClass2;
----
--

`MetaModel`:: 
+
--
Редко используемый интерфейс, служит для группировки мета-классов. 

Группировка осуществляется по имени корневого Java пакета проекта, указываемого в файле `<<metadata.xml,metadata.xml>>`.
--

[[metaClass]]
`MetaClass`:: 
+
--
Интерфейс метаданных класса сущности. `MetaClass` всегда ассоциирован с классом Java, которого он представляет.

Основные методы:

* `getName()` – имя сущности, по соглашению первой частью имени до знака `$` является код пространства имен, например, `sales$Customer`

* `getProperties()` – список мета-свойств (`MetaProperty`)

* `getProperty()`, `getPropertyNN()` - получение мета-свойства по имени. Первый метод в случае отсутствия атрибута с указанным именем возвращает `null`, второй выбрасывает исключение.
+
Пример:
+
[source, java]
----
MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupProperty = userClass.getPropertyNN("group");
----

[[MetaPropertyPath]]
* `getPropertyPath()` - позволяет перемещаться по ссылкам. Данный метод принимает строковый параметр - путь из имен атрибутов, разделенных точкой. Возвращаемый объект `MetaPropertyPath` позволяет обратиться к искомому (последнему в пути) атрибуту вызовом `getMetaProperty()`.
+
Пример:
+
[source, java]
----
MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupNameProp = userClass.getPropertyPath("group.name").getMetaProperty();
assert groupNameProp.getDomain().getName().equals("sec$Group");
----

* `getJavaClass()` – класс сущности, которому соответствует данный `MetaClass`

* `getAnnotations()` – коллекция <<meta_annotations,мета-аннотаций>> 

--

[[metaProperty]]
`MetaProperty`:: 
+
--
Интерфейс метаданных атрибута сущности. 

Основные методы:

* `getName()` – имя свойства, соответствует имени атрибута сущности

* `getDomain()` – мета-класс, которому принадлежит данное свойство

[[metaProperty.getType]]
* `getType()` – тип свойства:

** простой тип: `DATATYPE`

** перечисление: `ENUM`

** ссылочный тип двух видов:
*** `ASSOCIATION` − простая ссылка на другую сущность. Например, отношение заказа и покупателя − ассоциация.

*** `COMPOSITION` − ссылка на сущность, которая не имеет самостоятельного значения без владеющей сущности. `COMPOSITION` можно считать "более тесным" отношением, чем `ASSOCIATION`. Например, отношение заказа и пункта этого заказа − `COMPOSITION`, т.к. пункт не может существовать без заказа, которому он принадлежит.
+
Вид ссылочного атрибута `ASSOCIATION` или `COMPOSITION` влияет на режим редактирования сущности: в первом случае сохранение связанной сущности в базу данных происходит независимо, а во втором − связанная сущность сохраняется в БД только вместе с владеющей сущностью.

* `getRange()` – интерфейс `Range`, детально описывающий тип данного атрибута

* `isMandatory()` – признак обязательности атрибута. Используется, например, визуальными компонентами для сигнализации пользователю о необходимости ввода значения.

* `isReadOnly()` – признак неизменности атрибута

* `getInverse()` – для ссылочного атрибута возвращает мета-свойство с обратной стороны ассоциации, если таковое имеется

* `getAnnotatedElement()` – поле (`java.lang.reflect.Field`) или метод (`java.lang.reflect.Method`), соответствующие данному атрибуту сущности

* `getJavaType()` – класс Java данного атрибута сущности. Это либо тип поля класса, либо тип возвращаемого значения метода.

* `getDeclaringClass()` – класс Java, содержащий данный атрибут

--

`Range`:: 
+
--
Интерфейс, детально описывающий тип атрибута сущности.

Основные методы:

* `isDatatype()` – возвращает `true` для атрибута простого <<metaProperty.getType,типа>>

* `asDatatype()` - возвращает <<datatype,Datatype>> для атрибута простого <<metaProperty.getType,типа>>

* `isEnum()` – возвращает `true` для атрибута <<metaProperty.getType,типа>> перечисления

* `asEnumeration()` - возвращает <<datatype,Enumeration>> для атрибута <<metaProperty.getType,типа>> перечисления

* `isClass()` – возвращает `true` для ссылочного атрибута <<metaProperty.getType, типа>> `ASSOCIATION` или `COMPOSITION`

* `asClass()` - возвращает <<metaClass,мета-класс>> ассоциированной сущности для ссылочного атрибута

* `isOrdered()` – возвращает `true` если атрибут представляет собой упорядоченную коллекцию (например, `List`)

* `getCardinality()` – вид отношения для ссылочного атрибута: `++ONE_TO_ONE++`, `++MANY_TO_ONE++`, `++ONE_TO_MANY++`, `++MANY_TO_MANY++`

--

[[metadata_building]]
===== Формирование метаданных

Основной источник формирования структуры метаданных - <<entity_annotations,аннотированные>> классы сущностей. 

Класс сущности отражается в метаданных в следующих случаях: 

* Класс персистентной сущности аннотирован `@Entity`, `@Embeddable`, `@MappedSuperclass` и расположен в пределах корневого пакета, указанного в `<<metadata.xml,metadata.xml>>`.

* Класс неперсистентной сущности аннотирован `@MetaClass` и расположен в пределах корневого пакета, указанного в `<<metadata.xml,metadata.xml>>`.

Все сущности внутри одного корневого пакета помещаются в один экземпляр `MetaModel`, которому присваивается имя этого пакета. Между сущностями внутри одной `MetaModel` можно устанавливать произвольные связи, между разными - в порядке объявления файлов `metadata.xml` в свойстве `<<cuba.metadataConfig,cuba.metadataConfig>>`.

Атрибут сущности отражается в метаданных, если: 

* поле класса аннотировано `@Column`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@Embedded`

* поле класса или метод доступа на чтение (getter) аннотирован `@MetaProperty`

Параметры мета-класса и мета-свойств формируются на основе параметров перечисленных <<entity_annotations,аннотаций>>, а также типов полей и методов класса. Кроме того, если у атрибута отсутствует метод доступа на запись (setter), атрибут становится неизменяемым (read only). 

[[datatype]]
===== Datatype

Интерфейс `Datatype` определяет методы конвертации значение в строку и из строки (formatting & parsing). Каждый атрибут сущности, не являющийся ссылкой, имеет некоторый `Datatype`, который и используется фреймворком для конвертации значений данного атрибута.

Экземпляры `Datatype` регистрируются в бине `DatatypeRegistry`, который выполняет загрузку и инициализацию классов реализации `Datatype` из файлов <<metadata.xml,metadata.xml>> <<app_components,компонентов приложения>> и самого проекта.

`Datatype` атрибута сущности может быть получен из соответствующего <<metaProperty,meta-property>> методом `getRange().asDatatype()`.

Кроме конвертации значений атрибутов сущностей, зарегистрированные экземпляры `Datatype` могут быть использованы для преобразования в строку и из строки произвольных значений поддерживаемых типов. Для этого необходимо получить экземпляр `Datatype` из `DatatypeRegistry` с помощью его методов `get(Class)` или `getNN(Class)`, передавая тип Java, который необходимо конвертировать.

`Datatype` сопоставляется атрибуту сущности по следующим правилам:

* Как правило, атрибуту сопоставляется экземпляр `Datatype`, зарегистрированный в `DatatypeRegistry` и предназначенный для конвертации типа атрибута.
+
Например, в данном случае атрибут `amount` получит `BigDecimalDatatype`:
+
[source, java]
----
@Column(name = "AMOUNT")
private BigDecimal amount;
----
+
потому что в `cuba-metadata.xml` есть следующий элемент:
+
[source, xml]
----
<datatype id="decimal" class="com.haulmont.chile.core.datatypes.impl.BigDecimalDatatype"
          default="true"
          format="0.####" decimalSeparator="." groupingSeparator=""/>
----

* Для поля или метода можно задать аннотацию <<metaProperty_annotation,@MetaProperty>>, указав в ней атрибут `datatype`.
+
Например, атрибут `issueYear` получит тип `YearDatatype`:
+
[source, java]
----
@MetaProperty(datatype = "year")
@Column(name = "ISSUE_YEAR")
private Integer issueYear;
----
+
если файл `metadata.xml` проекта содержит следующий элемент:
+
[source, xml]
----
<datatype id="year" class="com.company.sample.YearDatatype"/>
----
+
Как видно, атрибут `datatype` аннотации `@MetaProperty` указывает на идентификатор, который использован при регистрации класса имплементации `Datatype` в файле `metadata.xml`.

Основные методы интерфейса `Datatype`:

* `format()` - преобразовывает переданное значение в строку

* `parse()` - преобразовывает строку в значение нужного типа 

* `getJavaClass()` – возвращает тип Java, для конвертации которого создан данный `Datatype`. Этот метод имеет реализацию по умолчанию, которая считывает значение аннотации `@JavaClass`, если она присутствует на классе.

`Datatype` определяет два набора методов для форматирования/парсинга: с учетом локали и без учета локали. Преобразование с учетом локали используется повсеместно в пользовательском интерфейсе, преобразование без учета локали используется в системных механизмах, например, для сериализации в <<rest_api_v2,REST API>>.

Форматы для преобразований без учета локали задаются в коде имплементации или в файле `metadata.xml`.

В следующем разделе описано, как задать форматы преобразований с учетом локали.

[[datatype_format_strings]]
====== Строки форматов Datatype

Форматы для преобразований с учетом локали задаются в <<main_message_pack,главном пакете локализованных сообщений>> проекта или его <<app_components,компонентов>>, в строках со следующими ключами:

* `numberDecimalSeparator` - задает символ разделителя целой и дробной части для числовых типов

* `numberGroupingSeparator` - задает символ разделителя групп разрядов для числовых типов

* `integerFormat` - формат для типов `Integer` и `Long`

* `doubleFormat` - формат для типа `Double`

* `decimalFormat` - формат для типа `BigDecimal`

* `dateTimeFormat` - формат для типа `java.util.Date`

* `dateFormat` - формат для типа `java.sql.Date`

* `timeFormat` - формат для типа `java.sql.Time`

* `trueString` - строка, соответствующая `Boolean.TRUE`

* `falseString` - строка, соответствующая `Boolean.FALSE`

[TIP]
====
Форматы для используемых в приложении языков могут быть заданы в Studio. Для этого откройте на редактирование *Project Properties*, нажмите кнопку в поле *Available locales*, затем нажмите *Show data format strings*.
====

Строки форматов могут быть получены из бина `FormatStringsRegistry`.

[[datatype_custom_example]]
====== Пример специализированного Datatype

В качестве примера рассмотрим следующую задачу: в приложении есть атрибуты сущностей, хранящие годы в виде целых чисел. Пользователи должны иметь возможность просматривать и редактировать годы, причем если пользователь вводит только две цифры, приложение должно преобразовать их в год между 2000 и 2100. В противном случае, все введенное число считается годом.

Создайте класс в модуле *global*:

[source, java]
----
include::{sourcesdir}/common/datatype_1.java[]
----

Затем добавьте элемент `datatypes` в файл <<metadata.xml,metadata.xml>> вашего проекта:

[source, xml]
----
include::{sourcesdir}/common/datatype_2.xml[]
----

В элементе `datatype` можно также указать атрибут `sqlType`, содержащий SQL-тип вашей базы данных, подходящий для хранения значений нового типа. Этот SQL-тип будет использоваться CUBA Studio при генерации скриптов базы данных. Studio может автоматически определить SQL-тип для следующих типов Java:

* `java.lang.Boolean`
* `java.lang.Integer`
* `java.lang.Long`
* `java.math.BigDecimal`
* `java.lang.Double`
* `java.lang.String`
* `java.util.Date`
* `java.util.UUID`
* `byte[]`

В нашем случае класс предназначен для работы с типом `Integer` (что декларируется аннотацией `@JavaClass` со значением `Integer.class`), поэтому атрибут `sqlType` можно не указывать.

Наконец, укажите новый тип данных для требуемых атрибутов (программно или с помощью интерфейса Studio):

[source, java]
----
@MetaProperty(datatype = "year")
@Column(name = "ISSUE_YEAR")
private Integer issueYear;
----

После выполнения перечисленных действий атрибут `latitude` везде в приложении будет отображаться в нужном формате.

[[datatype_ui_format]]
====== Пример форматирования даты в UI

Рассмотрим отображение атрибута `Order.date` в таблице браузера заказов.

`order-browse.xml`

[source, xml]
----
include::{sourcesdir}/common/dateformat_1.xml[]
----

Атрибут `date` в классе `Order` определен с типом "дата":

[source, java]
----
@Column(name = "DATE", nullable = false)
@Temporal(TemporalType.DATE)
private Date date;
----

Если текущий пользователь зарегистрирован c русской локалью, то из <<main_message_pack,главного пакета>> локализованных сообщений извлекается строка:

[source, plain]
----
dateFormat=dd.MM.yyyy
----

В результате дата "2012-08-06" конвертируется в строку "06.08.2012" для отображения в ячейке таблицы.

[[datatype_date_number_format]]
====== Примеры форматирования дат и чисел в коде приложения

Если вам необходимо отформатировать или получить из строки значения `BigDecimal`, `Integer`, `Long`, `Double`, `Boolean` или `Date` учитывая локаль текущего пользователя, используйте бин `DatatypeFormatter`. Например:

[source, java]
----
include::{sourcesdir}/common/dateformat_4.java[]
----

Ниже приведены примеры использования методов интерфейса `Datatype` напрямую.

* Пример форматирования даты
+
[source, java]
----
include::{sourcesdir}/common/dateformat_2.java[]
----

* Пример форматирования числового значения с 5 знаками после запятой в Web Client:
+
.com/sample/sales/web/messages_ru.properties
[source, plain]
----
coordinateFormat = #,##0.00000
----
+
[source, java]
----
include::{sourcesdir}/common/dateformat_3.java[]
----

[[meta_annotations]]
===== Мета-аннотации

Мета-аннотации сущностей - набор пар ключ/значение, содержащих дополнительную информацию о сущностях.

Обращение к мета-аннотациям производится с помощью метода <<metaClass,мета-класса>> `getAnnotations()`.

Источниками мета-аннотаций сущности являются:

* <<entity_annotations,Аннотации>> `@OnDelete`, `@OnDeleteInverse`, `@Extends`. При этом в мета-аннотациях создаются служебные объекты связей между сущностями. 

* Расширяемые мета-аннотации, помеченные аннотацией `@MetaAnnotation`. Эти аннотации конвертируются в мета-аннотации с ключом, соответствующими полному имени класса Java аннотации и значением, являющимся map атрибутов аннотации. Например, аннотация `@TrackEditScreenHistory` будет иметь значение, являющееся map с единственным элементом: `value -> true`. Платформа предоставляет следующие аннотации такого вида: `@NamePattern`, `@SystemLevel`, `@EnableRestore`, `@TrackEditScreenHistory`. В вашем приложении или <<app_components,компоненте>> можно создать собственные аннотации и пометить их аннотацией `@MetaAnnotation`.

* Опционально: в файлах <<metadata.xml,metadata.xml>> также могут быть определены мета-аннотации сущностей. Если мета-аннотация в XML имеет то же имя, что и мета-аннотация, созданная по Java аннотации класса сущности, первая переопределит значение второй.
+
Пример переопределения мета-аннотаций в <<metadata.xml,metadata.xml>>:
+
[source, xml]
----
include::{sourcesdir}/common/metaannotations_1.xml[]
----

[[views]]
==== Представления

При извлечении сущностей из базы данных обычно встает вопрос - как обеспечить загрузку связанных сущностей на нужную глубину? 

Например, для браузера Заказов нужно отобразить дату и сумму заказа совместно с названием Покупателя, т.е. загрузить связанный экземпляр Покупателя. А для экрана редактирования Заказа необходимо загрузить еще и коллекцию Пунктов заказа, причем каждый Пункт заказа должен содержать связанный экземпляр Товара для отображения его наименования. 

<<lazy_loading,Загрузка по требованию>> в большинстве случаев не может помочь, так как обработка данных, как правило, происходит не в транзакции, в которой загружаются сущности, а, например, на клиентском <<app_tiers,уровне>> в пользовательском интерфейсе. В то же время задание <<eager_fetching,жадной загрузки>> в <<entity_annotations,аннотациях сущностей>> недопустимо, так как приводит к постоянному извлечению всего графа связанных сущностей, который может быть очень большим.

Другой похожей проблемой является ограничение набора <<local_attribute,локальных атрибутов>> сущностей загружаемого графа: например, некоторая сущность имеет 50 атрибутов, в том числе BLOB, а в экране отображается только 10 атрибутов. Зачем загружать из БД, затем сериализовать и передавать клиенту 40 атрибутов, которые ему в данный момент не нужны?

Механизм _представлений_ (views) решает эти проблемы, обеспечивая извлечение из базы данных и передачу клиенту графов сущностей, ограниченных в глубину и по атрибутам. _Представление_ является описателем графа объектов, который требуется в некотором экране UI или другом процессе обработки данных.

Обработка представлений производится следующим образом:

* Все связи в модели данных объявляются с признаком <<lazy_loading,загрузки по требованию>> (`fetch = FetchType.LAZY`, см. <<entity_annotations,>>).

* В процессе загрузки данных через <<dataManager,DataManager>> клиентский код помимо <<jpql,JPQL>>-запроса указывает нужное представление.

* На основе представления формируется так называемая _FetchGroup_ - особенность лежащего в основе <<orm,слоя ORM>> фреймворка *EclipseLink*. Fetch Group влияет на формирование SQL-запроса к базе данных: как на список возвращаемых полей, так и на соединения с другими таблицами, содержащими связанные сущности.

.Классы представления
image::View.png[align="center"]

Представление определяется экземпляром класса `View`, в котором:

* `entityClass` - класс сущности, для которого определено представление. Другими словами, "корень" дерева загружаемых сущностей.

* `name` - имя представления. Должно быть либо `null`, либо уникальным в пределах данной сущности.

* `properties` - коллекция экземпляров класса ViewProperty, соответствующих загружаемым атрибутам сущности.

* `includeSystemProperties` - признак включения системных атрибутов (входящих в состав <<base_entity_classes,базовых интерфейсов>> персистентных сущностей `BaseEntity` и `Updatable`).

Класс `ViewProperty` имеет следующие свойства:

* `name` - имя атрибута сущности

* `view` - для ссылочных атрибутов задает представление, с которым необходимо загружать связанную сущность

* `fetch` - для ссылочных атрибутов задает способ загрузки связанной сущности из БД. Соответствует перечислению `FetchMode`:
+
--
** `AUTO` - платформа автоматически выбирает оптимальный режим в зависимости от типа отношения.

** `UNDEFINED` - загрузка будет выполнена по правилам JPA, что означает загрузку отдельными SELECT-запросами.

** `JOIN` - загрузка в том же SELECT-запросе путем объединения с таблицей, содержащей ссвязанную сущность.

** `BATCH` - загрузка экземпляров связанной сущности будет осуществляться порциями. Подробнее см. link:$$http://java-persistence-performance.blogspot.ru/2010/08/batch-fetching-optimizing-object-graph.html$$[здесь].
--
+
Если атрибут `fetch` не указан, будет использоваться режим `AUTO`. Если атрибут представляет собой <<entity_cache,кэшируемую>> сущность, независимо от указанного значения будет использоваться `UNDEFINED`.

[TIP]
====
Независимо от набора атрибутов, определенного в представлении, всегда загружаются следующие атрибуты:

* `id` - идентификатор сущности

* `version` - для оптимистично блокируемых сущностей, реализующих `Versioned`

* `deleteTs`, `deletedBy` - для сущностей, реализующих <<soft_deletion,SoftDelete>>

====

[WARNING]
====
При попытке прочитать или установить значение незагруженного (не включенного в представление) атрибута генерируется исключение. Проверить, загружен ли некоторый атрибут можно методом `PersistenceHelper.isLoaded()`.
====

Незагруженные атрибуты имеют значение `null`. По умолчанию попытка установки значения незагруженного атрибута (вызов setter) для <<entity_states,Detached>> сущности вызывает исключение.

Следует иметь в виду, что незагруженные ссылочные атрибуты Detached сущности, соответствующие внешним ключам (т.е. many-to-one, one-to-one), можно установить в новое ненулевое значение в любом случае, и изменения будут сохранены при последующем `merge()`.

[[views_creation]]
===== Создание представлений

Представление может быть создано двумя путями:

* *программно* - созданием экземпляра `View`, например:
+
[source, java]
----
include::{sourcesdir}/common/views_1.java[]
----
+
Как правило, таким способом создаются представления, используемые только в каком-то одном месте бизнес-логики.

* *декларативно* - путем создания описателя на XML и его развертывания в репозитории представлений `ViewRepository`. При развертывании на основе XML-описателя создаются и кэшируются экземпляры `View`. В дальнейшем в любом месте кода приложения требуемое представление можно получить вызовом репозитория с указанием класса сущности и имени представления.

Рассмотрим подробнее декларативный способ создания и работы с представлениями.

`ViewRepository` является бином *Spring*, доступным для всех блоков приложения. Ссылка на `ViewRepository` может быть также получена через интерфейс инфраструктуры <<metadata,Metadata>>. Для получения экземпляра `View`, содержащегося в репозитории, используются методы `getView()`. Для развертывания XML-описателей представлений в репозитории используются методы `deployViews()` базовой реализации `AbstractViewRepository`.

В репозитории для каждой сущности по умолчанию доступны три представления с именами `_local`, `_minimal` и `_base`:

* `_local` включает в себя все <<local_attribute,локальные>> атрибуты сущности

* `_minimal` включает в себя атрибуты, входящие в имя экземпляра сущности, и задаваемые аннотацией <<namePattern_annotation,@NamePattern>>. Если аннотация `@NamePattern` для сущности не указана, данное представление не включает никаких атрибутов.

* `_base` включает в себя все локальные несистемные атрибуты и атрибуты, заданные в аннотации `@NamePattern` (т.е. фактически `_minimal` + `_local`).

Подробная структура XML-описателей изложена <<views.xml,здесь>>.

Пример описателя представления для сущности Заказ, которое должно обеспечить загрузку всех локальных атрибутов, ассоциированного Покупателя и коллекции Пунктов заказа:

[source, xml]
----
include::{sourcesdir}/common/views_2.xml[]
----

Рекомендуемый способ группировки и развертывания описателей представлений:

* В <<app_modules,модуле>> *global* в корне `src` создать файл `views.xml` и поместить в него все описатели представлений, которые должны быть доступны глобально, т.е. на всех <<app_tiers,уровнях приложения>>.

* Зарегистрировать данный файл в свойстве <<cuba.viewsConfig,cuba.viewsConfig>> блока Middleware и используемых клиентских блоков, т.е. в файле `app.properties` модуля *core*, в файле `web-app.properties` модуля *web* и так далее. Это обеспечит автоматическое развертывание представлений на старте приложения в репозитории Middleware и клиентских блоков (см. метод `AbstractViewRepository.init()`).

* Если существуют представления, которые необходимы только какому-то одному клиентскому блоку приложения, то можно определить их в аналогичном файле данного блока, например, `web-views.xml`, и добавить этот файл в свойство `cuba.viewsConfig` этого блока, т.е. в данном случае в файл `web-app.properties`. 

Если на момент развертывания некоторого представления в репозитории уже есть представление для этого же класса сущности и с таким же именем, то новое будет проигнорировано. Для того чтобы представление заменило имеющееся в репозитории и гарантированно было развернуто, в XML-описателе должен быть явно указан атрибут `overwrite = "true"`.

[TIP]
====
Рекомендуется давать представлениям "описательные" имена. Например, не "browse", а "customerBrowse". Это упрощает поиск XML-описателей представлений по имени в процессе разработки приложения.
====

[[managed_beans]]
==== Управляемые бины

_Управляемые бины (Managed Beans)_ − это программные компоненты, предназначенные для реализации бизнес-логики приложения. Термин "управляемые" в данном случае означает, что созданием экземпляров и установкой связей между такими компонентами управляет <<container,контейнер>> который является основной частью фреймворка *Spring*.

[TIP]
====
Managed Bean представляет собой _singleton_, то есть в некотором блоке приложения существует только один экземпляр данного класса. Поэтому, если бин содержит изменяемые данные в полях (другими словами, имеет состояние), то обращение к таким данным необходимо синхронизировать.
====

[[managed_beans_creation]]
===== Создание бина

Для создания управляемого бина достаточно добавить классу Java аннотацию `@org.springframework.stereotype.Component`. Например:

[source, java]
----
include::{sourcesdir}/common/managedbean_1.java[]
----

Рекомендуется присваивать бину уникальное имя вида `++{имя_проекта}_{имя_класса}++`, и определять его в константе `NAME`. 

[TIP]
====
Аннотация `@javax.annotation.ManagedBean` также может ипользоваться для определения бина, однако ее наличие может вызывать проблемы при развертывании в некоторые сервера приложений. Поэтому мы рекомендуем использовать только аннотацию `@Component` из Spring Framework.
====


Класс управляемого бина должен находиться внутри дерева пакетов с корнем, заданным в элементе `context:component-scan` файла <<spring.xml,spring.xml>>. В нашем случае файл `spring.xml` содержит элемент:

[source, xml]
----
<context:component-scan base-package="com.sample.sales"/>
----

что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета `com.sample.sales`.

Управляемые бины можно создавать на любом <<app_tiers,уровне>>, так как контейнер Spring Framework используется во всех стандартных блоках приложения.

[[managed_beans_usage]]
===== Использование бина

Ссылку на бин можно получить с помощью инжекции или класса `AppBeans`. В качестве примера использования бина рассмотрим реализацию <<services,сервиса>> `OrderService`, делегирующего выполнение бину `OrderWorker`:

[source, java]
----
include::{sourcesdir}/common/managedbean_5.java[]
----

В данном примере сервис стартует <<transactions,транзакцию>>, вносит полученный с клиентского уровня экземпляр сущности в <<entityManager,персистентный контекст>>, и передает управление бину `OrderWorker`, который и содержит основную бизнес-логику. 

[[jmx_beans]]
==== JMX-бины

Иногда требуется предоставить администратору системы возможность просматривать и изменять состояние некоторого <<managed_beans,управляемого бина>> во время выполнения. В этом случае рекомендуется создать JMX-бин - программный компонент, имеющий <<jmx,JMX>>-интерфейс. Такой бин, как правило, делегирует вызовы управляемому бину, содержащему кэш, конфигурационные данные или статистику, к которым нужно обеспечить доступ через JMX.

image::JMXBeans.png[align="center"]

Как видно из диаграммы, JMX-бин состоит из интерфейса и класса реализации. Класс должен представлять собой <<managed_beans,управляемый бин>>, то есть иметь аннотацию `@Component` и уникальное имя. Интерфейс JMX-бина специальным образом регистрируется в <<spring.xml,spring.xml>> для создания в текущей JVM собственно JMX-интерфейса.

Вызовы всех методов интерфейса JMX-бина перехватываются с помощью *Spring AOP* классом−<<interceptor,интерцептором>> `MBeanInterceptor`, который обеспечивает установку правильного `ClassLoader` в контексте потока выполнения, и журналирование необработанных исключений.

[WARNING]
====
Интерфейс JMX-бина обязательно должен иметь имя вида `++{имя_класса}MBean++`.
====

С JMX-интерфейсом можно работать из внешних инструментов, таких как `jconsole` или `jvisualvm`. Кроме того, в состав блока Web Client платформы входит <<jmx_console,JMX-консоль>>, предоставляющая базовые средства просмотра состояния и вызова методов JMX-бинов.

[[jmx_beans_creation]]
===== Создание JMX-бина

Рассмотрим процесс создания JMX-бина на примере.

* Интерфейс JMX-бина:
+
[source, java]
----
include::{sourcesdir}/common/jmxbean_1.java[]
----

** Интерфейс и его методы могут содержать аннотации для задания описания JMX-бина и его операций. Это описание будет отображаться во всех инструментах, работающих с данным JMX-интерфейсом, тем самым помогая администратору системы.

** Аннотацию `@JmxRunAsync` можно использовать для указания длительных операций. Если такая операция запускается через встроенную <<jmx_console,консоль JMX>>, платформа отображает диалог с неопределенным индикатором прогресса и кнопкой *Cancel*. Пользователь может прервать операцию и продолжить работу с приложением. Аннотация может также содержать параметр `timeout`, который устанавливает максимальное время выполнения в миллисекундах, например:
+
[source, java]
----
@JmxRunAsync(timeout = 30000)
String calculateTotals();
----
+
Если таймаут превышен, диалог закрывается с сообщением об ошибке.
+
[WARNING]
====
Пожалуйста имейте в виду, что если операция прервана пользователем или по таймауту, она все равно продолжает работать в фоне, то есть данные действия не прерывают самого выполнения, а только возвращают управление пользователю.
====

** Так как инструменты JMX поддерживают ограниченный набор типов данных, параметры и результат метода желательно задавать типа `String`, и при необходимости выполнять конвертацию внутри метода. Помимо `String`, поддерживаются следующие типы параметров: `boolean`, `double`, `float`, `int`, `long`, `Boolean`, `Integer`.

* Класс JMX-бина:
+
[source, java]
----
include::{sourcesdir}/common/jmxbean_2.java[]
----
+
Аннотация `@Component` определяет, что данный класс является управляемым бином с именем `++sales_OrdersMBean++`. Имя указано напрямую в аннотации, а не в константе, так как доступ к JMX-бину из кода Java не требуется.
+
Рассмотрим реализацию метода `calculateTotals()`.

** Метод имеет аннотацию `@Authenticated`, т.е. при входе в метод и при отсутствии в потоке выполнения <<userSession,пользовательской сессии>> выполняется <<system_authentication,системная аутентификация>>.

** Тело метода обернуто в блок try/catch, так что метод в случае успешного выполнения возвращает строку "Done", а в случае ошибки - stacktrace исключения в виде строки.
+
В данном случае все исключения обрабатываются, а значит, не попадают в `MBeanInterceptor` и не выводятся в журнал автоматически. Поэтому при необходимости логировать исключения здесь нужно добавить вызов логгера в секции `catch`.

** Логика метода заключается в том, что он стартует транзакцию, загружает экземпляр сущности `Order` по идентификатору и передает управление бину `OrderWorker` для обработки.

* Регистрация JMX-бина в `spring.xml`:
+
[source, xml]
----
include::{sourcesdir}/common/jmxbean_3.xml[]
----
+
Все JMX-бины проекта объявляются в одном экземпляре `MBeanExporter` в элементах `map/entry` свойства `beans`. Ключом элемента здесь является JMX ObjectName, значением - имя бина, заданное в аннотации `@Component`. ObjectName начинается с имени веб-приложения, так как в одном экземпляре сервера приложения (т.е. в одной JVM) может быть развернуто несколько веб-приложений, экспортирующих одинаковые JMX-интерфейсы.

[[jmx_beans_platform]]
===== JMX-бины платформы

В данном разделе описаны некоторые имеющиеся в платформе JMX-бины.

[[cachingFacadeMBean]]
====== CachingFacadeMBean

`CachingFacadeMBean` предоставляет методы очистки различных кэшей в блоках Middleware и Web Client.

JMX ObjectName: `app-core.cuba:type=CachingFacade` и `app.cuba:type=CachingFacade`

[[configStorageMBean]]
====== ConfigStorageMBean

`ConfigStorageMBean` позволяет просматривать и задавать значения <<app_properties,свойствам приложения>> в блоках Middleware, Web Client и Web Portal.

Данный интерфейс имеет отдельные наборы операций для работы с параметрами конфигурации и развертывания (`*AppProperties`) и с параметрами времени выполнения (`*DbProperties`). Эти операции отображают только свойства, явно заданные в хранилище. То есть если имеется конфигурационный интерфейс, определяющий некоторое свойство и его значение по умолчанию, но в базе данных или в файлах никакого значения не указано, данные операции не отобразят свойство и его текущее значение.

Заметьте, что изменения в свойствах, хранящихся в файлах, не персистентны и актуальны только до перезапуска блока приложения.

В отличие от операций, описанных выше, операция `getConfigValue()` всегда возвращает в точности то значение, какое вернул бы соответствующий метод конфигурационного интерфейса, вызванный из кода приложения.

JMX ObjectName:

* `app-core.cuba:type=ConfigStorage`
* `app.cuba:type=ConfigStorage`
* `app-portal.cuba:type=ConfigStorage`

[[emailerMBean]]
====== EmailerMBean

`EmailerMBean` позволяет просмотреть текущие значения параметров <<email_sending,отсылки email>>, а также отправить тестовое сообщение.

JMX ObjectName: `app-core.cuba:type=Emailer`

[[persistenceManagerMBean]]
====== PersistenceManagerMBean

`PersistenceManagerMBean` предоставляет следующие возможности:

* управление механизмом <<entity_statistics,статистики сущностей>>

* отображение новых скриптов обновления БД методом `findUpdateDatabaseScripts()` и запуск обновления методом `updateDatabase()`

* запуск произвольных JPQL запросов в контексте Middleware методами `jpqlLoadList()`, `jpqlExecuteUpdate()`

JMX ObjectName: `app-core.cuba:type=PersistenceManager`

[[scriptingManagerMBean]]
====== ScriptingManagerMBean

`ScriptingManagerMBean` является JMX-фасадом для интерфейса инфраструктуры <<scripting,Scripting>>.

JMX ObjectName: `app-core.cuba:type=ScriptingManager`

JMX-атрибуты:

* `RootPath` - абсолютный путь к <<conf_dir,конфигурационному каталогу>> <<app_tiers,блока приложения>>, в котором запущен данный бин.

JMX-операции:

[[scripting.runGroovyScript]]
* `runGroovyScript()` - выполнить скрипт Groovy в контексте Middleware и вернуть результат. В скрипт передаются следующие переменные:

** `persistence` типа <<persistence,Persistence>>

** `metadata` типа <<metadata,Metadata>>

** `configuration` типа <<configuration,Configuration>>

** `dataManager` типа <<dataManager,DataManager>>
+
Для отображения в JMX-интерфейсе результат должен быть типа `String`. В остальном аналогичен методу `Scripting.<<scripting.runGroovyScript,runGroovyScript()>>`. 
+
Пример скрипта, создающего набор тестовых пользователей:
+
[source, groovy]
----
include::{sourcesdir}/common/scriptingjmx_1.java[]
----

[[serverInfoMBean]]
====== ServerInfoMBean

`ServerInfoMBean` предоставляет общую информацию о данном блоке Middleware: номер и дату сборки, <<serverId,идентификатор сервера>>.

JMX ObjectName: `app-core.cuba:type=ServerInfo`

[[infrastructure_interfaces]]
==== Интерфейсы инфраструктуры

Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Большинство из этих интерфейсов расположены в <<app_modules,модуле>> *global* и могут быть использованы как на среднем слое, так и в <<app_tiers,блоках>> клиентского уровня, но некоторые (например, <<persistence,Persistence>>) доступны только коду среднего слоя.

Интерфейсы инфраструктуры реализуются бинами Spring Framework, поэтому они могут быть инжектированы в любые другие управляемые компоненты (<<managed_beans,Managed Beans>>, <<services,сервисы среднего слоя>>, <<screen_controller,контроллеры>> экранов универсального пользовательского интерфейса).

Кроме того, как и любые другие бины, интерфейсы инфраструктуры могут быть получены с помощью статических методов класса `AppBeans` и использоваться в неуправляемых компонентах (POJO, вспомогательных классах и пр.).

[[configuration]]
===== Configuration

Позволяет получать ссылки на <<config_interfaces,конфигурационные интерфейсы>> там, где невозможна их инжекция.

Пример:

[source, java]
----
include::{sourcesdir}/common/configuration_1.java[]
----

[source, java]
----
include::{sourcesdir}/common/configuration_2.java[]
----

[source, java]
----
include::{sourcesdir}/common/configuration_3.java[]
----

[[messages]]
===== Messages

Интерфейс `Messages` обеспечивает получение <<localization,локализованных строк сообщений>>.

Рассмотрим методы интерфейса подробнее.

* `getMessage()` - возвращает локализованное сообщение по ключу, имени пакета сообщений и требуемой локали. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.
+
Примеры:
+
[source, java]
----
@Inject
protected Messages messages;
...
String message1 = messages.getMessage(getClass(), "someMessage");
String message2 = messages.getMessage("com.abc.sales.web.customer", "someMessage");
String message3 = messages.getMessage(RoleType.STANDARD);
----

* `formatMessage()` - находит локализованное сообщение по ключу, имени пакета сообщений и требуемой локали, и использует его для форматирования переданных параметров. Формат задается по правилам метода `String.format()`. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.
+
Пример:
+
[source, java]
----
String formattedValue = messages.formatMessage(getClass(), "someFormat", someValue);
----

* `getMainMessage()` - возвращает локализованное сообщение из <<main_message_pack,главного пакета>> данного <<app_tiers,блока>> приложения.
+
Пример:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
messages.getMainMessage("actions.Ok");
----

* `getMainMessagePack()` - возвращает имя <<main_message_pack,главного пакета>> сообщений данного блока приложения.
+
Пример:
+
[source, java]
----
String formattedValue = messages.formatMessage(messages.getMainMessagePack(), "someFormat", someValue);
----

* `getTools()` - возвращает экземпляр интерфейса `MessageTools` (см. ниже).

[[messageTools]]
====== MessageTools

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с <<localization,локализованными сообщениями>>. Интерфейс `MessageTools` можно получить либо методом `Messages.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`. 

Методы `MessageTools`:

[[messageTools.loadString]]
* `loadString()` - возвращает локализованное сообщение, заданное ссылкой вида `msg://{messagePack}/{key}`.
+
Составные части ссылки:

** `msg://` - обязательный префикс.

** `{messagePack}` - необязательное имя пакета сообщения. Если не указано, предполагается, что имя пакета передается в `loadString()` отдельным параметром.

** `{key}` - ключ сообщения в пакете.
+
Примеры ссылок на сообщения:
+
[source, plain]
----
msg://someMessage
msg://com.abc.sales.web.customer/someMessage
----

* `getEntityCaption()` - возвращает локализованное название сущности.

* `getPropertyCaption()` - возвращает локализованное название атрибута сущности.

* `hasPropertyCaption()` - определяет, задано ли для атрибута сущности локализованное название. 

* `getLocValue()` - возвращает локализованное значение атрибута сущности, основываясь на определении аннотации <<localizedValue_annotation,@LocalizedValue>>.

* `getMessageRef()` - формирует для <<metaProperty,мета-свойства>> ссылку на сообщение, по которой можно получить локализованное название атрибута сущности.

* `getDefaultLocale()` - возвращает локаль приложения по умолчанию, то есть указанную первой в списке свойства <<cuba.availableLocales,cuba.availableLocales>>.

* `useLocaleLanguageOnly()` - возвращает `true`, если в списке поддерживаемых приложением локалей, заданном свойством <<cuba.availableLocales,cuba.availableLocales>>, для всех локалей определен только язык, а `country` и `variant` не указаны. Этим методом пользуются механизмы платформы, которым необходимо найти наиболее подходящую локаль из списка поддерживаемых на основе локали, полученной из внешних источников, таких как операционная система или HTTP запрос.

* `trimLocale()` - удаляет из переданной локали все кроме языка, если метод `useLocaleLanguageOnly()` возвращает `true`.

Для расширения набора вспомогательных методов в конкретном приложении бин `MessageTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
MyMessageTools tools = messages.getTools();
tools.foo();
----

[source, java]
----
((MyMessageTools) messages.getTools()).foo();
---- 

[[metadata]]
===== Metadata

Интерфейс `Metadata` обеспечивает доступ к сессии <<metadata_framework,метаданных>> и репозиторию <<views,представлений>>.

Методы интерфейса:

* `getSession()` - возвращает экземпляр сессии <<metadata_framework,метаданных>> 

* `getViewRepository()` - возвращает экземпляр репозитория <<views,представлений>>

* `getExtendedEntities()` - возвращает экземпляр `ExtendedEntities`, предназначенный для работы с расширенными сущностями. Подробнее см. <<entity_extension,>>

* `create()` - создать экземпляр сущности, учитывая возможность расширения. Подробнее см. <<entity_extension,>> 

* `getTools()` - возвращает экземпляр интерфейса `MetadataTools` (см. ниже).

[[metadataTools]]
====== MetadataTools

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с метаданными. Интерфейс `MetadataTools` можно получить либо методом `Metadata.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`.

Методы `MetadataTools`:

* `getAllPersistentMetaClasses()` - возвращает коллекцию <<metaClass,мета-классов>> персистентных сущностей

* `getAllEmbeddableMetaClasses()` - возвращает коллекцию <<metaClass,мета-классов>> встраиваемых сущностей

* `getAllEnums()` - возвращает коллекцию классов перечислений, используемых в качестве типов атрибутов сущностей

* `format()` - форматирует переданное значение в соответствии с типом данных заданного <<metaProperty,мета-свойства>>

* `isSystem()` - определяет, является ли переданное <<metaProperty,мета-свойство>> системным, т.е. заданным в одном из <<base_entity_classes,базовых интерфейсов сущностей>>

* `isPersistent()` - определяет, является ли переданное мета-свойство персистентным, т.е. хранимым в БД

* `isTransient()` - определяет, является ли переданное мета-свойство или произвольный атрибут неперсистентным

* `isEmbedded()` - определяет, является ли переданное мета-свойство встроенным объектом

* `isAnnotationPresent()` - определяет наличие указанной аннотации на классе или его предках

* `getNamePatternProperties()` - возвращает коллекцию мета-свойств атрибутов, входящих в имя экземпляра, возвращаемого методом `Instance.getInstanceName()`. См. <<namePattern_annotation,@NamePattern>>.

Для расширения набора вспомогательных методов в конкретном приложении бин `MetadataTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
MyMetadataTools tools = metadata.getTools();
tools.foo();
----

[source, java]
----
((MyMetadataTools) metadata.getTools()).foo();
----

[[resources]]
===== Resources

Обеспечивает загрузку ресурсов по следующим правилам:

. если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;

. если указанное местонахождение начинается с префикса `classpath:`, ресурс загружается из classpath;

. если не URL и не начинается с `classpath:`, то:

.. в <<conf_dir,каталоге конфигурации>> приложения ищется файл, используя указанное местонахождение как относительный путь. Если файл найден, ресурс загружается из него;

.. если ресурс не найден на предыдущих этапах, он загружается из classpath.

На практике явное указание URL или префикса `classpath:` используется редко, т.е. обычно ресурсы загружаются либо из <<conf_dir,конфигурационного каталога>>, либо из classpath. Ресурс в конфигурационном каталоге замещает одноименный ресурс в classpath.

Методы `Resources`:

* `getResourceAsStream()` - возвращает `InputStream` для указанного ресурса, либо `null`, если ресурс не найден. Поток должен быть закрыт после использования, например:
+
[source, java]
----
include::{sourcesdir}/common/resources_1.java[]
----
+
Возможно использование "try with resources":
+
[source, java]
----
include::{sourcesdir}/common/resources_2.java[]
----

* `getResourceAsString()` - возвращает указанный ресурс в виде строки, либо `null`, если ресурс не найден

[[scripting]]
===== Scripting

Интерфейс `Scripting` позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.

Методы `Scripting`:

* `evaluateGroovy()` - выполняет выражение на Groovy и возвращает его результат. 
+
Свойство приложения <<cuba.groovyEvaluatorImport,cuba.groovyEvaluatorImport>> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <<persistenceHelper,PersistenceHelper>>.
+
Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_1.java[]
----

[[scripting.runGroovyScript]]
* `runGroovyScript()` - выполняет скрипт Groovy и возвращает его результат.
+
Скрипт должен быть расположен либо в <<conf_dir,конфигурационном каталоге>> приложения, либо в classpath (текущая реализация `Scripting` поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.
+
Путь к скрипту указывается с разделителями `/`, в начале пути символ `/` не требуется.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_2.java[]
----

* `loadClass()` - загружает Java или Groovy класс, используя следующую последовательность действий:

. Если класс уже загружен, возвращает его.

. Ищет исходный текст Groovy (файл `*.groovy`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет исходный текст Java (файл `*.java`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.

. Если ничего не найдено, возвращает `null`.
+
Файлы исходных текстов Java и Groovy в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове `loadClass()` соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:

** нельзя изменять тип исходного текста с Groovy на Java

** если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по-прежнему возвращаться класс, скомпилированный из удаленного исходника.
+
Пример:
+
[source, java]
----
include::{sourcesdir}/common/scripting_3.java[]
----

* `getClassLoader()` - возвращает `ClassLoader`, способный работать по правилам, описанным выше для метода `loadClass()`.

Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бина <<cachingFacadeMBean,CachingFacadeMBean>>.

См. также <<scriptingManagerMBean,ScriptingManagerMBean>>.

[[security]]
===== Security

Обеспечивает авторизацию - проверку прав пользователя на различные объекты системы. Перед вызовом соответствующих методов <<userSession,UserSession>> выполняется поиск исходного мета-класса сущности, что является важным при наличии <<entity_extension,расширений>>. Кроме методов, дублирующих методы `UserSession`, данный интерфейс имеет методы `isEntityAttrReadPermitted()` и `isEntityAttrUpdatePermitted()`, предназначенные для определения доступности пути к атрибуту с учетом доступности атрибутов и сущностей, входящих в этот путь.

Интерфейс `Security` рекомендуется использовать в прикладном коде вместо вызовов методов `UserSession.isXYXPermitted()`.

Подробнее см. <<authentication,Аутентификация пользователей>>.

[[timeSource]]
===== TimeSource

Обеспечивает получение текущего времени. Применение `new Date()` и т.п. в прикладном коде не рекомендуется.

Примеры:

[source, java]
----
include::{sourcesdir}/common/timesource_1.java[]
----

[source, java]
----
include::{sourcesdir}/common/timesource_2.java[]
----

[[userSessionSource]]
===== UserSessionSource

Обеспечивает получение объекта сессии текущего пользователя. Подробнее см. <<authentication,Аутентификация пользователей>>.

[[uuidSource]]
===== UuidSource

Обеспечивает получение значений `UUID`, в том числе для идентификаторов сущностей. Применение `UUID.randomUUID()` в прикладном коде не рекомендуется.

Для вызова из статического контекста можно использовать класс `UuidProvider`, который имеет также дополнительный метод `fromString()`, работающий быстрее, чем стандартный метод `UUID.fromString()`.

[[dataManager]]
===== DataManager

Интерфейс `DataManager` является универсальным средством для загрузки графов сущностей из базы данных, и для сохранения изменений, произведенных в detached экземплярах сущностей. 

[TIP]
====
В разделе <<dm_vs_em>> приведена информация о различиях между DataManager и <<entityManager,EntityManager>>.
====

`DataManager` на самом деле делегирует выполнение реализациям <<data_store,DataStore>>, и поддерживает ссылки между сущностями из разных хранилищ. Большинство деталей реализации, описанных ниже, актуальны только когда производится работа через `RdbmsStore` с сущностями, хранящимися в реляционной БД. Для другого типа хранилища все, кроме сигнатур методов, может отличаться. Для простоты изложения, далее, когда мы говорим просто "DataManager", мы будем иметь в ввиду "DataManager через RdbmsStore".

Методы `DataManager`:

* `load()`, `loadList()` - загружает граф сущностей в соответствии с параметрами переданного объекта `LoadContext`. 
+
В `LoadContext` обязательно должен быть передан либо JPQL-запрос, либо идентификатор сущности. Если передано и то и другое, используется запрос, а идентификатор игнорируется. 
+
Правила создания запросов аналогичны описанным в разделе <<query,Выполнение JPQL-запросов>>. Отличием является то, что в запросе `LoadContext` могут быть использованы только именованные параметры, позиционные не поддерживаются.
+
Примеры загрузки сущностей в контроллере экрана:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_1.java[]
---- 

* `loadValues()` - загружает список пар ключ-значение. Метод принимает `ValueLoadContext`, в котором задается запрос и список ключей. Возвращаемый список содержит экземпляры `KeyValueEntity`. Например:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_3.java[]
----

* `getCount()` - возвращает количество записей для запроса, переданного в метод. Когда возможно, для максимальной производительности, стандартная реализация в классе `RdbmsStore` выполняет запрос `select count()` с условиями исходного запроса.

* `commit()` - сохраняет в базе данных набор сущностей, переданный в объекте `CommitContext`. Отдельно указываются коллекции сущностей, которые нужно сохранить и которые нужно удалить.
+
Метод возвращает набор экземпляров сущностей, возвращенных из метода <<entityManager,EntityManager>>.merge(), то есть по сути свежие экземпляры, только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки. Для того, чтобы обеспечить наличие нужных атрибутов у возвращенных сущностей, с помощью мэп `CommitContext.getViews()` можно указать <<views,представление>> для каждого сохраняемого экземпляра. 
+
Примеры сохранения коллекций сущностей:
+
[source, java]
----
include::{sourcesdir}/common/dataManager_2.java[]
---- 

* `reload()` - удобный метод для перезагрузки экземпляра сущности с требуемым <<views,представлением>>. Делегирует выполнение методу `load()`.

* `remove()` - удаляет экземпляр сущности из базы данных. Делегирует выполнение методу `commit()`.

[[dm_transactions]]
Транзакции::
+
--
`DataManager` всегда стартует новую транзакцию и по завершении работы выполняет коммит, таким образом возвращая сущности в <<entity_states,detached состоянии>>.
--

[[dm_partial_entities]]
Частичные сущности::
+
--
По умолчанию, DataManager загружает _частичные_ сущности в соответствии с указанными <<views,представлениями>>. В следующих случаях будут загружаться все локальные атрибуты и представление будет определять только загрузку связей:

* Загружаемая сущность <<entity_cache,кэшируется>>.
* Для сущности заданы in-memory "read" <<constraints,ограничения>>.
* Атрибут `loadPartialEntities` класса `LoadContext` установлен в false.
--

[[dm_security]]
====== Права доступа в DataManager

Методы `load()`, `loadList()`, `loadValues()` и `getCount()` проверяют наличие у пользователя <<permissions,права>> READ на загружаемую сущность. Кроме того, при извлечении сущностей из БД накладываются <<constraints,ограничения>> групп доступа.

Метод `commit()` проверяет наличие у пользователя права UPDATE на изменяемые сущности и DELETE на удаляемые.

По умолчанию, `DataManager` проверяет права на операции (READ/CREATE/UPDATE/DELETE) с сущностями, когда вызывается с клиентской стороны, и игнорирует их, когда вызывается из кода middleware. Права на атрибуты по умолчанию не проверяются.

Если вы хотите, чтобы `DataManager` проверял права на операции и при вызове на среднем слое, получите методом `DataManager.secure()` специальный объект-обертку и вызывайте методы у него. В качестве альтернативы, вы можете установить свойство приложения <<cuba.dataManagerChecksSecurityOnMiddleware,cuba.dataManagerChecksSecurityOnMiddleware>>, чтобы проверка прав работала для всего приложения.

Права на атрибуты будут проверяться только если вы дополнительно установите свойство приложения <<cuba.entityAttributePermissionChecking,cuba.entityAttributePermissionChecking>> в true.

Имейте в ввиду, что <<constraints,ограничения>> групп доступа (row-level security) применяются всегда, независимо от того, был ли вызов с клиентского или со среднего слоя.


[[query_with_distinct]]
====== Запросы с distinct

В JPQL запросах для экранов со списками сущностей, в которых включено постраничное отображение и возможна непредсказуемая модификация запроса <<gui_Filter,универсальным фильтром>> или механизмом ограничений групп доступа, при отсутствии в запросе оператора `distinct` может возникать следующий эффект: 

* при объединении с коллекцией на уровне извлечения из базы данных возникает набор с дубликатами строк

* на клиентском уровне в источнике данных дубликаты исчезают, т.к. попадают в мэп (`java.util.Map`) 

* при постраничном отображении на одной странице оказывается меньшее количество строк, чем запрошено, общее количество строк наоборот завышено.

Таким образом, рекомендуется в JPQL запросы браузеров включать предложение `distinct`, которое гарантирует отсутствие дубликатов записей при выборке из базы данных. Однако в некоторых серверах БД (в частности *PostgreSQL*) при большом количестве извлекаемых записей (более 10000) SQL запрос с `distinct` выполняется недопустимо долго.

Для решения этой проблемы в платформе реализована возможность корректной работы без `distinct` на уровне SQL. Данный механизм включается свойством приложения <<cuba.inMemoryDistinct,cuba.inMemoryDistinct>>, при активации которого выполняется следующее: 

* В JPQL запросе должен по-прежнему присутствовать `select distinct`

* В `DataManager` из JPQL запроса перед отправкой в ORM `distinct` вырезается 

* После загрузки страницы данных на Middleware удаляются дубликаты и выполняются дополнительные запросы к БД для получения нужного количества строк, которые затем и возвращаются клиенту.

[[query_from_selected]]
====== Последовательная выборка

`DataManager` может выполнять последовательную выборку данных из результатов предыдущего запроса. Эта возможность используется в <<gui_Filter,универсальном фильтре>> при последовательном наложении фильтров. 

Данный механизм работает следующим образом:

* При получении `LoadContext` с установленными атрибутами `prevQueries` и `queryKey` `DataManager` выполняет выборку по предыдущему запросу и сохраняет идентификаторы полученных сущностей в таблице `SYS_QUERY_RESULT` (соответствующей сущности `sys$QueryResult`), разделяя наборы записей по идентификаторам пользовательских сессий и ключу сеанса выборки `queryKey`.

* Текущий запрос модифицируется для объединения с результатами предыдущего, так что в итоге возвращает данные, соответствующие условиям обоих запросов, объединенных по "И".

* Далее процесс может повторяться, при этом уменьшающийся набор предыдущих результатов удаляется из таблицы `SYS_QUERY_RESULT` и заполняется заново.

Таблицу `SYS_QUERY_RESULT` необходимо периодически чистить от ненужных результатов запросов, оставленных завершенными пользовательскими сессиями. Для этого предназначен метод `deleteForInactiveSessions` бина `QueryResultsManagerAPI`. В прикладном проекте с включенным параметром <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> необходимо вызывать этот метод из <<scheduled_tasks,назначенных заданий>>, например:

[source, xml]
----
include::{sourcesdir}/common/sequentialqueries_1.xml[]
----

[[events]]
===== Events

Бин `Events` реализует функциональность публикации объектов-событий уровня приложения. События могут использоваться для передачи данных между слабо связанными компонентами приложения. Бин `Events` является простым фасадом для объекта `ApplicationEventPublisher` Spring Framework.

[source, java]
----
include::{sourcesdir}/common/events.java[]
----

Этот бин имеет только один метод - `publish()`, принимающий объект события. Метод `Events.publish()` уведомляет все слушатели, зарегистрированные в приложении и подписанные на события того же типа, что и переданный объект. Вы может использовать класс-обёртку `PayloadApplicationEvent` для публикации любых объектов в качестве событий.

См. также https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2[руководство Spring Framework].

[[bean-events]]
Обработка событий в компонентах приложения::
+
--

Прежде всего, необходимо создать класс события. Он должен быть наследником класса `ApplicationEvent`. Класс события может включать любые дополнительные данные. Например:
[source, java]
----
include::{sourcesdir}/common/events_DemoEvent.java[]
----

Бины могут публиковать события, используя бин `Events`:
[source, java]
----
include::{sourcesdir}/common/events_DemoBean.java[]
----

По умолчанию все события обрабатываются синхронно.

Есть два способа обработки событий:

- Реализовать интерфейс `ApplicationListener`.
- Использовать аннотацию `@EventListener` для метода.

В первом случае, мы должны создать бин, реализующий интерфейс `ApplicationListener` с указанием типа события:
[source, java]
----
include::{sourcesdir}/common/events_DemoEventListener.java[]
----

Второй способ может использоваться для сокрытия деталей реализации обработчика событий и обработки множества различных событий в одном бине:
[source, java]
----
include::{sourcesdir}/common/events_MultipleEventListener.java[]
----

Вы можете использовать интерфейс `Ordered` и аннотацию `@Order` Spring Framework для указания порядка исполнения обработчиков событий. Все бины и обработчики событий платформы используют значение `order` от 100 до 1000, таким образом, вы можете добавить обработчик событий как до, так и после обработчиков события платформы. Если вы хотите добавить свой обработчик события до обработчиков из платформы, то используйте значение меньше 100.

--

[[ui-events]]
Обработка событий в экранах::
+
--
Обычно, бин `Events` делегирует публикацию события объекту `ApplicationContext`. Для блоков Web Client / Desktop Client это поведение отличается от стандартного, вы можете использовать дополнительный интерфейс для классов событий - `UiEvent`. Это интерфейс-маркер для событий, которые должны быть доставлены в экраны пользовательского интерфейса текущего экземпляра UI (текущей вкладки веб-браузера). Важно отметить, что экземпляры событий, реализующих `UiEvent`, не доставляются в бины Spring и не могут быть обработаны за пределами UI.

Пример класса события:
[source, java]
----
include::{sourcesdir}/common/events_UserRemovedEvent.java[]
----

События публикуются при помощи бина `Events` из контроллера экрана так же, как и из бинов Spring:
[source, java]
----
include::{sourcesdir}/common/events_publish.java[]
----

Чтобы обработать событие, вы должны объявить в экране метод с аннотацией `@EventListener` (Интерфейс `ApplicationListener` не поддерживается):
[source, java]
----
include::{sourcesdir}/common/events_EventListener.java[]
----

Вы можете использовать аннотацию `@Order`, чтобы задать порядок вызова обработчиков события.

Если класс события реализует `UiEvent`, и объект такого события опубликован при помощи бина `Events` из потока UI, то будут вызваны обработчики событий этого типа в открытых на данный момент окнах и фреймах. Обработка событий синхронная. Только экраны и фреймы текущей активной вкладки веб-браузера получат уведомление о событии.
--

[[persistenceHelper]]
==== PersistenceHelper

Вспомогательный класс для получения информации о персистентных сущностях. В отличие от бинов <<persistence,Persistence>> и <<persistenceTools,PersistenceTools>> доступен на всех <<app_tiers,уровнях>> приложения.

Методы `PersistenceHelper`:

*  `isLoaded()` - определяет, загружен ли данный атрибут сущности. Атрибут загружается, если он включен в <<views,представление>>, или если это локальный атрибут и никакое представление не использовалось в процессе загрузки через <<entityManager,EntityManager>> или <<dataManager,DataManager>>. Данный метод поддерживает только непосредственные атрибуты сущностей.

* `isNew()` - определяет, является ли переданный экземпляр только что созданным, т.е. находящимся в состоянии <<entity_states,New>>. Возвращает `true`, также если экземпляр не является персистентной сущностью.

* `isManaged()` - определяет, находится ли переданный экземпляр в состоянии <<entity_states,Managed>>, то есть присоединен к персистентному контексту.

* `isDetached()` - определяет, находится ли переданный экземпляр в состоянии <<entity_states,Detached>>. Возвращает `true`, также если экземпляр не является персистентной сущностью.

* `isSoftDeleted()` - определяет, поддерживает ли переданный класс сущности <<soft_deletion,мягкое удаление>>.

* `getEntityName()` - возвращает имя сущности, заданное в <<entity_annotations,аннотации>> `@Entity`.


[[appContext]]
==== AppContext

`AppContext` - системный класс, в статических полях которого хранятся ссылки на некоторые общие для любого <<app_tiers,блока>> приложения компоненты:

* `ApplicationContext` фреймворка *Spring*

* Набор <<app_properties,свойств приложения>>, загруженных из файлов `app.properties`

* `ThreadLocal` переменная, хранящая экземпляры `SecurityContext`

* Коллекция слушателей жизненного цикла приложения (`AppContext.Listener`)

`AppContext` инициализируется на запуске приложения классами-загрузчиками, специфичными для типа <<app_tiers,блока>> приложения:

* загрузчик Middleware - `AppContextLoader`

* загрузчик Web Client - `WebAppContextLoader`

* загрузчик Web Portal - `PortalAppContextLoader`

* загрузчик Desktop Client - `DesktopAppContextLoader`

`AppContext` может быть использован в прикладном коде для решения следующих задач:

* Регистрации слушателей, срабатывающих после полной инициализации и перед закрытием приложения, например:
+
[source, java]
----
include::{sourcesdir}/common/appcontext_1.java[]
----
+
В момент вызова `applicationStarted()`:

** Полностью инициализированы все <<managed_beans,бины>>, в том числе выполнены их методы `@PostConstruct`.

** Можно использовать статические методы получения бинов `AppBeans.get()`.

** Метод `AppContext.isStarted()` возвращает `true`.

** Метод `AppContext.isReady()` возвращает `false`.

** В блоке Middleware: если свойство приложения <<cuba.automaticDatabaseUpdate,cuba.automaticDatabaseUpdate>> включено, все скрипты обновления БД успешно выполнены.
+
В момент вызова `applicationStopped()`:

** Все бины работоспособны и доступны через статические методы `AppBeans.get()`.

** Метод `AppContext.isStarted()` возвращает `false`.

** Метод `AppContext.isReady()` возвращает `false`.
+
Практический пример использования `AppContext.Listener` см. в <<app_start_recipe,Выполнение кода на старте приложения>>.

* Получения значений <<app_properties,свойств приложения>>, хранимых в файлах `app.properties`, если они недоступны через <<config_interfaces,конфигурационные интерфейсы>>.

* Передачи `SecurityContext` в новые потоки выполнения, см. <<authentication,Аутентификация пользователей>>.

[[app_properties]]
==== Свойства приложения

Свойства приложения − именованные значения различных типов, определяющие всевозможные аспекты конфигурации и функционирования приложения. Свойства приложения широко используются в платформе, и могут применяться в приложении для решения аналогичных задач.

По назначению свойства приложения можно классифицировать следующим образом:

* _Конфигурационные параметры_ - задают наборы конфигурационных файлов и некоторые параметры пользовательского интерфейса, т.е. определяют функциональность приложения. Значения конфигурацинных параметров обычно задаются при разработке приложения.
+
Например: <<cuba.springContextConfig,cuba.springContextConfig>>.

* _Параметры развертывания_ - различные URL для соединения <<app_tiers,блоков>> приложения, тип используемой БД, настройки безопасности и т.д. Значения параметров развертывания обычно зависят от окружения, в котором устанавливается данный экземпляр приложения.
+
Например: <<cuba.connectionUrlList,cuba.connectionUrlList>>, <<cuba.dbmsType,cuba.dbmsType>>, <<cuba.userSessionExpirationTimeoutSec,cuba.userSessionExpirationTimeoutSec>>.

* _Параметры времени выполнения_ - активность аудита, параметры отсылки email и т.д. Параметры времени выполнения могут быть изменены при необходимости во время работы приложения без его перезапуска.
+
Например: <<cuba.entityLog.enabled,cuba.entityLog.enabled>>, <<cuba.email._,cuba.email.smtpHost>>.

[[setting_app_properties]]
Задание свойств приложения::
+
--
Значения свойств приложения могут быть заданы в <<app_properties_db,базе данных>>, в <<app_properties_files,файлах свойств>>, или через системные свойства Java. Кроме того, значение, заданное в файле, переопределяет одноименное значение, заданное в БД. Значение, заданное системным свойством Java, переопределяет одноименные значения из файлов и из БД.

Некоторые свойства не поддерживают установку свойств в базе данных по причине того, что их значения требуются еще то того, как БД становится доступной приложению. Это параметры конфигурации и развертывания. Поэтому их можно устанавливать только в файлах свойств или через системные свойства Java. Параметры времени выполнения всегда могут быть установлены в базе данных (и, возможно, переопределены в файле или системными свойствами).

Как правило, некоторое свойство используется только в одном или нескольких <<app_tiers,блоках>> приложения. Например, <<cuba.persistenceConfig,cuba.persistenceConfig>> необходимо только для Middleware, <<cuba.web.appWindowMode,cuba.web.appWindowMode>> − только для Web Client, а <<cuba.springContextConfig,cuba.springContextConfig>> − для всех блоков. Это означает, что если нужно задать значение некоторому свойству, это необходимо сделать _во всех блоках_, в которых данное свойство используется. Свойства, хранящиеся в БД, доступны всем блокам, поэтому они устанавливаются в одном месте (в таблице базы данных), независимо от того, в каких блоках они используются. Более того, платформа предоставляет экран *Administration > Application Properties* для управления свойствами, хранящимися в БД. Свойства, хранящиеся в файлах, должны быть установлены одновременно в соответствующих файлах блоков приложения.

[TIP]
====
Когда вам необходимо установить значение свойству приложения, определенному платформой, найдите это свойство в <<app_properties_reference,документации>>. Если в документации сказано, что свойство хранится в БД, для установки значения используйте экран *Administration > Application Properties*. В противном случае выясните в документации, какие блоки приложения используют свойство, и установите значение в файлах `app.properties` этих блоков. Например, если в документации сказано, что свойство используется во всех блоках, а ваше приложение состоит из Middleware и Web Client, установите свойство в файле `app.properties` модуля *core* и в файле `web-app.properties` модуля *web*. Параметры развертывания можно также установить вне проекта в <<conf_dir,конфигурационном>> каталоге. Подробнее см. <<app_properties_files>>.
====
--

[[component_app_properties]]
Свойства из компонентов приложения::
+
--
--
<<app_components,Компонент приложения>> может предоставлять свойства путем объявления их в файле <<app-component.xml,app-component.xml>>. Тогда если приложение, использующее компонент, не задает собственное значение свойства, значение будет получено из компонента. Если приложение использует несколько компонентов, предоставляющих одно и то же свойство, значение будет получено из компонента, который является ближайшим предком в иерархии зависимостей между компонентами. Если существует несколько компонентов на одном уровне иерархии, то значение свойства непредсказуемо.

[[additive_app_properties]]
Аддитивные свойства::
+
--
Иногда необходимо получить объединенное значение свойства из всех компонентов, используемых в приложении. Это особенно актуально для конфигурационных параметров, которые позволяют механизмам платформы конфигурировать приложение на основании свойств, предоставляемых компонентами приложения.

Такие свойства должны быть сделаны _аддитивными_ путем добавления знака плюс в начале значения. Этот знак говорит о том, что значение свойства во время выполнения должно быть собрано из компонентов приложения. Например, <<cuba.persistenceConfig,cuba.persistenceConfig>> - аддитивное свойство. В вашем проекте оно задает файл `persistence.xml`, определяющий модель данных проекта. Однако вследствие того, что реальное значение свойства будет также включать файлы `persistence.xml` компонентов приложения, полная модель данных вашего приложения будет включать также и сущности, определенные в компонентах.

Если знак `+` опустить, то значение будет получено только из текущего проекта. Это может быть полезным в случае, если наследование некоторой конфигурации из компонентов не требуется, например, при определении структуры главного меню.
--

[[app_properties_access]]
Программный доступ к свойствам приложения::
+
--
Доступ к свойствам из кода приложения можно получить следующими способами:

* Через <<config_interfaces,конфигурационный интерфейс>>. Если определить свойства с помощью аннотированных методов конфигурационного интерфейса, то код приложения будет иметь типизированный доступ к этим свойствам. Конфигурационные интерфейсы позволяют работать со свойствами всех типов хранения: в базе данных, в файлах и системных свойствах.

* Методом `getProperty()` класса <<appContext,AppContext>>. Если вы установили свойство в файле или в системном свойстве Java, то код приложения может прочитать значение с помощью этого метода. Данный подход имеет следующие недостатки:
** Не поддерживаются свойства, хранящиеся в базе данных.
** В отличие от вызова метода интерфейса, вам необходимо передавать имя свойства в строке.
** В отличие от получения результата нужного типа, вы можете получить только строковое значение свойства.
--

[[app_properties_files]]
===== Хранение свойств в файлах

Свойства, определяющие конфигурацию и параметры развертывания, задаются в специальных файлах свойств, имеющих имя вида `++*app.properties++`. Каждый <<app_tiers,блок>> приложения имеет набор таких файлов, который определяется следующим образом:

* Для блоков, являющихся веб-приложениями (Middleware, Web Client, Web Portal) набор файлов свойств задается в `web.xml` в параметре `appPropertiesConfig`.

* Для блока Desktop Client основной способ задания набора файлов свойств − переопределение в приложении метода `getDefaultAppPropertiesConfig()` в классе-наследнике `com.haulmont.cuba.desktop.App`.

Например, набор файлов свойств блока Middleware задается в файле `web/WEB-INF/web.xml` модуля *core*, и выглядит следующим образом:

[source, xml]
----
<context-param>
    <param-name>appPropertiesConfig</param-name>
    <param-value>
        classpath:com/company/sample/app.properties
        /WEB-INF/local.app.properties
        "file:${catalina.base}/conf/app-core/local.app.properties"
    </param-value>
</context-param>
----

Здесь префикс `classpath:` означает, что данный файл нужно искать в Java classpath, префикс `file:` − в файловой системе. Путь без такого префикса означает путь внутри веб-приложения относительно его корня. Возможно использование системных свойств Java, в данном случае это `catalina.home` − путь к каталогу установки Tomcat.

Порядок перечисления файлов важен, так как значения, указанные в каждом последующем файле, заменяют значения одноименных свойств, заданные в предыдущих файлах.

Последний файл в приведенном наборе − `local.app.properties`. Он может использоваться для переопределения свойств приложения при развертывании. Если этого файла нет, он игнорируется. Если же во время инсталляции системы требуется переопределение некоторых параметров (как правило, различных URL), достаточно создать этот файл и поместить в него переопределяемые свойства. При последующих обновлениях системы такой файл с локальными настройками легко сохранить. В разделе <<tomcat_in_prod>> приведен пример использования файла `local.app.properties`.

Аналогом `local.app.properties` для Desktop Client служат аргументы командной строки запуска JVM. Загрузчик свойств данного блока воспринимает все аргументы, содержащие знак "=", как пары ключ-значение, и заменяет ими соответствующие свойства приложения, заданные в файлах `app.properties`.

[TIP]
====
Правила задания информации в файлах `*.properties`:

* Кодировка файла - `UTF-8`

* Ключ может состоять из латинских букв, цифр, точек и знаков подчеркивания

* Значение пишется после знака равно (`=`)

* Значение не нужно брать в кавычки " или '

* Файловые пути записываются либо в UNIX-виде (`/opt/haulmont/`), либо в Windows-виде (`c:\\haulmont\\`)

* Возможно использование кодов `\n \t \r`. Символ `\` является зарезервированным, для вставки в значение экранируется сам собой (`\\`). Подробнее см.: link:$$http://docs.oracle.com/javase/tutorial/java/data/characters.html$$[http://docs.oracle.com/javase/tutorial/java/data/characters.html]

* Для ввода значения в нескольких строках файла используйте символ `\` в конце строки, для того чтобы данное значение продолжалось на следующей строке.

====

[[app_properties_db]]
===== Хранение свойств в базе данных

Свойства приложения, представляющие собой параметры времени выполнения, хранятся в таблице `SYS_CONFIG` базы данных.

Такие свойства имеют следующие особенности:

* Так как значение свойства хранится в базе данных, оно задается в одном месте, независимо от того, в каких блоках приложения оно используется.

* Значение может быть изменено и сохранено во время работы приложения следующими способами:
** Через экран *Administration > Application Properties*.
** Через JMX бин <<configStorageMBean,ConfigStorageMBean>>.
** Если <<config_interfaces,конфигурационный интерфейс>>, содержащий это свойство, имеет соответствующий setter, то свойство может изменено кодом приложения.

* Значение свойства может быть переопределено для конкретного блока приложения в его файле `app.properties` или одноименным системным свойством Java.

Следует иметь в виду, что на клиентском уровне чтение свойства, хранящегося в БД, приводит к запросу к Middleware, что менее эффективно, чем чтение свойства из локального файла `app.properties`. Для уменьшения количества таких запросов клиент кэширует все свойства, хранящиеся в БД, на время жизни экземпляра реализации конфигурационного интерфейса. Поэтому если, например, в некотором экране UI необходимо несколько раз обратиться к свойствам одного конфигурационного интерфейса, лучше получить ссылку на него при инициализации экрана, и сохранить в поле для последующих обращений к одному и тому же экземпляру.

[[config_interfaces]]
===== Конфигурационные интерфейсы

Данный механизм позволяет работать со свойствами приложения через методы Java-интерфейсов, что дает следующие преимущества:

* Типизированность - прикладной код работает с нужными типами (String, Boolean, Integer и пр.), а не только со строками.

* В прикладном коде вместо строковых идентификаторов свойств используются методы интерфейсов, имена которых проверяются компилятором и подсказываются средой разработки.

Пример получения значения таймаута транзакции в блоке Middleware:

[source, java]
----
include::{sourcesdir}/common/configinterface_1.java[]
----

При невозможности инжекции можно получить ссылку на конфигурационный интерфейс через <<configuration,Configuration>>:

[source, java]
----
include::{sourcesdir}/common/configinterface_2.java[]
----

[WARNING]
====
Конфигурационные интерфейсы не являются нормальными бинами Spring, не пытайтесь получить их через `AppBeans.get()` - только непосредственной инжекцией самого интерфейса или через `Configuration.getConfig()`.
====

[[config_interface_usage]]
====== Использование

Для создания конфигурационного интерфейса необходимо:

* Создать интерфейс, унаследованный от `com.haulmont.cuba.core.config.Config` (не путать с классом сущности `com.haulmont.cuba.core.entity.Config`)

* Добавить интерфейсу аннотацию `@Source` для указания источника (способа хранения) параметров:

** `SourceType.SYSTEM` - значение свойства будет взято из системных свойств данной JVM, т.е. методом `System.getProperty()`.

** `SourceType.APP` - значение свойства будет взято из файлов `app.properties`.

** `SourceType.DATABASE` - значение свойства будет взято из базы данных.

* Создать методы доступа к свойству (getter / setter). Если значение свойства не предполагается изменять из кода приложения, метод доступа на запись не нужен. Тип, вовращаемый методом доступа на чтение, определяет тип свойства. Возможные типы рассмотрены <<config_interface_property_types,ниже>>.

* Добавить методу доступа на чтение аннотацию `@Property`, определяющую имя свойства.

* Опционально аннотацию `@Source` можно задать для отдельного свойства в интерфейсе, если его источник отличается от заданного для всего интерфейса.

Например:

[source, java]
----
include::{sourcesdir}/common/configinterface_3.java[]
----

Создавать класс реализации конфигурационного интерфейса не нужно - при получении ссылки на интерфейс инжекцией или через <<configuration,Configuration>> будет автоматически создан необходимый прокси-объект.

[[config_interface_property_types]]
====== Типы свойств

"Из коробки" платформой поддерживаются следующие типы свойств:

* `String`, простые типы и их объектные обертки (`boolean`, `Boolean`, `int`, `Integer`, etc.).

* Перечисления (`enum`). Значение свойства сохраняется в файле или БД в виде имени значения перечисления.
+
Если перечисление реализует интерфейс `EnumClass` и имеет статический метод `fromId()` для получения значения по идентификатору, с помощью аннотации `@EnumStore` можно задать хранение значения в виде идентификатора. Например:
+
[source, java]
----
include::{sourcesdir}/common/configinterface_8.java[]
----

* Классы персистентных <<data_model,сущностей>>. При обращении к свойству типа сущности происходит загрузка из БД экземпляра, заданного значением свойства.

Для поддержки произвольного типа необходимо реализовать классы `TypeStringify` и `TypeFactory` для преобразования значения в строку и из нее, и указать эти классы для свойства с помощью аннотаций `@Stringify` и `@Factory`.

Рассмотрим этот процесс на примере типа `UUID`.

* Создаем класс `com.haulmont.cuba.core.config.type.UuidTypeFactory` унаследованный от `com.haulmont.cuba.core.config.type.TypeFactory` и реализуем в нем метод:
+
[source, java]
----
include::{sourcesdir}/common/configinterface_4.java[]
----

* `TypeStringify` создавать не нужно, т.к. по умолчанию будет использован метод `toString()` − в данном случае он нам подходит.

* Аннотируем свойство в конфигурационном интерфейсе:
+
[source, java]
----
include::{sourcesdir}/common/configinterface_5.java[]
----

В платформе определены реализации `TypeFactory` для следующих типов:

* `UUID` - `UuidTypeFactory`, описано выше.

* `java.util.Date` - `DateFactory`. Значение даты должно быть указано в формате `yyyy-MM-dd HH:mm:ss.SSS`, например:
+
[source, properties]
----
cuba.test.dateProp = 2013-12-12 00:00:00.000
----

* `List<Integer>` (список целых чисел) - `IntegerListTypeFactory`. Значение свойства должно быть указано в виде списка чисел, разделенных пробелами, например:
+
[source, properties]
----
cuba.test.integerListProp = 1 2 3
----

* `List<String>` (список строк) - `StringListTypeFactory`. Значение свойства должно быть указано в виде списка строк, разделенных символом "|", например:
+
[source, properties]
----
cuba.test.stringListProp = aaa|bbb|ccc
----

[[config_interface_default_values]]
====== Значения по умолчанию

Для свойств конфигурационных интерфейсов могут быть заданы значения по умолчанию. Эти значения будут возвращаться вместо `null`, если данный параметр не задан в месте хранения - в БД или в файле `app.properties`.

Значение по умолчанию может быть задано в виде строки с помощью аннотации `@Default`, либо в виде конкретного типа с помощью других аннотаций пакета `com.haulmont.cuba.core.config.defaults`:

[source, java]
----
include::{sourcesdir}/common/configinterface_6.java[]
----

Для сущностей значение по умолчанию задается строкой вида `++{entity_name}-{id}-{optional_view_name}++`, например:

[source, java]
----
include::{sourcesdir}/common/configinterface_7.java[]
----

[[localization]]
==== Локализация сообщений

Приложение на основе платформы CUBA поддерживает локализацию сообщений, то есть вывод всех элементов пользовательского интерфейса на языке, выбранном пользователем.

Возможности выбора языка пользователем определяются комбинацией свойств приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>> и <<cuba.availableLocales,cuba.availableLocales>>.

Для того, чтобы некоторое сообщение могло быть локализовано, т.е. представлено пользователю на нужном языке, его необходимо поместить в так называемый _пакет сообщений_. Ниже рассмотрены принципы работы механизма локализации и правила создания сообщений. 

<<getting_messages,>> содержит информацию о способах получения локализованных сообщений в различных компонентах системы.

[[message_packs]]
===== Пакеты сообщений

Пакет сообщений представляет собой набор файлов свойств с именами вида `messages{++_XX++}.properties`, расположенных в одном Java-пакете. Суффикс `XX` определяет язык, для которого в данном файле содержатся сообщения, и соответствует коду языка в `Locale.getLanguage()`. Возможно также использование остальных атрибутов `Locale`, например, `country`. В этом случая файл пакета будет иметь вид `messages{_XX_YY}.properties`. Один из файлов пакета может быть без суффикса языка - это _файл по умолчанию_. Именем пакета сообщений считается имя Java-пакета, в котором расположены файлы пакета.

Рассмотрим пример:

[source, plain]
----
/com/abc/sales/gui/customer/messages.properties
/com/abc/sales/gui/customer/messages_fr.properties
/com/abc/sales/gui/customer/messages_ru.properties
----

Данный пакет состоит из 3-х файлов - один для русского языка, один для французского, и один по умолчанию. Имя пакета - `com.abc.sales.gui.customer` 

Файлы сообщений содержат пары ключ-значение, где ключ - это идентификатор сообщения, на который ссылается код приложения, а значение - само сообщение на языке данного файла. Правила задания пар аналогичны правилам файлов свойств `java.util.Properties`, со следующими особенностями:

* Кодировка файла - обязательно `UTF-8`

* Поддерживается включение других пакетов сообщений с помощью ключа `@include`, в том числе нескольких сразу - перечислением через запятую. При этом если некоторый ключ сообщения встречается и во включаемом пакете, и в текущем, будет использовано сообщение из текущего. Пример включения пакетов:
+
[source, plain]
----
@include=com.haulmont.cuba.web, com.abc.sales.web

someMessage=Some Message
...
----

Получение сообщений из пакетов производится с помощью методов интерфейса <<messages,Messages>> по следующим правилам:

* Сначала производится поиск в <<conf_dir,конфигурационном каталоге>> приложения

** Ищется файл `messages++_XX++.properties` в каталоге, задаваемом именем пакета сообщений, где `XX` - код требуемого языка

** Если такого файла нет, в этом же каталоге ищется файл по умолчанию `messages.properties`

** Если найден или файл нужного языка, или файл по умолчанию, он загружается вместе со всеми `@include`, и в нем ищется ключ сообщения

** Если файл не найден, либо нужный ключ в нем отсутствует, производится смена каталога на родительский, и процедура поиска повторяется. И так до достижения корня конфигурационного каталога.

* Если в конфигурационном каталоге сообщение не найдено, производится поиск в classpath по такому же алгоритму.

* Если сообщение найдено, оно кэшируется и возвращается. Если не найдено - кэшируется факт отсутствия сообщения и возвращается ключ, который был передан для поиска. Таким образом, сложная процедура поиска выполняется только один раз, в дальнейшем результат загружается из локального для блока приложения кэша.

[TIP]
====
Рекомендуется организовывать пакеты сообщений следующим образом:

* Если приложение не предполагает интернационализации, то можно не использовать пакеты и включать строки сообщений прямо в код приложения, либо пользоваться файлами по умолчанию `messages.properties` для отделения ресурсов от кода.

* Если приложение интернациональное, логично файлы по умолчанию использовать для языка основной аудитории приложения, либо для английского языка. Именно сообщения из файлов по умолчанию будут показаны пользователю, если сообщений для нужного языка не найдено.
====

[[main_message_pack]]
===== Главный пакет сообщений

Каждый стандартный <<app_tiers,блок>> приложения определяет для себя один _главный_ пакет сообщений. Для блоков клиентского уровня этот пакет содержит названия пунктов главного меню и общих элементов UI (например, названия кнопок *OK* и *Cancel*). Для всех блоков приложения, включая Middleware, главный пакет определяет форматы преобразований <<datatype,Datatype>>.

Для указания главного пакета сообщений используется свойство приложения <<cuba.mainMessagePack,cuba.mainMessagePack>>. Значением свойства может быть либо один пакет, либо список пакетов, разделенный пробелами. Например:

[source, properties]
----
cuba.mainMessagePack=com.haulmont.cuba.web com.abc.sales.web
----

В данном случае сообщения, заданные во втором пакете списка, будут перекрывать сообщения из первого пакета. Таким образом, в проекте приложения можно переопределять сообщения, заданные в пакетах <<app_components,компонентов приложения>>.

Сообщения, заданные в пакетах базовых проектов CUBA, также можно переопределять в главном пакете сообщений проекта:

[source, plain]
----
com.haulmont.cuba.gui.backgroundwork/backgroundWorkProgress.timeoutMessage = Новое сообщение об ошибке
----

[[entity_localization]]
===== Локализация названий сущностей и атрибутов

Для отображения в UI локализованных названий сущностей и их атрибутов необходимо создать специальные пакеты сообщений в тех же Java-пакетах, что и сами сущности. Формат файлов сообщений должен быть следующим:

* Ключ названия сущности - простое имя класса (без пакета)

* Ключ названия атрибута - простое имя класса, затем через точку имя атрибута

Пример русской локализации сущности `com.abc.sales.entity.Customer` - файл `/com/abc/sales/entity/messages_ru.properties`:

[source, plain]
----
Customer=Покупатель
Customer.name=Имя
Customer.email=Email

Order=Заказ
Order.customer=Покупатель
Order.date=Дата
Order.amount=Сумма
----

Такие пакеты сообщений, как правило, используются неявно для разработчика, например, визуальными компонентами <<gui_Table,Table>> и <<gui_FieldGroup,FieldGroup>>. Кроме того, названия сущностей и атрибутов могут быть также получены следующими методами:

* программно - методами <<messageTools,MessageTools>> `getEntityCaption()`, `getPropertyCaption()`

* в XML-дескрипторе экрана - указанием ссылки на сообщение по правилам `MessageTools.loadString`: `++msg://{entity_package}/{key}++`, например,
+
[source, xml]
----
caption="msg://com.abc.sales.entity/Customer.name"
----

[[enum_localization]]
===== Локализация enum

Для локализации названий и значений перечислений необходимо в пакет сообщений, находящийся в Java-пакете класса перечисления добавить сообщения со следующими ключами:

* Ключ названия перечисления - простое имя класса (без пакета)

* Ключ значения - простое имя класса, затем через точку имя значения

Например, для перечисления 

[source, java]
----
package com.abc.sales;

public enum CustomerGrade { PREMIUM, HIGH, STANDARD }
----

файл русской локализации `/com/abc/sales/messages_ru.properties` должен содержать строки:

[source, plain]
----
CustomerGrade=Уровень покупателя
CustomerGrade.PREMIUM=Премиум
CustomerGrade.HIGH=Высокий
CustomerGrade.STANDARD=Стандартный
----

Локализованные значения перечислений автоматически используются различными визуальными компонентами, например, <<gui_LookupField,LookupField>>. Для программного получения локализованного значения перечисления можно использовать метод `getMessage()` интерфейса <<messages,Messages>>, просто передавая в него экземпляр `enum`.

[[authentication]]
==== Аутентификация пользователей

В данном разделе рассмотрены некоторые аспекты управления доступом с точки зрения разработчика приложения. Для получения полной информации о возможностях и настройке ограничения доступа пользователей к данным см. <<security_subsystem,Подсистема безопасности>>.

[[userSession]]
===== UserSession

Основной элемент подсистемы контроля доступа в CUBA-приложении - пользовательская сессия. Это объект класса `UserSession`, который ассоциирован с аутентифицированным в данный момент в системе пользователем, и содержит информацию о правах доступа пользователя к данным. Объект текущей сессии может быть получен в любом <<app_tiers,блоке>> приложения через интерфейс инфраструктуры <<userSessionSource,UserSessionSource>>.

Пользовательская сессия создается на Middleware при выполнении метода `AuthenticationManager.login()` после аутентификации пользователя по переданному имени и паролю. Объект `UserSession` затем кэшируется в данном блоке Middleware, и возвращается на клиентский уровень. При работе в кластере объект сессии реплицируется на соседние узлы кластера Middleware. Клиентский блок, получив объект сессии, также сохраняет его у себя, так или иначе ассоциируя с активным пользователем (например, в HTTP сессии). Далее все вызовы Middleware для данного пользователя сопровождаются передачей идентификатора сессии (типа `UUID`), причем прикладному коду не нужно об этом заботиться - идентификатор сессии передается автоматически, независимо от сигнатуры вызываемых методов среднего слоя. Обработка вызовов клиентов на Middleware начинается с извлечения из кэша сессии по полученному идентификатору и установки ее в потоке выполнения. Объект сессии удаляется из кэша при вызове метода `LoginService.logout()`, либо при истечении времени бездействия, определяемого свойством приложения <<cuba.userSessionExpirationTimeoutSec,cuba.userSessionExpirationTimeoutSec>>.

Таким образом, идентификатор сессии, создаваемой при входе пользователя в систему, служит для аутентификации пользователя при каждом вызове среднего слоя.

Объект `UserSession` содержит также методы для _авторизации_ текущего пользователя, т.е. проверки его прав на объекты системы: `isScreenPermitted()`, `isEntityOpPermitted()`, `isEntityAttrPermitted()`, `isSpecificPermitted()`.

С объектом `UserSession` могут быть ассоциированы именованные атрибуты произвольного сериализуемого типа. Атрибуты устанавливаются методом `setAttribute()` и возвращаются методом `getAttribute()`. Последний может также возвращать следующие параметры сессии, как если бы они были атрибутами:

* `userId` - ID текущего зарегистрированного или замещенного пользователя;

* `userLogin` - логин текущего зарегистрированного или <<user_substitution,замещенного>> пользователя в нижнем регистре.

Атрибуты реплицируются в кластере Middleware так же, как и все остальные данные сессии.

[[login]]
===== Вход в систему

Платформа предоставляет встроенные механизмы аутентификации, функциональность которых может быть расширена в приложениях. Они включают в себя различные схемы аутентификации, такие как вход по паролю, функциональность "Запомнить меня", доверенный и анонимный вход в систему.

Платформа включает следующие механизмы среднего слоя:

- `AuthenticationManager` реализованный классом `AuthenticationManagerBean`
- Реализации интерфейса `AuthenticationProvider`
- `AuthenticationService` реализованный классом `AuthenticationServiceBean`
- `UserSessionLog` - см. <<userSession_log,журналирование пользовательских сессий>>.

.Механизмы аутентификации среднего слоя
image::MiddlewareAuthenticationStructure.png[align="center"]

Также, платформа включает следующие дополнительные компоненты:

- `TrustedClientService` реализованный классом `TrustedClientServiceBean` - предоставляет анонимную/системную сессию для доверенных приложений-клиентов.
- `AnonymousSessionHolder` - создаёт и хранит анонимную сессю для доверенных приложений-клиентов.
- `UserCredentialsChecker` - проверяет, могут ли быть использованы переданные `Credentials`, например, для защиты от атак типа brute-force.
- `UserAccessChecker` - проверяет, может ли пользователь выполнять вход из данного контекста, например, в REST API или с указанного IP адреса.

Основной интерфейс аутентификации - `AuthenticationManager`, включающий 4 метода:

[source, java]
----
include::{sourcesdir}/common/authenticationManager.java[]
----

Здесь есть два метода с похожей ответственностью: `authentucate()` и `login()`. Оба метода проверяют, являются ли переданные аутентификационные данные валидными и соответствуют ли они активному пользователю системы, затем возвращают объект `AuthenticationDetails`. Основное отличие в работе этих методов в том, что метод `login()` активирует сессию пользователя, так что она может использоваться в дальнейшем для вызова сервисов.

Объект `Credentials` представляет собой набор аутентификационных данных. Платформа поставляет несколько типов аутентификационных данных:

Доступные на всех слоях:

* `LoginPasswordCredentials`
* `RememberMeCredentials`
* `TrustedClientCredentials`

Доступные только на среднем слое:

* `SystemUserCredentials`
* `AnonymousUserCredentials`

Методы login / authenticate `AuthenticationManager`  возвращают объект `AuthenticationDetails`, который содержит объект <<userSession,UserSession>>. Этот объект может быть использован для проверки дополнительных разрешений, чтения свойств объекта *User* и атрибутов сессии. В платформе есть встроенная реализация интерфейса `AuthenticationDetails` - *SimpleAuthenticationDetails*, который хранит только объект сессии пользователя, приложения могут предоставлять свою реализацию `AuthenticationDetails` с дополнительной инфомацией для приложений-клиентов.

*AuthenticationManager* может выполнить метод *authenticate()* с одним из следующих результатов:

 - вернуть объект `AuthenticationDetails` если он подтверждает, что переданные аутентификационные данные верны и соответствуют активному пользователю системы.
 - выбросить `LoginException` если невозможно аутентифицировать пользователя, неверны аутентификационные данные или если пользователю запрещён доступ к системе.
 - выбросить `UnsupportedCredentialsException` если переданный тип аутентификационных данных не поддерживается системой.

Реализация `AuthenticationManager` по умолчанию - `AuthenticationManagerBean`, который делегирует аутентификацию цепочке экземпляров `AuthenticationProvider`. `AuthenticationProvider` - это модуль аутентификации, который может обрабатывать объекты `Credentials` определённого типа. `AuthenticationProvider` также имеет специальный метод `supports()` позволяющий узнать поддерживается ли переданный тип аутентификационных данных.

.Стандартный процесс входа пользователя
image::LoginProcedure.png[align="center"]

Стандартный процесс входа пользователя:

* пользователь вводит свой логин и пароль

* клиентский блок приложения хэширует пароль, вызывая метод `getPlainHash()` бина `PasswordEncryption` и вызывает на Middleware метод `LoginService.login()`, передавая ему логин пользователя и хэш пароля.

* `Connection` создаёт объект `Credentials` и вызывает метод `login()` сервиса `AuthenticationService`.

* `AuthenticationService` делегирует выполнение бину `AuthenticationManager`, который использует цепочку объектов `AuthenticationProvider`. В этой цепочке имеется бин `LoginPasswordAuthenticationProvider`, поддерживающий аутентификационные данные типа `LoginPasswordCredentials`. Он загружает объект `User` по полученному логину, хэширует полученный хэш пароля повторно, используя в качестве соли идентификатор пользователя, и сравнивает полученный хэш с сохраненным в БД хэшем пароля. В случае несовпадения выбрасывается исключение `LoginException`.

* После успешной аутентификации в созданный экземпляр <<userSession,UserSession>> загружаются все параметры доступа данного пользователя: список ролей, права, ограничения и атрибуты сессии.

* Если <<userSession_log,журналирование пользовательских сессий>> активировано, в базу данных сохраняется запись с информацией о текущей сессии.

Алгоритм хэширования паролей реализуется бином типа `EncryptionModule` и задается в свойстве приложения <<cuba.passwordEncryptionModule,cuba.passwordEncryptionModule>>. По умолчанию - SHA-1.

[[built-in-authentication-providers]]
Встроенные провайдеры аутентификации::
+
--
Платформа включает следующие реализации интерфейса `AuthenticationProvider`:

- `LoginPasswordAuthenticationProvider`
- `RememberMeAuthenticationProvider`
- `TrustedClientAuthenticationProvider`
- `SystemAuthenticationProvider`
- `AnonymousAuthenticationProvider`

Все реализации загружают пользователя из базы данных, проверяют переданные аутентификационные данные и создают неактивный экземпляр пользовательской сессии при помощи `UserSessionManager`. Этот экземпляр может стать активным позднее, если вызывается метод `AuthenticationManager.login()`.

Бины `LoginPasswordAuthenticationProvider`, `RememberMeAuthenticationProvider` и `TrustedClientAuthenticationProvider` используют дополнительные подключаемые проверки: бины, реализующие интерфейс `UserAccessChecker`. Если по крайней мере одна из таких проверок выбрасывает исключение `LoginException`, то аутентификация не выполняется и исключение `LoginException` передаётся вызывающему коду.

Кроме того, `LoginPasswordAuthenticationProvider` и `RememberMeAuthenticationProvider` проверяют аутентификационные данные при помощи бинов *UserCredentialsChecker*. Имеется одна встроенная реализация этого интерфейса - *BruteForceUserCredentialsChecker*, который проверяет, пытается ли пользователь подобрать верные аутентификационные данные при помощи атаки brute-force.
--

[[login-exceptions]]
Исключения::
+
--
`AuthenticationManager` и `AuthenticationProvider` могут выбрасывать исключение *LoginException* или одного из его наследников из методов `authenticate()` и `login()`. Исключение *UnsupportedCredentialsException* выбрасывается, если переданный объект аутентификационных данных `Credentials` не может быть обработан имеющимися `AuthenticationProvider`.

См. следующие классы исключений:

- `UnsupportedCredentialsException`
- `LoginException`
  - `AccountLockedException`
  - `UserIpRestrictedException`
  - `RestApiAccessDeniedException`

--

[[login-events]]
События::
+
--
Стандартная реализация `AuthenticationManager` - `AuthenticationManagerBean` публикует следующие <<events, события>> во время аутентификации / входа пользователей:

- `BeforeAuthenticationEvent` / `AfterAuthenticationEvent`
- `BeforeLoginEvent` / `AfterLoginEvent`
- `AuthenticationSuccessEvent` / `AuthenticationFailureEvent`
- `UserLoggedInEvent` / `UserLoggedOutEvent`
- `UserSubstitutedEvent`

Бины Spring на среднем слое приложения могут обрабатывать эти события при помощи механизма подписок ```@EventListener```:

[source, java]
----
include::{sourcesdir}/common/loginEventListener.java[]
----

Обработчики всех событий, перечисленных выше (кроме `AfterLoginEvent`, `UserSubstitutedEvent` и `UserLoggedInEvent`), могут выбросить `LoginException`, чтобы прервать процесс аутентификации / входа пользователя.

Например, мы можем реализовать механизм режима обслуживания системы, который позволит запретить вход в систему на время её обслуживания.

[source, java]
----
include::{sourcesdir}/common/maintenanceModeValve.java[]
----

--

[[login-extension-points]]
Точки расширения::
+
--
Вы можете расширить механизм аутентификации, используя следующие точки расширения:

- `AuthenticationService` - заменить существующий `AuthenticationServiceBean`.
- `AuthenticationManager` - заменить существующий `AuthenticationManagerBean`.
- `AuthenticationProvider` - реализовать новый или заменить существующий бин `AuthenticationProvider`.
- Events - реализовать обработчик одного из доступных событий.

Вы можете заменить существующие бины, задействуя механизмы Spring Framework, например, зарегистрировав новую реализацию в XML конфигурации Spring модуля *core*:

[source, xml]
----
<bean id="cuba_LoginPasswordAuthenticationProvider"
      class="com.company.authext.core.CustomLoginPasswordAuthenticationProvider"/>
----

[source, java]
----
include::{sourcesdir}/common/customAuthenticationProvider.java[]
----

Обработчики событий могут быть упорядочены при помощи аннотации `@Order`. Все бины и обработчики событий платформы используют значение `order` из диапазона 100 и 1000, что позволяет добавлять обработчики на уровне проект как до, так и после кода платформы. Если вы хотите добавить свой обработчик до обработчиков/бинов платформы - используйте значение меньше 100.

Задание `order` для обработчика события:
[source, java]
----
include::{sourcesdir}/common/eventListenerOrder.java[]
----

Бины `AuthenticationProvider` могут реализовать интерфейс *Ordered* и метод `getOrder()` для определения очерёдности исполнения.
[source, java]
----
include::{sourcesdir}/common/authProviderOrdered.java[]
----

--

[[login-additional-features]]
Дополнительные возможности::
+
--
* В платформе имеется механизм защиты от взлома пароля методом перебора. Для его включения необходимо установить свойство приложения <<cuba.bruteForceProtection.enabled,cuba.bruteForceProtection.enabled>> для блока Middleware. В этом случае после определенного количества неуспешных попыток входа для определенного имени пользователя с определенного IP-адреса вход для пары логин + IP-адрес блокируется на некоторое время. Допустимое количество попыток входа для пары логин + IP-адрес определяется свойством приложения <<cuba.bruteForceProtection.maxLoginAttemptsNumber,cuba.bruteForceProtection.maxLoginAttemptsNumber>> (по умолчанию 5). Интервал блокировки пользователя в секундах задается свойством <<cuba.bruteForceProtection.blockIntervalSec,cuba.bruteForceProtection.blockIntervalSec>> (по умолчанию 60).

* Возможен вариант, когда пароль пользователя (точнее, хэш пароля) не хранится в базе данных, а проверяется внешними средствами, например, путем интеграции с *ActiveDirectory*. В этом случае фактически аутентификацию выполняет клиентский блок, а Middleware "доверяет" клиенту, создавая сессию по одному только логину пользователя без пароля методом `LoginService.loginTrusted()`. Метод `loginTrusted()` требует выполнения следующих условия:

    - клиентский блок должен передать так называемый доверенный пароль, задаваемый на Middleware и на клиентском блоке свойством приложения <<cuba.trustedClientPassword,cuba.trustedClientPassword>>

    - IP-адрес клиентского блока должен быть в списке, задаваемой свойством приложения <<cuba.trustedClientPermittedIpList,cuba.trustedClientPermittedIpList>>

* Вход в систему требуется также для автоматических процессов, запускаемых по расписанию, а также при подключении к бинам Middleware через JMX-интерфейс. Строго говоря, такие действия считаются административными и не требуют аутентификации до тех пор, пока не выполняется каких-либо изменений сущностей в базе данных. При записи сущностей в БД требуется проставить логин пользователя, который выполнил изменения, поэтому для работы таких процессов должен быть указан пользователь, от лица которого выполняются изменения.
+
Дополнительным плюсом входа в систему для автоматического процесса и для JMX-вызова является то, что вывод в журнал сообщений от логгеров сопровождается указанием логина текущего пользователя, если пользовательская сессия установлена в потоке выполнения. Это упрощает поиск сообщений от конкретного процесса при разборе журнала.
+
Вход в систему для процессов внутри Middleware выполняется вызовом `AuthenticationManager.loginSystem()` с передачей объекта `SystemUserCredentials` , содержащего логин пользователя (без пароля), от имени которого будет работать данный процесс. В результате создается объект <<userSession,UserSession>>, который будет закэширован в данном блоке Middleware и не будет реплицироваться в кластере.

Более подробно аутентификация процессов внутри Middleware рассмотрена в разделе <<system_authentication,Системная аутентификация>>.
--

[[login-obsolete]]
Устаревшие механизмы::
+
--
Следующие компоненты считаются устаревшими:

- `LoginService` делегирует исполнение методов сервису `AuthenticationService`
- `LoginWorker` делегирует исполнение методов бину `AuthenticationManager`

Не используйте эти компоненты в коде приложений. Они будут удалены в одной из следующих версий платформы.
--

[[securityContext]]
===== SecurityContext

Экземпляр класса `SecurityContext` хранит информацию о пользовательской сессии для текущего потока выполнения. Он создается и передается в метод `AppContext.setSecurityContext()` в следующие моменты:

* для блоков Web Client и Web Portal - в начале обработки каждого HTTP-запроса от пользовательского браузера.

* для блока Middleware - в начале обработки каждого запроса от клиентского уровня и от <<scheduled_tasks_cuba,назначенных заданий CUBA>>.

* для блока Desktop Client - один раз после входа пользователя, так как десктопное приложение является однопользовательским.

По окончании выполнения запроса в первых двух случаях `SecurityContext` удаляется из потока выполнения.

При создании прикладным кодом нового потока выполнения в него необходимо передать текущий экземпляр `SecurityContext`, например:

[source, java]
----
include::{sourcesdir}/common/securitycontext_1.java[]
----

То же самое можно сделать, используя обертки `SecurityContextAwareRunnable` или `SecurityContextAwareCallable`, например:

[source, java]
----
include::{sourcesdir}/common/securitycontext_2.java[]
----

[source, java]
----
include::{sourcesdir}/common/securitycontext_3.java[]
----

[[exception_handling]]
==== Обработка исключений

В данном разделе рассмотрены различные аспекты генерации и обработки исключений в CUBA-приложениях.

[[exception_classes]]
===== Классы исключений

При создании собственных классов исключений следует придерживаться следующих правил:

* Если исключение является нормальной частью бизнес-логики и при его возникновении требуется предпринимать некоторые нетривиальные действия, то класс исключения следует делать декларируемым (наследником `Exception`). Обработка таких исключений производится вызывающим кодом.

* Если исключение сигнализирует об ошибочной ситуации, и реакцией на него должно быть прерывание хода выполнения и простое действие типа отображения информации об ошибке пользователю, то класс исключения следует делать недекларируемым (наследником `RuntimeException`). Обработка таких исключений производится специальными классами-обработчиками, зарегистрированными в клиентских блоках приложения.

* Если исключение выбрасывается и обрабатывается в рамках одного <<app_tiers,блока>> приложения, то класс исключения следует объявлять в соответствующем <<app_modules,модуле>>. Если же исключение выбрасывается на Middleware, а обрабатывается на клиентском уровне, то класс исключения необходимо объявлять в модуле *global*.

Платформа содержит специальный класс недекларируемого исключения `SilentException`, который можно использовать для прерывания хода выполнения без выдачи каких-либо сообщений пользователю или в лог. `SilentException` объявлен в модуле *global*, поэтому доступен как на Middleware, так и в клиентских блоках.

[[remoteException]]
===== Передача исключений Middleware

Если при выполнении запроса от клиента на Middleware возникает исключение, выполнение прерывается и на клиента возвращается объект исключения, как правило, включающий цепочку порождающих друг друга исключений. Так как цепочка исключений может содержать классы, недоступные клиентскому блоку (например, исключения JDBC-драйвера), на клиента передается не сама эта цепочка, а ее представление внутри специального создаваемого исключения `RemoteException`. 

Информация об исключениях-причинах сохраняется в виде списка объектов `RemoteException.Cause`. Каждый объект `Cause` хранит обязательно имя класса исключения и его сообщение. Кроме того, если класс исключения "поддерживается клиентом", то `Cause` содержит также и сам объект исключения. Это дает возможность передать на клиента информацию в полях исключения. 

Класс исключения, объекты которого нужно передавать на клиентский уровень именно в виде Java-объектов, нужно аннотировать `@SupportedByClient`, например: 

[source, java]
----
include::{sourcesdir}/common/mwexception_1.java[]
----

Таким образом, при возникновении на Middleware исключения, не аннотированного `@SupportedByClient`, вызывающий клиентский код получит `RemoteException`, внутри которого будет находиться исходное исключение в виде строки. Если же исходное исключение аннотировано `@SupportedByClient`, то вызывающий код получит именно его. Это дает возможность в прикладном коде организовывать обработку декларируемых <<services,сервисами>> Middleware исключений традиционным образом - с помощью блоков try/catch.

Следует иметь в виду, что чтобы поддерживаемое клиентом исключение было действительно передано на клиента в виде объекта, оно не должно содержать внутри себя в цепочке `getCause()` неподдерживаемых исключений. Поэтому если вы создаете на Middleware экземпляр исключения и хотите передать его на клиента, указывайте для него параметр `cause` только если вы уверены, что он содержит только исключения, известные клиенту.

Упаковку объектов исключений в `RemoteException` перед передачей на клиентский уровень выполняет перехватчик вызовов <<services,сервисов>> - класс `ServiceInterceptor`. Кроме того, он же выполняет логирование исключений. По умолчанию в журнал выводится вся информация об исключении, включая полный stack trace. Если это нежелательно, можно добавить классу исключения аннотацию `@Logging`, указав в ней тип логирования:

* `FULL` - (по умолчанию) полная информация, включая stacktrace

* `BRIEF` - только имя класса исключения и сообщение

* `NONE` - не выводить ничего

Например:

[source, java]
----
include::{sourcesdir}/common/mwexception_2.java[]
----

[[exceptionHandlers]]
===== Обработчики исключений клиентского уровня

Необработанные исключения в <<app_tiers,блоках>> Web Client и Desktop Client, возникшие на клиентском уровне или переданные с Middleware, попадают в специальный механизм обработчиков. Этот механизм реализован в <<app_modules,модуле>> GUI и доступен обоим клиентам. 

Обработчик должен быть <<managed_beans,управляемым бином>>, реализовывать интерфейс `GenericExceptionHandler`, в методе `handle()` которого производить обработку и возвращать `true`, либо сразу возвращать `false`, если данный обработчик не может обработать переданное ему исключение. Такое поведение позволяет организовать "цепочку ответственности" обработчиков. 

Рекомендуется наследовать классы своих обработчиков от базового класса `AbstractGenericExceptionHandler`, который умеет разбирать цепочку исключений (с учетом упакованных внутри `RemoteException`) и реагировать на конкретные типы исключений. Типы исключений, для которых предназначен данный обработчик, указываются в массиве строк, передаваемом в конструкторе обработчика базовому конструктору. Каждая строка массива должна содержать одно полное имя класса обрабатываемого исключения, например: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_1.java[]
---- 

Если класс исключения недоступен на клиенте, следует указывать его имя строковым литералом: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_2.java[]
---- 

В случае использования в качестве базового класса `AbstractGenericExceptionHandler` логика обработки располагается в методе `doHandle()`, и может выглядеть следующим образом: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_3.java[]
---- 

Если имени класса исключения недостаточно для того, чтобы принять решение о применимости данного обработчика к исключению, следует определить метод `canHandle()`, получающий кроме прочего текст исключения. Метод должен вернуть `true`, если данный обработчик применим для исключения. Например:

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_4.java[]
---- 

[[dialogs_showExceptionDialog]]
`WindowManager` предоставляет метод `showExceptionDialog()` для отображения диалогового окна с выброшенным исключением и его stacktrace. Метод принимает следующие параметры:

** `throwable` - экземпляр `Throwable`.

** `caption` - заголовок диалога. Это необязательный параметр, если он не установлен, используется заголовок по умолчанию.

** `message` - сообщение диалога. Это необязательный параметр, если он не установлен, используется сообщение по умолчанию.

Пример вызова диалога в обработчике исключения:

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_5.java[]
----

[[bean_validation]]
==== Bean Validation

Bean Validation - опциональный механизм, обеспечивающий единообразную валидацию данных на среднем слое, в <<gui_framework,Generic UI>> и в <<rest_api_v2,REST API>>. Он основан на спецификации JSR 349 - Bean Validation 1.1 и ее референсной имплементации: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/?v=5.3[Hibernate Validator].

[[bean_validation_constraints]]
===== Задание ограничений

Ограничения bean validation задаются с помощью аннотаций пакета `javax.validation.constraints` или собственных аннотаций. Аннотации указываются на декларации класса сущности или POJO, на поле или getter-методе, а также на методе <<services,сервиса>> middleware.

Пример использования стандартных аннотаций валидации на полях сущности:

[source, java]
----
include::{sourcesdir}/common/bean_validation_1.java[]
----

Пример использования собственной аннотации уровня класса (см. <<bean_validation_custom_constraints,ниже>>):

[source, java]
----
include::{sourcesdir}/common/bean_validation_2.java[]
----

Пример валидации параметров и возвращаемого значения метода сервиса:

[source, java]
----
include::{sourcesdir}/common/bean_validation_3.java[]
----

[[bean_validation_constraint_groups]]
Группы ограничений::
+
--
Группы ограничений позволяют применять подмножество всех заданных ограничений в зависисмости от логики приложения. Например, вы можете заставить пользователя ввести значение некоторого атрибута сущности в UI, и а то же время иметь возможность установить данный атрибут в null в некотором внутреннем механизме. Для этого необходимо указать атрибут `groups` в аннотации ограничения, и оно будет действовать только когда эта же группа передается в механизм валидации.

Платформа передает в механизм валидации следующие группы ограничений:

* `RestApiChecks` - при валидации в <<rest_api_v2,REST API>>.
* `ServiceParametersChecks` - при валидации параметров сервисов.
* `ServiceResultChecks` - при валидации возвращаемых значений сервисов.
* `UiComponentChecks` - при валидации отдельных полей в UI.
* `UiCrossFieldChecks` - при валидации ограничений уровня класса на коммите экрана редактора сущности.
* `javax.validation.groups.Default` - данная группа передается во всех случаях кроме коммита экрана редактора сущности.
--

[[bean_validation_messages]]
Сообщения валидации::
+
--
Ограничения могут иметь сообщения для отображения пользователям.

Сообщения могут быть указаны непосредственно в аннотациях валидации, например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_4.java[]
----

Сообщения можно также поместить в <<message_packs,пакет локализованных сообщений>> и использовать следующий формат указания сообщения в аннотации: `{msg://message_pack/message_key}`. Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_5.java[]
----

Сообщения могут содержать параметры и выражения. Параметры заключаются в фигурные скобки `{}` и представляют собой либо указатели на локализованные сообщения (см. выше) или параметры аннотации, например `{min}`, `{max}`, `{value}`. Выражения заключаются в фигурные скобки со знаком доллара `${}` и могут включать валидируемое значение в виде переменной `validatedValue`, параметры аннотации типа `value` или `min`, и выражения JSR-341 (EL 3.0). Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_6.java[]
----

Значения локализованных сообщений также могут содержать параметры и выражения.
--

[[bean_validation_custom_constraints]]
Собственные ограничения::
+
--
В проекте можно создать собственные ограничения с программной или декларативной валидацией.

Для создания ограничения с программной валидацией выполниет следующее:

. Создайте аннотацию в модуле *global* проекта и добавьте ей аннотацию `@Constraint`. Ваша аннотация должна содержать атрибуты `message`, `groups` и `payload`:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_7.java[]
----

. Создайте класс валидатора в модуле *global* проекта:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_8.java[]
----

. Используйте аннотацию:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_9.java[]
----

Собственные аннотации могут также быть созданы как композиции имеющихся, например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_10.java[]
----

При использовании композитных ограничений результирующий набор нарушений `ConstraintViolation` будет содержать отдельные записи для каждого включенного ограничения. Для того, чтобы получить одну запись нарушения, добавьте `@ReportAsSingleViolation` классу вашей аннотации.
--

[[bean_validation_related_objects]]
Валидация связанных объектов::
+
--
Для каскадной валидации связанных объектов на ссылочные поля необходимо добавить аннотацию `@Valid`:

[source, java]
----
include::{sourcesdir}/common/bean_validation_11.java[]
----

В примере выше, при валидации экземпляра `Cart` список продуктов будет проверен на наличие хотя-бы одной записи, и все экземпляры `Product` в списке будут также провалидированы.
--

[[bean_validation_cuba_annotations]]
Аннотации валидации, заданные в CUBA::
+
--
Кроме стандартных аннотаций из пакета `javax.validation.constraints` можно использовать следующую аннотацию, определенную в платформе:

* `@RequiredView` - может быть добавлена на методы сервисов для того, чтобы во время выполнения убедиться, что в сущностях загружены все атрибуты, заданные в требуемых <<views,представлениях>>. Если аннотация задана на методе, то проверяется результат метода. Если аннотация задана на параметре, проверяется этот параметр. Если параметр или результат являются коллекцией, то проверяются все элементы этой коллекции. Пример использования:

[source, java]
----
include::{sourcesdir}/common/bean_validation_18.java[]
----
--

[[bean_validation_running]]
===== Запуск валидации

[[bean_validation_in_ui]]
Валидация в UI::
+
--
Компоненты Generic UI, соединенные с источником данных, получают экземпляр `BeanValidator` для проверки значения. Валидатор вызывается из метода `Component.Validatable.validate()`, реализуемого компонентом, и может выбрасывать исключение `CompositeValidationException`, содержащее набор объектов нарушений.

Стандартный валидатор может быть программно удален или проинициализирован другой <<bean_validation_constraint_groups,группой ограничений>>:

[source, java]
----
include::{sourcesdir}/common/bean_validation_12.java[]
----

По умолчанию, `BeanValidator` содержит две группы: `Default` и `UiComponentChecks`.

Если атрибут сущности аннотирован `@NotNull` без группы ограничений, он будет помечен как обязательный в метаданных, и UI-компоненты работающие с данным атрибутом через источник данных, будут иметь свойство `required = true`.

Компоненты <<gui_DateField,DateField>> и <<gui_DatePicker,DatePicker>> автоматически устанавливают свои свойства `rangeStart` и `rangeEnd` в соответствии с аннотациями `@Past` и `@Future`, не учитывая текущее время.

Экраны <<abstractEditor,редактирования>> выполняют валидацию ограничений уровня класса при коммите, если ограничения включают группу `UiCrossFieldChecks` и все проверки ограничений уровня атрибутов прошли успешно. Валидацию данного типа можно отключить с помощью свойства экрана `crossFieldValidate` в XML-дескрипторе или в контроллере:

[source, xml]
----
include::{sourcesdir}/common/bean_validation_13.xml[]
----

[source, java]
----
include::{sourcesdir}/common/bean_validation_14.java[]
----
--

[[bean_validation_in_services]]
Валидация сервисов Middleware::
+
--
<<services,Сервисы>> среднего слоя выполняют валидацию параметров и результатов методов, если метод имеет аннотацию `@Validated` в интерфейсе сервиса. Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_15.java[]
----

Аннотация `@Validated` может содержать указание <<bean_validation_constraint_groups,групп ограничений>> для применения подмножества имеющихся ограничений. Если группы не указаны, то по умолчанию используются следующие:

* `Default` и `ServiceParametersChecks` - для параметров методов
* `Default` и `ServiceResultChecks` - для возвращаемых результатов методов

При возникновении ошибок валидации выбрасываются исключения `MethodParametersValidationException` и `MethodResultValidationException`.

При выполнении некоторой специфической программной валидации в сервисе, можно использовать исключение `CustomValidationException` для того, чтобы клиенты получали информацию об ошибках в том же формате что и от стандартной валидации. Это может быть особенно актуально для клиентов REST API.
--

[[bean_validation_in_rest]]
Валидация в REST API::
+
--
Универсальный <<rest_api_v2,REST API>> автоматически выполняет bean validation для действий создания и изменения сущностей. Ошибки валидации передаются клиенту следующим образом:

* `MethodResultValidationException` и `ValidationException` порождают HTTP статус `500 Server error`

* `MethodParametersValidationException`, `ConstraintViolationException` и `CustomValidationException` порождают HTTP статус `400 Bad request`

* Тело ответа с `Content-Type: application/json` будет содержать список объектов со свойствами `message`, `messageTemplate`, `path` и `invalidValue`, например:
+
[source, json]
----
include::{sourcesdir}/common/bean_validation_16.json[]
----

** `path` содержит путь к невалидному атрибуту в валидируемом графе объектов
** `messageTemplate` содержит сторку, заданную в атрибуте `message` аннотации
** `message` содержит сообщение ошибки валидации
** `invalidValue` возвращается только если тип значения один из следующих: `String`, `Date`, `Number`, `Enum`, `UUID`.
--

[[bean_validation_programmatic]]
Программная валидация::
+
--
Bean validation можно запустить программно используя интерфейс инфраструктуры `BeanValidation`, доступный и на middleware и на клиентском уровне. Через данный интерфейс необходимо получить реализацию `javax.validation.Validator`, которая и запускает валидацию. Результатом валидации является набор объектов типа `ConstraintViolation`. Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_17.java[]
----
--

[[entity_attribute_access]]
==== Контроль доступа к атрибутам сущностей

<<security,Подсистема безопасности>> позволяет управлять доступом к атрибутам сущностей в соответствии с правами пользователя. Т.е. фреймворк может сделать атрибут read-only или скрыть его в зависимости от набора ролей, назначенных текущему пользователю. Однако, иногда может потребоваться изменять доступ к атрибуту в зависимости также от текущего состояния экземпляра сущности или связанных сущностей.

Механизм контроля доступа к атрибутам позволяет создавать правила того, какие атрибуты должны быть скрыты, нередактируемы или обязательны к заполнению для некоторого экземпляра сущности, и применять эти правила к компонентам <<gui_framework,Generic UI>> и в <<rest_api_v2,REST API>>.

Данный механизм работает следующим образом:

* Когда <<dataManager,DataManager>> загружает сущность, он посылает Spring application event типа `SetupAttributeAccessEvent`. Объект события содержит загруженный экземпляр в состоянии managed и три коллекции имен атрибутов: read-only, hidden и required (изначально они пустые).

* Вам необходимо создать event listener, который будет анализировать состояние сущности и заполнять списки имен атрибутов соответствующим образом. Данный event listener является по сути контейнером правил, задающих доступ к атрибутам экземпляров.

* Описываемый механизм сохраняет имена атрибутов, заданные правилами, в самом экземпляре (в связанном объекте `SecurityState`).

* На клиентском уровне, Generic UI и REST API используют объект `SecurityState` для управления доступом к атрибутам сущностей.

Для создания правил для некоторого типа сущностей, необходимо выполнить следующее:

* Создайте <<managed_beans,управляемый бин>> в модуле *core* проекта. Бин должен иметь дефолтный singleton scope.

* Создайте метод, принимающий единственный параметр типа `SetupAttributeAccessEvent`. Метод должен иметь аннотацию `org.springframework.context.event.EventListener`. Тип `SetupAttributeAccessEvent` является generic и должен быть параметризован типом сущности.

* В данном методе необходимо заполнить коллекции скрываемых, только для чтения и обязательных атрибутов используя методы `addHidden()`, `addReadOnly()` и `addRequired()` объекта события. Экземпляр сущности, доступный через метод `getEntity()`, находится в состоянии managed, поэтому можно безопасно обращаться ко всем его атрибутам и атрибутам связанных сущностей.

Рассмотрим пример сущности `Order`, имеющей атрибуты `customer` и `amount`. Для ограничения доступа к атрибуту `amount` в зависимости от `customer` можно создать следующее правило:

[source, java]
----
include::{sourcesdir}/common/attr_access_1.java[]
----

[[entity_attribute_access_gui]]
Контроль доступа к атрибутам в Generic UI::
+
--
Фреймворк автоматически применяет ограничения доступа к экрану перед вызовом метода `ready()` его контроллера. Если вы не хотите этого для некоторого экрана, переопределите метод `isAttributeAccessControlEnabled()` его контроллера и верните из него `false`.

Пересчитать и применить ограничения к экрану можно и когда он уже открыт, в ответ на действия пользователя. Для этого необходимо использовать бин `AttributeAccessSupport`, передавая ему текущий экран и сущность, состояние которой изменилось. Например:

[source, java]
----
include::{sourcesdir}/common/attr_access_2.java[]
----

Второй параметр метода `applyAttributeAccess()` - булевское значение, которое указывает, нужно ли сбрасывать ограничения доступа к компонентам в дефолтные настройки перед тем, как применить новые. Если передано true, возможные программные изменения в этих настройках будут потеряны. Когда данный метод вызывается автоматически перед открытием окна, передается false. Когда же вы вызываете данный метод в ответ на UI-события, передавайте true, иначе ограничения компонентов будут суммироваться, а не заменяться.

[WARNING]
====
Ограничения доступа к атрибутам применяются только к компонентам, связанным с одним атрибутом сущности, например <<gui_TextField,TextField>> или <<gui_LookupField,LookupField>>. <<gui_Table,Table>> и другие компоненты, реализующие интерфейс `ListComponent`, не затрагиваются. Поэтому если вы пишете правило, скрывающее атрибут для некоторых экземпляров, рекомендуется не показывать этот атрибут в таблицах совсем.
====
--
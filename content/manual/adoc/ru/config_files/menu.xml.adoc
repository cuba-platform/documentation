:sourcesdir: ../../../source

[[menu.xml]]
=== menu.xml

Файлы данного типа используются в блоке Web Client для описания структуры главного меню приложения.

Схема XML доступна по адресу {xsd_url}/menu.xsd.

Расположение файла `menu.xml` задается в свойстве приложения <<cuba.menuConfig,cuba.menuConfig>>. При создании нового проекта в Studio, она создает файл `web-menu.xml` в корневом пакете модуля *web*, например `modules/web/src/com/company/sample/web-menu.xml`.

`menu-config` - корневой XML-элемент файла. Элементы `menu-config` образуют древовидную структуру, в которой элементы `menu` представляют собой ветви, а элементы `item` и `separator` - листья.

* Атрибуты элемента `menu`:

** `id` - уникальный идентификатор элемента.

** `caption` - заголовок элемента меню. Если не задан, заголовок формируется по правилам, описанным <<menu.xml_localized,ниже>>.

** `description` - текст, появляющийся во всплывающей подсказке при наведении курсора мыши. Можно использовать локализованные сообщения из главного пакета сообщений.

** `icon` - значок для элемента меню. См. <<gui_attr_icon,icon>>.

** `insertBefore`, `insertAfter` - идентификатор элемента или пункта меню, перед которым или после которого нужно вставить данный элемент. Используется в прикладном проекте для вставки элемента в нужное место меню, определенного в аналогичных файлах компонентов приложения. Разумеется, использование одного из этих атрибутов для конкретного элемента исключает возможность использования второго атрибута для данного элемента.

** `stylename` - задает имя стиля пункта меню. См. <<gui_themes>>.

* Атрибуты элемента `item`:

** `id` - уникальный идентификатор элемента. Если не определены атрибуты `screen`, `bean`, `class`, то id используется для указания на экран с таким же id. При выборе пункта меню в главном окне приложения будет открыт соответствующий экран.
+
[source, xml]
----
<item id="sample_Foo.browse"/>
----

** `caption` - заголовок элемента меню. Если не задан, заголовок формируется по правилам, описанным <<menu.xml_localized,ниже>>.
+
[source, xml]
----
<item id="sample_Foo.browse" caption="mainMsg://fooBrowseCaption"/>
----

** `screen` - идентификатор экрана (например, `sample_Foo.browse`). Может быть использован для включения в меню одного и того же экрана несколько раз. При выборе пункта меню в главном окне приложения будет открыт соответствующий экран.
+
[source, xml]
----
<item id="foo1" screen="sample_Foo.browse"/>
<item id="foo2" screen="sample_Foo.browse"/>
----

** `bean` - имя бина. Атрибут должен использоваться совместно с `beanMethod`. При выборе пункта меню будет вызван метод бина.
+
[source, xml]
----
<item bean="sample_FooProcessor" beanMethod="processFoo"/>
----

** `class` - полное имя класса, который реализует интерфейс `Runnable`, `Consumer<Map<String, Object>>`, или `MenuItemRunnabl`. При выборе пункта меню будет создан экземпляр данного класса и вызван его метод.
+
[source, xml]
----
<item class="com.company.sample.web.FooProcessor"/>
----

** `description` - текст, появляющийся во всплывающей подсказке при наведении курсора мыши. Можно использовать локализованные сообщения из главного пакета сообщений.
+
[source, xml]
----
<item id="sample_Foo.browse" description="mainMsg://fooBrowseDescription"/>
----

** `shortcut` - горячая клавиша для вызова данного пункта меню. Возможные модификаторы - `ALT`, `CTRL`, `SHIFT` - отделяются символом "`-`". Например:
+
[source, xml]
----
shortcut="ALT-C"
shortcut="ALT-CTRL-C"
shortcut="ALT-CTRL-SHIFT-C"
----
+
Горячие клавиши можно также задавать в <<app_properties,свойствах приложения>> и использовать в `menu.xml` следующим образом:
+
[source, properties]
----
shortcut="${sales.menu.customer}"
----

** `openType` - тип открытия экрана, возможные значения соответствуют перечислению `OpenMode`: `NEW_TAB`, `THIS_TAB`, `DIALOG`. По умолчанию - `NEW_TAB`.

** `icon` - значок для элемента меню. См. <<gui_attr_icon,icon>>.

** `insertBefore`, `insertAfter` - идентификатор элемента или пункта меню, перед которым или после которого нужно вставить данный элемент.

** `resizable` - актуально для типа открытия экрана `DIALOG` - задает окну возможность изменения размера. Возможные значения: `true`, `false`. По умолчанию главное меню не влияет на возможность изменения размера диалоговых окон.

** `stylename` - задает имя стиля пункта меню. См. <<gui_themes>>.

* Вложенные элементы `item`:

[[menu.xml_screen_properties]]
** `properties` – определяет набор параметров для передачи в публичные сеттеры экрана. Каждый параметр задается в элементе `property` с атрибутом `name`, который соответствует сеттеру, например строковый параметр `foo` соответвует методу `void setFoo(String value)`. Сеттеры вызываются фреймворком между посылкой событий <<screen_AfterInitEvent,AfterInitEvent>> и <<screen_BeforeShowEvent,BeforeShowEvent>>.
+
Атрибуты `property`:

*** `name` – имя параметра.

*** `value` – значение параметра для параметров, не являющихся сущностями.

*** `entityClass` – класс параметра-сущности.

*** `entityId` – идентификатор параметра-сущности.

*** `entityView` – представление для загрузки параметра-сущности.

** `permissions` - элемент, позволяющий задать набор разрешений текущего пользователя, при которых данный пункт меню доступен. Данный механизм имеет смысл использовать только если необходимо привязать доступность пункта к специфическим разрешениям, или не к одному, а к нескольким разрешениям сразу. В большинстве случаев достаточно стандартной возможности подсистемы безопасности управлять доступностью пунктов меню по идентификаторам экранов.
+
Данный элемент должен содержать вложенные элементы `permission`, каждый из которых описывает одно требуемое разрешение. Пункт меню доступен только при наличии всех требуемых разрешений.
+
Атрибуты `permission`:

*** `type` - тип требуемого разрешения, задаваемый значением перечисления `PermissionType`: `SCREEN`, `++ENTITY_OP++`, `++ENTITY_ATTR++`, `SPECIFIC`, `UI`.

*** `target` - объект, на который проверяется наличие разрешения. Зависит от типа разрешения:

**** `SCREEN` - идентификатор экрана, например `sales_Customer.lookup`.

**** `++ENTITY_OP++` - строка вида `++{entity_name}:{op}++`, где `{op}` - `read`, `create`, `update`, `delete`. Например: `sales_Customer:create`.

**** `++ENTITY_ATTR++` - строка вида `++{entity_name}:{attribute}++`, например `sales_Customer:name`.

**** `SPECIFIC` - идентификатор специфического разрешения, например `sales.runInvoicing`.

**** `UI` - путь к визуальному компоненту экрана.

Пример файла меню:

[source, xml]
----
include::{sourcesdir}/config_files/menu_1.xml[]
----
<1> - открыть экран в диалоговом окне.
<2> - вызвать метод `setStringParam()`, передавая в него `some string`.
<3> - вызвать метод `setCustomerParam()`, передавая в него экземпляр сущности загруженный по данному id.
<4> - вызвать метод `setEntityToEdit()` класса `StandardEditor`, передавая в него экземпляр сущности загруженный по данному id и представлению.

[[menu.xml_localized]]
Если атрибут `caption` не задан, локализованное название элемента меню формируется следующим образом: к идентификатору элемента добавляется префикс `menu-config` с точкой на конце, и полученная строка используется как ключ в <<main_message_pack,главном пакете сообщений>>. Например:

[source, plain]
----
menu-config.sales=Sales
menu-config.sales_Customer.lookup=Customers
----

Если атрибут `id` не задан, имя элемента меню будет составлено из имени класса (если задан атрибут `class`) или имени бина и его метода (если задан атрибут `bean`), поэтому для локализации рекомендуется указывать атрибут `id`.


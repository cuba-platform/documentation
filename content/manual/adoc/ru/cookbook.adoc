:proj_business_logic: https://github.com/cuba-platform/sample-business-logic
:proj_model: https://github.com/cuba-platform/sample-model

[[cookbook]]
== Сборник рецептов

// for backward compatibility
[[dev_recipes]]

Данный раздел представляет собой коллекцию практических рецептов по решению типичных задач, встающих перед разработчиками при использовании платформы CUBA. В каждом подразделе информация организована от простого к сложному, поэтому вы в любой момент можете перейти к другой секции или заняться кодированием.

Большинство разделов снабжены демо-приложениями. Вы можете увидеть их в работе онлайн, посмотреть исходный код на GitHub, или загрузить и запустить локально. Ссылки на проекты приложений доступны также на вкладке *Samples* в Studio.

[TIP]
====
Данный раздел находится в работе и будет постоянно дополняться. Если у вас есть идеи новых рецептов и задач, решение которых стоило бы продемонстрировать, вы можете создать запрос в виде issue в исходниках документации на https://github.com/cuba-platform/documentation[GitHub].
====

[[business_logic_recipes]]
=== Организация бизнес-логики

Один из первых вопросов, возникающих в начале процесса разработки на платформе, это "где мне расположить мою бизнес-логику"? Использование Studio сильно облегчает создание модели данных и CRUD экранов, любой реальный проект требует создания логики помимо загрузки и сохранения данных. Данный раздел содержит информацию о том, как эффективно организовать бизнес-логику в зависимости от задачи.

Большинство примеров в данном разделе работают со следующей моделью:

image::business_logic_model_1.png[align="center"]

В этих примерах мы будем рассчитывать скидки для заказчиков в зависимости от общей суммы их покупок.

[[logic_in_controllers_recipe]]
==== Бизнес-логика в контроллерах

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=sample$Customer.browse_1" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Например, необходимо запускать расчет скидки, когда пользователь нажимает кнопку на экране-браузере заказчиков. В этом случае, наиболее простое решение - это разместить логику расчета прямо в <<screen_controller,контроллере>> экрана.

См. кнопку *Calculate discount* в демо-приложении и реализацию контроллера: {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex1/customer/CustomerBrowse.java[CustomerBrowse.java]. Пожалуйста, имейте в виду, что данная имплементацию расчета не является оптимальной (см. варианты работы с данными в разделе <<data_recipes>>).

Данный подход приемлем, если логика вызывается из одного места и она не слишком сложна, чтобы уместиться в нескольких коротких методах.

[[using_client_beans_recipe]]
==== Использование бинов клиентского уровня

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=sample$Customer.browse_2" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Теперь давайте немного усложним задачу из <<logic_in_controllers_recipe,предыдущего>> раздела. Допустим, требуется вызывать расчет из двух экранов: и из браузера, и из редактора. Чтобы не дублировать код, нужно извлечь код из контроллера и поместить в некоторое общедоступное место. Это может быть <<managed_beans,управляемый бин>> клиентского <<app_tiers,уровня>>.

Управляемый бин - это класс с аннотацией `@Component`. Он может быть инжектирован в другие бины и контроллеры экранов, или получен с помощью статического метода `AppBeans.get()`. Если класс бина реализует некоторый интерфейс, то к нему можно обращаться через этот интерфейс.

Имейте в виду, что для того чтобы бин был доступен для контроллеров экранов, он должен располагаться в одном из следующих <<app_modules,модулей>>: *global*, *gui* или *web* вашего проекта. В случае *global*, бин будет также доступен на среднем слое.

См. кнопку *Calculate discount* на экранах браузера и редактора в демо-приложении, и реализацию:

image::using_client_beans_1.png[align="center"]

* {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex2/customer/CustomerBrowse.java[CustomerBrowse.java] - контроллер браузера.

* {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex2/customer/CustomerEdit.java[CustomerEdit.java] - контроллер редактора.

* {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex2/DiscountCalculator.java[DiscountCalculator.java] - бин расчета скидок. Он использует <<dataManager,DataManager>> для загрузки списка заказов данного заказчика из базы данных.

[[using_services_recipe]]
==== Использование сервисов среднего слоя

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=sample$Customer.browse_3" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

В <<using_client_beans_recipe,предыдущем>> разделе мы рассмотрели инкапсуляцию бизнес-логики в бине клиентского уровня. Теперь мы пойдем дальше и поместим нашу логику в наиболее подходящее место: на <<middleware,средний слой>>. Сделав это, мы достигнем следующих целей:

* Наши бизнес-методы будут доступны клиентам всех типов, включая <<polymer_ui,Polymer UI>>.

* Мы сможем использовать API, доступный только на middleware: <<entityManager,EntityManager>>, <<transactions,transactions>>, и т.п.

Чтобы вызвать бизнес-метод среднего слоя, необходимо создать <<services,сервис>>. Studio может помочь в создании заготовки сервиса:

* Переключитесь на вкладку *Middleware* и нажмите *New > Service*.

* Измените имя интерфейса сервиса на `DiscountService`. Имена класса и самого сервиса будут изменены соответственно. Нажмите *OK* или *Apply*.

* Нажмите *IDE* и откройте интерфейс сервиса в IDE. Создайте новый метод и реализуйте его в классе сервиса.

См. пример реализации в демо-приложении:

image::using_services_1.png[align="center"]

 * {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex3/customer/CustomerBrowse.java[CustomerBrowse.java] and {proj_business_logic}/blob/master/modules/web/src/com/company/sample/web/ex3/customer/CustomerEdit.java[CustomerEdit.java] - контроллер экрана, который вызывает сервис.

 * {proj_business_logic}/blob/master/modules/global/src/com/company/sample/service/DiscountService.java[DiscountService.java] - интерфейс сервиса.

 * {proj_business_logic}/blob/master/modules/core/src/com/company/sample/service/DiscountServiceBean.java[DiscountServiceBean.java] - класс реализации сервиса.

 * {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/DiscountCalculator.java[DiscountCalculator.java] - бин среднего слоя, рассчитывающий скидки. Разумеется, сервис мог бы содержать бизнес-логику сам, но мы будем использовать этот делегат для того чтобы разделять логику с entity listener и JMX-бином (см. следующие разделы).
+
Обратите внимание, что данный бин отличается от рассмотренного в
<<using_client_beans_recipe,предыдущем>> разделе: он расположен в модуле *core* и использует <<entityManager,EntityManager>> для загрузки суммы заказов из базы данных.

Теперь давайте сделаем наш бизнес-метод доступным для внешних клиентов через <<rest_api_v2,REST API>>:

* Откройте сервис на редактирование в Studio и переключитесь на вкладку *REST Methods*.

* Установите для метода флажок *REST invocation allowed*.

Studio создаст файл `rest-services.xml` и зарегистрирует в нем метод. После перезапуска сервера вы сможете вызвать метод с помощью HTTP-запросов. Например, следующий GET-запрос должен работать с нашим онлайн демо-сервером:

`\https://demo1.cuba-platform.com/business-logic/rest/v2/services/sample_DiscountService/calculateDiscount?customerId=1797f54d-5bec-87a6-4330-d958955743a2`

Имейте в виду, что демо-приложение имеет <<rest_api_v2_anonymous,анонимный доступ>>. В большинстве реальных сценариев использования необходимо будет аутентифицироваться, прежде чем выполнять запросы.

[[using_entity_listeners_recipe]]
==== Использование Entity Listeners

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=sample$orderBrowseWithCustomers" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

<<entity_listeners,Entity listeners>> позволяют выполнять бизнес-логику каждый раз, когда сущность создается, изменяется или удаляется в базе данных. Например, мы можем пересчитывать скидку для заказчика каждый раз, когда некоторый заказ для него изменяется.

Заготовку для entity listener можно легко создать в Studio:

* Перейдите на вкладку *Middleware* и нажмите *New > Entity listener*.

* Измените имя класса на `OrderEntityListener` и включите флажки для интерфейсов `BeforeInsertEntityListener`, `BeforeUpdateEntityListener` и `BeforeDeleteEntityListener`.

* Выберите сущность `Order` в поле *Entity type*.

* Нажмите *OK* или *Apply* и откройте класс listener в IDE.

См. пример в демо-приложении:

image::using_entity_listeners_1.png[align="center"]

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/listener/OrderEntityListener.java[OrderEntityListener.java] - класс entity listener.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/DiscountCalculator.java[DiscountCalculator.java] - бин среднего слоя, рассчитывающий скидки. Entity listener мог бы содержать бизнес-логику сам, но мы используем этот делегат для того, чтобы разделять логику с сервисом и JMX бином.

Если вы откроете экран *Logic in Entity Listeners* демо-приложения, вы увидите две таблицы: заказы и заказчики. Создайте, измените или удалите заказ, обновите таблицу заказчиков, и вы увидите, что скидка для соответствующего заказчика изменилась.

[[using_jmx_beans_recipe]]
==== Использование JMX-бинов

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=jmxConsole" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

С помощью <<jmx_beans,JMX-бинов>> можно предоставить доступ к некоторой административной функциональности вашего приложения без создания пользовательского интерфейса для нее. Данная функциональность будет также доступна через встроенную JMX-консоль и через внешние инструменты JMX, например `jconsole`.

В нашем примере со скидками пользователь, имеющий доступ к JMX-консоли, сможет пересчитывать скидки для всех заказчиков или для заказчика с указанным id.

Studio на данный момент не умеет создавать заготовки JMX-бинов, поэтому все классы и конфигурационные элементы придется создавать вручную в IDE.

См. пример реализации в демо-приложении:

image::using_jmx_beans_1.png[align="center"]

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/jmx/DiscountsMBean.java[DiscountsMBean.java] - интерфейс JMX-бина.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/jmx/Discounts.java[Discounts.java] - реализация JMX-бина.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/DiscountCalculator.java[DiscountCalculator.java] - бин среднего слоя, вызываемый JMX-бином. JMX-бин мог бы содержать бизнес-логику сам, но мы используем этот делегат для того, чтобы разделять логику с entity listener и JMX бином.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/spring.xml[spring.xml] - в данном файле JMX-бин регистрируется.

[[app_start_recipe]]
==== Запуск кода на старте приложения

Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться <<app_lifecycle_events,слушателями событий жизненного цикла>>.

++++
<div class="manual-live-demo-container">
    <a href="https://demo1.cuba-platform.com/business-logic/open?screen=sample$Employee.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

В данном разделе мы рассмотрим, как динамически зарегистрировать для сущности <<entity_listeners,entity listener>> на старте приложения. Возьмем следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая связана один-к-одному с платформенной сущностью `User` (пользователь системы):

image::app_start_recipe_1.png[align="center"]

Если атрибут `name` сущности `User` изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут `name` связанной сущности `Employee`. Это обычная задача для "денормализованных" данных, и решается она, как правило, с использованием <<entity_listeners,entity listeners>>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности `User`, и добавить entity listener с помощью аннотации <<listeners_annotation,@Listeners>> невозможно. Однако, можно добавить listener динамически через бин `EntityListenerManager`, и сделать это лучше всего на старте приложения.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/core/AppLifecycle.java[AppLifecycle.java] - бин среднего слоя, слушающий события типа `AppContextInitializedEvent`.

* {proj_business_logic}/blob/master/modules/core/src/com/company/sample/listener/UserEntityListener.java[UserEntityListener.java] - entity listener для сущности `User`.

В результате сразу после старта <<app_tiers,блока>> Middleware будет вызван метод `initEntityListeners()` класса `AppLifecycle`. В этом методе в качестве entity listener сущности `User` регистрируется бин `sample_UserEntityListener`.

Метод `onBeforeUpdate()` класса `UserEntityListener` будет вызываться перед каждым сохранением изменений экземпляров `User` в базу данных. В методе проверяется, есть ли атрибут `name` среди измененных, и если да, загружается связанный экземпляр `Employee`, и в нем устанавливается это же значение `name`.


[[modeling_domain_recipes]]
=== Моделирование предметной области

В данном разделе приведены рецепты, связанные с дизайном модели данных и работой с атрибутами сущностей.

[[init_values]]
==== Присвоение начальных значений

Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.

[[init_values_in_class]]
===== Инициализация полей сущности

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Customer.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Атрибуты простых типов (`Boolean`, `Integer` и т.д.) и перечисления можно инициализировать прямо в объявлении соответствующего поля класса сущности. См. например поля `active` и `grade` в {proj_model}/blob/master/modules/global/src/com/company/sample/entity/customers/Customer.java[Customer.java].

Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <<postConstruct_entity_annotation,@PostConstruct>>. В этом случае в процессе инициализации можно использовать вызов любых глобальных <<infrastructure_interfaces,интерфейсов инфраструктуры>> и <<managed_beans,бинов>>. См. метод `init()` в {proj_model}/blob/master/modules/global/src/com/company/sample/entity/customers/Customer.java[Customer.java].


[[init_values_in_CreateAction]]
===== Инициализация с помощью CreateAction

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$customersWithAddresses" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методами `setInitialValues()` или `setInitialValuesSupplier()` класса <<createAction,CreateAction>>.

См. пример работы с сущностями `Customer` и `CustomerAddress` в демо-приложении:

image::cookbook/init_values_1.png[align="center"]

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/customer/customer-address-browse.xml[customer-address-browse.xml] - дескриптор экрана с двумя связанными таблицами, одна для заказчиков, другая для их адресов.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/customer/CustomerAddressBrowse.java[CustomerAddressBrowse.java] - контроллер экрана. В его методе `init()` вызывается `setInitialValuesSupplier()`, который используется для предоставления начального значения атрибуту `customer` создаваемого адреса. Значением будет заказчик, выбранный в данный момент в первой таблице.


[[init_values_in_initNewItem]]
===== Использование метода initNewItem

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Customer.browse1" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <<initNewItem,initNewItem()>>.

Рассмотрим сущности:

image::cookbook/composition_recipe_3.png[align="center"]

В демо-приложении атрибут `info` сущности `CustomerDetails` редактируется в том же экране, что и сам `Customer`. Данный подход требует создания экземпляра `CustomerDetails` вместе с владеющим им `Customer`.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/customers_1/customer-edit.xml[customer-edit.xml] - дескриптор экрана редактирования заказчика. Он содержит вложенный источник данных для связанного экземпляра `CustomerDetails`. Компонент` infoField` типа `TextArea` подключен к этому источнику.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/customers_1/CustomerEdit.java[CustomerEdit.java] - контроллер экрана. В нем определен метод `initNewItem()`, который создает новый экземпляр `CustomerDetails` и устанавливает его в новый `Customer`. Созданный экземпляр будет доступен через вложенный источник данных и сохранен в базе данных когда экран будет закоммичен.

[[composition_recipe]]
==== Редактирование композитных сущностей

Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию и композицию. В интерфейсе CUBA Studio они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа "master-detail" когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.

Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов, сохраняются в базу данных вместе в одной транзакции, и только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.

[[composition_impl_recipe]]
===== One-to-Many: один уровень вложенности

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Airport.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Рассмотрим реализацию композиции на примере сущностей `Airport` и `Terminal`:

image::cookbook/composition_recipe_1.png[align="center"]

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/airports/Terminal.java[Terminal.java] - сущность `Terminal` содержит обязательную ссылку на `Airport`.
+
В редакторе сущностей Studio установите следующие свойства для атрибута `airport`: *Attribute type* - ASSOCIATION, *Cardinality* - MANY_TO_ONE, *Mandatory* - on.

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/airports/Airport.java[Airport.java] - сущность `Airport` содержит one-to-many коллекцию терминалов. Соответствующее поле аннотировано <<composition_annotation,@Composition>> для реализации композиции, и <<onDelete_annotation,@OnDelete>> для каскадного мягкого удаления.
+
В редакторе сущностей Studio установите следующие свойства для атрибута `terminals`: *Attribute type* - COMPOSITION, *Cardinality* - ONE_TO_MANY, *On delete* - CASCADE.

* {proj_model}/blob/master/modules/global/src/com/company/sample/views.xml[views.xml] - <<views,представление>> `airport-terminals` экрана редактирования аэропорта содержит атрибут-коллекцию `terminals`. Для этого атрибута используется представление `_local`, так как атрибут `airport` сущности `Terminal` устанавливается только во время создания экземпляра `Terminal` и никогда не изменяется после этого, поэтому загружать его не требуется.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-edit.xml[airport-edit.xml] - XML-дескриптор экрана редактирования аэропорта определяет источник данных для экземпляра аэропорта, и вложенный источник для его терминалов. Кроме того, экран содержит таблицу, отображающую терминалы.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports/terminal/terminal-edit.xml[terminal-edit.xml] - стандартный редактор для сущности `Terminal`.

В результате редактирование экземпляра аэропорта работает следующим образом:

* В экране редактирования аэропорта отображается таблица терминалов.

* Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии *OK* в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных `terminalsDs` экрана редактирования аэропорта.

* Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных `terminalsDs`.

* Пользователь нажимает *OK* в экране редактирования аэропорта, и измененный `Airport` вместе со всеми измененными экземплярами `Terminal` отправляется на middleware в метод <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции.

[[composition_deep_recipe]]
===== One-to-Many: два уровня вложенности

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Airport.browse1" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Композиция может быть более глубокой и состоять из двух уровней вложенности. Усложним приведенный <<composition_impl_recipe,выше>> пример, добавив сущность `MeetingPoint`, описывающую место встречи у терминала аэропорта:

image::cookbook/composition_recipe_2.png[align="center"]

Теперь сущность `Terminal` содержит атрибут `meetingPoints` - коллекцию экземпляров `MeetingPoint`. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/airports/Terminal.java[Terminal.java] - атрибут `meetingPoints` класса `Terminal` содержит аннотации `@Composition` и `@OnDelete` аналогично атрибуту `terminals` класса `Airport`.

* {proj_model}/blob/master/modules/global/src/com/company/sample/views.xml[views.xml] - представление `terminal-meetingPoints-view` сущности `Terminal` содержит атрибут-коллекцию `meetingPoints`. Данное представление используется в представлении `airport-terminals-meetingPoints-view` сущности `Airport`.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_1/airport/airport-edit.xml[airport-edit.xml] - дескриптор экрана редактирования `Airport` содержит источники данных для экземпляра `Airport` и вложенных сущностей на всю глубину композиции (`airportDs` > `terminalsDs` > `meetingPointsDs`).
+
Источник данных `meetingPointsDs` здесь не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_1/terminal/terminal-edit.xml[terminal-edit.xml] - XML-дескриптор экрана редактирования терминала в свою очередь определяет вложенный источник данных и соответствующую таблицу для коллекции `meetingPoints`.

В результате измененные эземпляры `MeetingPoint`, так же как и экземпляры `Terminal`, будут сохраняться в базу данных только вместе с экземпляром `Airport` в одной транзакции.

[[composition_deep3_recipe]]
===== One-to-Many: три уровня вложенности

Представьте, что вам необходима еще одна сущность, содержащая некоторые детали места встречи (`MeetingPoint`). Назовем эту сущность *Note*. Таким образом, вся структура будет выглядеть следующим образом: *Airport > Terminal > Meeting Point > Note*.

image::cookbook/composition_recipe_4.png[align="center"]

CUBA может обеспечить работу с композициями с максимум двумя уровнями вложенности. Теперь у нас структура с тремя уровнями, поэтому необходимо ограничить глубину композиции либо сверху, либо снизу. В данном разделе мы рассмотрим два различных (с точки зрения user experience) подхода для исключения из композиции аэропорта. Оба подхода решают одну и ту же проблему: так как теперь терминалы сохраняются в базу данных независимо от аэропорта, невозможно сохранить терминал для только что созданного аэропорта, пока он не сохранен в БД.

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Airport.browse2" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

* При первом подходе браузер и редактор аэропорта выглядят так же, как и раньше, но редактор имеет дополнительную кнопку *Save* для сохранения нового аэропорта не закрывая экрана. Пользователь не может создавать терминалы, пока новый аэропорт не сохранен.

** {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_2/airport/airport-edit.xml[airport-edit.xml] содержит standalone источник данных для терминалов вместо вложенного. Этот источник связан с источником аэропорта, и поэтому загружает терминалы только для редактируемого аэропорта. Кроме того, экран содержит фрейм `extendedEditWindowActions`, позволяющий пользователю сохранить аэропорт не закрывая экран.

** {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_2/airport/AirportEdit.java[AirportEdit.java] - здесь, в методе `postInit()` редактора аэропорта, мы управляем состоянием enabled действия создания терминала и передаем текущий экземпляр аэропорта для инициализации ссылки в создаваемом терминале.

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Airport.browse3" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

* При втором подходе мы разбиваем браузер аэропортов на две панели: одна для списка аэропортов, вторая для зависимого списка терминалов. Т.е. список терминалов теперь находится вне редактора аэропорта. Действие создания терминалов недоступно, если не выбран ни один аэропорт.

** {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_3/airport-browse.xml[airport-browse.xml] содержит standalone источник данных для списка терминалов. Он связан с источником аэропортов, и загружает терминалы только для выбранного аэропорта.

** {proj_model}/blob/master/modules/web/src/com/company/sample/web/airports_3/AirportBrowse.java[AirportBrowse.java] - здесь, в методе `init()` браузера аэропорта, мы управляем состоянием enabled действия создания терминала и передаем выбранный экземпляр аэропорта для инициализации ссылки в создаваемом терминале.

[[composition_oto_recipe]]
===== Композиция One-to-One

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Customer.browse2" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Композиция one-to-one рассматривается на примере сущностей `Customer` и `CustomerDetails`:

image::cookbook/composition_recipe_3.png[align="center"]

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/customers/Customer.java[Customer.java] - сущность `Customer` содержит необязательную ссылку на `CustomerDetails`, аннотированную как `@Composition`.

* {proj_model}/blob/master/modules/global/src/com/company/sample/entity/customers/CustomerDetails.java[CustomerDetails.java] - сущность `CustomerDetails`.

* {proj_model}/blob/master/modules/web/src/com/company/sample/web/customers_2/customer-edit.xml[customer-edit.xml] - дескриптор экрана редактирования заказчика. Он содержит вложенный источник данных для экземпляра `CustomerDetails`. Для того, чтобы загрузить вложенный экземпляр, корневой источник данных использует <<views,представление>> сущности `Customer`, включающее атрибут `details`. Компонент FieldGroup просто декларирует поле для атрибута `details`.

В результате редактирование экземпляра `Customer` работает следующим образом:

* Экран редактирования `Customer` содержит компонент <<gui_PickerField,PickerField>> с двумя действиями: <<openAction,OpenAction>> и <<clearAction,ClearAction>>:

image::cookbook/composition_recipe_oto_1.png[align="center"]

* Когда вызывается `OpenAction`, создается новый экземпляр `CustomerDetails` и он отображается в собственном экране редактирования. При нажатии *OK* в этом экране, экземпляр `CustomerDetails` сохраняется не в БД, а в источнике данных `detailsDs` редактора `Customer`.

* Компонент выбора отображает <<namePattern_annotation,instance name>> сущности `CustomerDetails`:

image::cookbook/composition_recipe_oto_2.png[align="center"]

* Когда пользователь нажимает *OK* в редакторе `Customer`, измененный экземпляр `Customer` вместе с экземпляром `CustomerDetails` отправляется в метод `DataManager.commit()` на средний слой и сохраняется в БД в одной транзакции.

* Если пользователь вызывает `ClearAction` в поле выбора, экземпляр `CustomerDetails` удаляется и ссылка на него очищается в одной транзакции после коммита редактора `Customer`.

[[association_mtm]]
==== Ассоциация Many-to-Many

В ассоциации many-to-many множество записей в одной таблице может быть связано со множеством записей в другой таблице, при этом первичные ключи обеих связанных сущностей хранятся в отдельной связующей таблице. При необходимости связующая таблица может содержать дополнительные поля.

В зависимости от того, нужны ли вам дополнительные поля в связующей таблице, отношения many-to-many можно реализовать с использованием связующей сущности или без неё. Далее мы рассмотрим оба подхода.

[[association_mtm_recipe_1]]
===== Прямая ассоциация Many-to-Many

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Airline.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Рассмотрим реализацию ассоциации many-to-many на примере сущностей `Airport` и `Airline`. Один аэропорт может принимать множество авиакомпаний, и одна авиакомпания-перевозчик, в свою очередь, может осуществлять рейсы во множество аэропортов.

image::cookbook/association_recipe_1.png[align="center"]

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/entity/airports/Airport.java[Airport.java] - сущность `Airport` содержит many-to-many список авиакомпаний.
+
В редакторе сущностей Studio установите следующие свойства для атрибута `airlines`: *Attribute type* - `ASSOCIATION`, *Cardinality* - `MANY_TO_MANY`.
+
Сущность `Airport` будет отмечена ведущей стороной ассоциации, и Studio предложит создать соответствующий атрибут `airports` в сущности `Airline` на противоположной стороне отношений.
+
[source, java]
----
@JoinTable(name = "SAMPLE_AIRLINE_AIRPORT_LINK",
    joinColumns = @JoinColumn(name = "AIRPORT_ID"),
    inverseJoinColumns = @JoinColumn(name = "AIRLINE_ID"))
@ManyToMany
protected List<Airline> airlines;
----

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/entity/airports/Airline.java[Airline.java] - сущность `Airline` теперь содержит many-to-many список аэропортов: *Attribute type* - `ASSOCIATION`, *Cardinality* - `MANY_TO_MANY`.
+
[source, java]
----
@JoinTable(name = "SAMPLE_AIRLINE_AIRPORT_LINK",
    joinColumns = @JoinColumn(name = "AIRLINE_ID"),
    inverseJoinColumns = @JoinColumn(name = "AIRPORT_ID"))
@ManyToMany
protected List<Airport> airports;
----
+
Сущность `Airline` также будет отмечена как ведущая сторона отношений, что позволяет редактировать коллекции с обеих сторон.

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/views.xml[views.xml] - представление `airport-airlines` экрана редактирования аэропорта содержит ссылки на  авиакомпании с представлением `_minimal`. Представление `airline-airports`, в свою очередь, также содержит ссылки на аэропорты.

* https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-edit.xml[airport-edit.xml] - XML-дескриптор экрана редактирования аэропорта определяет источник данных для экземпляра аэропорта и вложенный источник для его авиакомпаний. Кроме того, экран содержит таблицу, отображающую авиакомпании, и действия https://doc.cuba-platform.com/manual-latest/list_actions.html#addAction[add] и https://doc.cuba-platform.com/manual-latest/list_actions.html#removeAction[remove] для неё.

* https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airline/airline-edit.xml[airline-edit.xml] - XML-дескриптор экрана редактирования авиакомпании определяет источник данных для экземпляра авиакомпании и вложенный источник данных для её аэропортов. Кроме того, экран содержит таблицу, отображающую аэропорты, и действия *add* и *remove*.
+
Таким образом, экраны редактирования сущностей `Airport` и `Airline` полностью симметричны.

В результате редактирование экземпляра авиакомпании работает следующим образом:

В экране редактирования авиакомпании отображается список аэропортов.

Пользователь может нажать *Add* и в открывшемся https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-browse.xml[экране выбора] сущности `Airport` либо выбрать аэропорт, который нужно добавить, либо открыть экран его редактирования. При нажатии *OK* в https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-edit.xml[экране редактирования] аэропорта изменённый экземпляр аэропорта сохраняется как в базу данных, так и в https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airline/airline-edit.xml#L12[источник данных] `airportsDs` экрана редактирования авиакомпании, так как сущность `Airport` является полностью независимой.

Пользователь может создавать новые аэропорты или удалять их, и все изменения будут сохраняться и в базу данных в отдельных транзакциях, и в источник данных `airportsDs`.

Пользователь нажимает *OK* в экране редактирования авиакомпании, и изменённый экземпляр `Airline` вместе со всеми ссылками на экземпляры `Airport` отправляется на middleware в метод <<dataManager,DataManager>>.commit(), чтобы быть сохранённым в базе данных.

На другой стороне отношений в экране редактирования сущности `Aiport` работает ровно тот же принцип.

[[association_mtm_recipe_2]]
===== Ассоциация Many-to-Many через связующую сущность

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$DutyFree.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Отношения many-to-many всегда требуют создания связующей таблицы в базе данных, однако создание отдельной сущности для отражения этой таблицы является опциональным. Связующую сущность необходимо создать в том случае, если вы хотите хранить в связующей таблице некие дополнительные поля.

Продемонстрируем этот подход на примере сущностей `Airport` и `DutyFree`. В одном аэропорту может располагаться множество разных сетей магазинов беспошлинной торговли, и одна сеть duty-free может быть представлена во множестве разных аэропортов. Предположим, что кроме связи сущностей мы хотим хранить ещё и валюту, используемую в данном магазине в данном аэропорту:

image::cookbook/association_recipe_2.png[align="center"]

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/entity/airports/Airport.java[Airport.java] - сущность `Airport` содержит one-to-many коллекцию экземпляров  `AirportDutyFree`.
+
В редакторе сущностей Studio установите следующие свойства для атрибута `dutyFreeShops`: *Attribute type* - `COMPOSITION`, *Cardinality* - `ONE_TO_MANY`.
+
[source, java]
----
@Composition
@OnDelete(DeletePolicy.CASCADE)
@OneToMany(mappedBy = "airport")
protected List<AirportDutyFree> dutyFreeShops;
----

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/entity/airports/DutyFree.java[DutyFree.java] - сущность `DutyFree` также содержит one-to-many коллекцию экземпляров  `AirportDutyFree`.
+
В редакторе сущностей Studio установите следующие свойства для атрибута `airports`: *Attribute type* - `COMPOSITION`, *Cardinality* - `ONE_TO_MANY`.
+
[source, java]
----
@Composition
@OnDelete(DeletePolicy.CASCADE)
@OneToMany(mappedBy = "dutyFree")
protected List<AirportDutyFree> airports;
----

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/entity/airports/AirportDutyFree.java[AirportDutyFree.java] - таким образом, связующая сущность `AirportDutyFree` содержит два ссылочных атрибута с отношением many-to-one: `airport` и `dutyFree`:
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "AIRPORT_ID")
protected Airport airport;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "DUTY_FREE_ID")
protected DutyFree dutyFree;
----

* https://github.com/cuba-platform/sample-model/blob/master/modules/global/src/com/company/sample/views.xml[views.xml] - представление `airport-duty-free` экрана редактирования аэропорта содержит атрибут-коллекцию `dutyFreeShops` (со ссылками на `AirportDutyFree`), а в ней атрибуты `dutyFree` и `currency`.
+
Представление `dutyFree-airport` следует той же логике: оно содержит атрибут-коллекцию `airports` (со ссылками на `AirportDutyFree`), а в ней атрибуты `airport` и `currency`.

* https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/dutyfree/duty-free-edit.xml[duty-free-edit.xml] - XML-дескриптор экрана редактирования магазина duty-free определяет источник данных для экземпляра `DutyFree` и вложенный источник для его аэропортов. Кроме того, экран содержит таблицу, отображающую аэропорты, и действие, позволяющее выбирать аэропорт напрямую, минуя экран редактирования связующей сущности `AirportDutyFree`.

В результате редактирование экземпляра `DutyFree` работает следующим образом:

В экране редактирования `DutyFree` отображается таблица аэропортов и выпадающий список валют.

По нажатию *Add airport* открывается экран выбора `Airport`, и пользователь может как выбрать аэропорт, так и открыть экран его редактирования. Когда экземпляр аэропорта выбран, создаётся https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/dutyfree/DutyFreeEdit.java#L29[новый экземпляр] сущности `AirportDutyFree`, которому проставляется валюта по умолчанию. Этот экземпляр связующей сущности не сохраняется в базу данных, а добавляется в источник данных `airportsDs` экрана редактирования `DutyFree`.

Когда пользователь нажимает *OK* в https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/airports/airport/airport-edit.xml[экране редактирования аэропорта], изменённый экземпляр аэропорта сохраняется и в базу данных, и в https://github.com/cuba-platform/sample-model/blob/master/modules/web/src/com/company/sample/web/dutyfree/duty-free-edit.xml#L12[источник данных] `airportsDs` экрана редактирования `DutyFree`, так как сущность `Airport` является полностью независимой.

Пользователь может сохранять новые аэропорты или удалять их, и все изменения будут сохраняться в базу данных в отдельных тракзакциях, а также в источник данных `airportsDs`.

Когда пользователь нажимает *OK* в экране редактирования магазина, изменённый экземпляр `DutyFree` вместе со всеми измененными экземплярами `AirportDutyFree` отправляется на middleware в метод  <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции.

[[entity_inheritance]]
==== Наследование сущностей

++++
<div class="manual-live-demo-container">
    <a href="https://demo2.cuba-platform.com/model/open?screen=sample$Order.browse" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Рассмотрим пример использования наследования сущностей в приложении CUBA.

Рассмотрим типичный случай, когда у заказа могут быть заказчики разных типов - например, юридические и физические лица, или сущности Company и Individual, у которых есть общие атрибуты. Мы хотим хранить общие атрибуты в общей таблице, а специфичные атрибуты для каждого типа - в отдельных связанных таблицах.

Так, в модели данных мы создадим сущность `Client` как базовый класс, который будем хранить в таблице `SAMPLE_CLIENT`. Сущности `Company` и `Person` будут храниться в отдельных таблицах с внешним ключом, ссылающимся на базовую таблицу.

Суцщность `Order` (заказ) имеет ссылку на сущность `Client`. Поскольку заказчики могут быть нескольких типов, при создании нового заказа пользователь должен иметь возможность выбрать нужный тип.

image::cookbook/inheritance.png[align="center"]

Сущность {proj_model}/blob/master/modules/global/src/com/company/sample/entity/clients/Client.java[Client.java]:

* Стратегия наследования: `JOINED`
* Имя столбца дискриминатора `DTYPE` и его тип String оставляем по умолчанию
* Значение дискриминатора: `C`

Сущность {proj_model}/blob/master/modules/global/src/com/company/sample/entity/clients/Company.java[Company.java]:

* Родительский класс: `Client`
* Значение дискриминатора: `M`

Сущность: {proj_model}/blob/master/modules/global/src/com/company/sample/entity/clients/Person.java[Person.java]:

* Родительский класс: `Client`
* Значение дискриминатора: `P`

Контроллер экрана {proj_model}/blob/master/modules/web/src/com/company/sample/web/order/OrderEdit.java[OrderEdit.java] содержит визуальные компоненты и логику для выбора типа заказчика.


[[ui_recipes]]
=== Создание универсального UI

[[screen_layout_rules]]
==== Правила компоновки экранов

[[screen_layout_rules_positioning]]
===== Позиционирование компонентов

[[screen_layout_rules_size]]
Виды размеров::
+
--
Размеры <<gui_vcl,компонента>>, т.е. его <<gui_attr_width,ширина>> и <<gui_attr_height,высота>>, могут быть заданы следующих видов:

* По содержимому - `AUTO`
* Фиксированные (в пикселах) - `10px`
* Относительные (в процентах) - `100%`

image::cookbook/screen_layout_rules_1_ru.png[align="center"]
--

[[screen_layout_rules_size_auto]]
Размер по содержимому::
+
--
Компонент займет столько места, сколько нужно его содержимому.

Примеры:

* Компонент <<gui_Label,Label>> выбирает такой размер по размеру текста.
* <<gui_layouts,Контейнеры>> выбирают размер по сумме размеров всех расположенных в контейнере компонентов.

[source, xml]
.XML
----
<label width=”AUTO”/>
----

[source, java]
.Java
----
label.setWidth(Component.AUTO_SIZE);
----

Компоненты с размером по содержимому будут подстраивать размер во время компоновки экрана и при изменении размера содержимого.

image::cookbook/screen_layout_rules_2_ru.png[align="center"]
--

[[screen_layout_rules_size_fixed]]
Фиксированный размер::
+
--
Фиксированные размеры не предполагают изменения размера компонента во время исполнения.

[source, xml]
.XML
----
<vbox width=”320px” height=”240px”/>
----

[source, java]
.Java
----
vbox.setWidth(”320px”);
----

image::cookbook/screen_layout_rules_3.png[align="center"]
--

[[screen_layout_rules_size_relative]]
Относительные размеры::
+
--
Относительные размеры указывают, какой процент доступного компоненту места будет использован.

[source, xml]
.XML
----
<label width=”100%”/>
----

[source, java]
.Java
----
label.setWidth(”50%”);
----

Компонент с относительными размерами будет реагировать на изменение доступного места и изменять свой реальный размер на экране.

image::cookbook/screen_layout_rules_4_ru.png[align="center"]
--

[[screen_layout_rules_container]]
Особенности контейнеров::
+
--
По умолчанию контейнеры без установленного атрибута <<gui_attr_expand,expand>> выделяют для всех вложенных компонентов одинаковое количество места. Исключения: <<gui_BoxLayout_flowBox,flowBox>> и <<gui_HtmlBoxLayout,htmlBox>>.

Пример контейнера с одинаковой высотой компонентов по умолчанию:

[source, xml]
----
<layout>
    <button caption="Button"/>
    <button caption="Button"/>
</layout>
----

image::cookbook/screen_layout_rules_7.png[align="center"]

Компоненты и контейнеры при создании имеют высоту и ширину по содержимому. Некоторые контейнеры имеют другие значения высоты и ширины по умолчанию:

[options="header"]
|===============
|Контейнер                         |Ширина |Высота
|<<gui_BoxLayout_vbox,VBox>>       |100%   |AUTO
|<<gui_GroupBoxLayout,GroupBox>>   |100%   |AUTO
|<<gui_BoxLayout_flowBox,FlowBox>> |100%   |AUTO
|===============

Корневой элемент компоновки *layout* является вертикальным контейнером (`VBox`) и имеет 100% ширину и высоту 100%. В режиме диалога высота корневого элемента может быть `AUTO`.

Вкладка компонента <<gui_TabSheet,TabSheet>> (`tab`) является контейнером `VBox`.

Компонент `GroupBox` содержит `VBox` или `HBox` в зависимости от значения свойства <<gui_GroupBox_orientation,orientation>>.

Пример контейнера с высотой по содержимому:

[source, xml]
----
<layout>
    <vbox>
        <button caption="Button"/>
        <button caption="Button"/>
    </vbox>
</layout>
----

image::cookbook/screen_layout_rules_8.png[align="center"]

Пример контейнера с относительными размерами компонентов:

[source, xml]
----
<layout spacing="true">
    <groupBox caption="GroupBox" height="100%">
    </groupBox>
    <button caption="Button"/>
</layout>
----

image::cookbook/screen_layout_rules_9.png[align="center"]

Здесь `layout`, так же как `vbox` или `hbox`, выделяет равные части всем вложенным компонентам, а для `groupBox` указана высота 100%. Кроме того, `groupBox`  имеет 100% ширину по умолчанию, поэтому он занимает все доступное ему пространство.
--

[[screen_layout_rules_component]]
Особенности компонентов::
+
--
Для <<gui_Table,Table>> и <<gui_Tree,Tree>> рекомендуется задавать абсолютную или относительную высоту, иначе таблица/дерево может неограниченно вырасти при большом количестве строк/узлов.

Контейнер <<gui_ScrollBoxLayout,ScrollBox>> должен обязательно иметь заданные высоту и ширину (не `AUTO`). Внутри `ScrollBox` нельзя использовать 100% размеры в направлении, для которого необходима полоса прокрутки.

Ниже приведены примеры правильного использования `ScrollBox` с вертикальной и горизонтальной прокруткой. Если требуются обе полосы прокрутки, компоненты должны иметь и ширину, и высоту (`AUTO` или абсолютные значения).

image::cookbook/screen_layout_rules_5_ru.png[align="center"]
--

[[screen_layout_rules_expand]]
Опция expand::
+
--
Атрибут <<gui_attr_expand,expand>> контейнера позволяет указать, какому из компонентов предоставить максимальное доступное место.

Компоненту, указанному в `expand`, будет выставлен размер 100% в направлении роста контейнера (`VBox` — по вертикали, `HBox` — по горизонтали). При изменении размера контейнера изменять размер будет именно этот компонент.

[source, xml]
----
<vbox expand=”bigBox”>
    <vbox id=”bigBox”>
    </vbox>
    <label value=”Label”/>
</vbox>
----

image::cookbook/screen_layout_rules_6.png[align="center"]

`expand` работает по направлению роста контейнера, например:

[source, xml]
----
<layout spacing="true" expand="groupBox">
    <groupBox id="groupBox"
            caption="GroupBox" width="200px">
    </groupBox>
    <button caption="Button"/>
</layout>
----

image::cookbook/screen_layout_rules_10.png[align="center"]

В следующем примере используется вспомогательный элемент <<gui_Label,Label>> - spacer. Для него применяется `expand`, поэтому он занимает всё оставшееся в контейнере место.

[source, xml]
----
<layout expand="spacer">
    <textField caption="Number"/>
    <dateField caption="Date"/>
    <label id="spacer"/>
    <hbox spacing="true">
        <button caption="OK"/>
        <button caption="Cancel"/>
    </hbox>
</layout>
----

image::cookbook/screen_layout_rules_11.png[align="center"]
--

[[screen_layout_rules_margins]]
===== Отступы

[[screen_layout_rules_margin]]
Отступ от границ контейнера (margin)::
+
--
Атрибут <<gui_attr_margin,margin>> позволяет задать отступ вложенных компонентов от края контейнера.

Если задан `margin="true"`, то отступ применяется для всех сторон контейнера.

[source, xml]
----
<layout>
    <vbox margin="true" height="100%">
        <groupBox caption="Group"
                height="100%">
        </groupBox>
    </vbox>
    <groupBox caption="Group"
            height="100%">
    </groupBox>
</layout>
----

image::cookbook/screen_layout_rules_12.png[align="center"]

Можно также задать отступ для каждой из сторон отдельно (в порядке Верхний, Правый, Нижний, Левый). Пример использования только верхнего и нижнего отступа:

[source, xml]
----
<vbox margin="true,false,true,false">
----
--

[[screen_layout_rules_spacing]]
Отступ между компонентами контейнера (spacing)::
+
--
Атрибут <<gui_attr_spacing,spacing>> указывает, использовать ли отступ между вложенными компонентами по направлению роста контейнера.

image::cookbook/screen_layout_rules_13.png[align="center"]

[TIP]
====
Не используйте `margin` для эмуляции `spacing`. Spacing работает правильно в случаях, когда часть компонентов контейнера становится невидимой.
====

[source, xml]
----
<layout spacing="true">
    <button caption="Button"/>
    <button caption="Button"/>
    <button caption="Button"/>
    <button caption="Button"/>
</layout>
----

image::cookbook/screen_layout_rules_14.png[align="center"]
--

[[screen_layout_rules_alignment]]
===== Выравнивание

[[screen_layout_rules_align]]
Выравнивание компонентов в контейнере::
+
--
Для выравнивания компонентов в контейнере воспользуйтесь атрибутом <<gui_attr_align,align>>.

Пример расположения надписи по центру контейнера:

[source, xml]
----
<vbox height="100%">
    <label align="MIDDLE_CENTER"
            value="Label"/>
</vbox>
----

image::cookbook/screen_layout_rules_15.png[align="center"]

Компонент, для которого задан `align`, не должен иметь размер "100%" в направлении выравнивания. В контейнере должно быть доступное для компонента место, по размеру большее чем сам компонент. Именно в этом
пространстве будет выровнен компонент.

Пример выравнивания в доступном пространстве:

[source, xml]
----
<layout>
    <groupBox height="100%"
        caption="Group">
    </groupBox>
    <label align="MIDDLE_CENTER"
        value="Label"/>
</layout>
----

image::cookbook/screen_layout_rules_16.png[align="center"]
--

[[screen_layout_mistakes]]
===== Типовые ошибки компоновки

[[screen_layout_mistake_1]]
Ошибка №1. Указание относительных размеров для компонента в контейнере с размерами по содержимому::
+
--
Пример неправильной компоновки c явным относительным размером:

image::cookbook/screen_layout_rules_17.png[align="center"]

В этом примере для надписи задана высота 100%. При этом у контейнера `VBox` по умолчанию используется высота `AUTO`, то есть по содержимому.

Пример неправильной компоновки c `expand`:

image::cookbook/screen_layout_rules_18.png[align="center"]

Expand неявно задаёт относительную высоту 100% для `label`, что, как и в примере выше, неверно.
В таких случаях экран может выглядеть некорректно, часть компонентов может пропадать или иметь нулевые размеры. При возникновении проблем с компоновкой в первую очередь проверьте правильность указания
относительных размеров.
--

[[screen_layout_mistake_2]]
Ошибка №2. Вложенные в ScrollBox компоненты имеют 100% размеры::
+
--
Пример неправильной компоновки:

image::cookbook/screen_layout_rules_19.png[align="center"]

При возникновении таких ошибок полосы прокрутки в `ScrollBox` не будут появляться при превышении вложенными компонентами размеров области прокрутки.

image::cookbook/screen_layout_rules_20_ru.png[align="center"]
--

[[screen_layout_mistake_3]]
Ошибка №3. Выравнивание для компонентов при отсутствии доступного места::
+
--
Пример неправильной компоновки:

image::cookbook/screen_layout_rules_21.png[align="center"]

В этом примере `HBox` имеет размеры по содержимому, поэтому заданное для надписи выравнивание не оказывает никакого эффекта.

image::cookbook/screen_layout_rules_22_ru.png[align="center"]
--

[[screen_params_recipe]]
==== Передача параметров в экран

++++
<div class="manual-live-demo-container">
    <a href="https://demo3.cuba-platform.com/ui/open?screen=sample$Order.edit" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Передача параметров из одного экрана в другой является одной из самых частых задач в разработке UI. Рассмотрим типовые решения этой задачи на примере усовершенствованного демо-приложения https://demo3.cuba-platform.com[sample-sales].

Параметры могут быть переданы из методов `<<abstractFrame_openWindow,openWindow()>>`, `openLookup()` и `openEditor()` одного экрана в метод `<<abstractFrame_init,init()>>` другого экрана. Предположим, что мы хотим отфильтровать список продуктов в экране просмотра сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/Product.java[Product], передав в него некоторые параметры из экрана редактирования сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/Order.java[Order].

* Экран редактирования https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/order/OrderEdit.java[OrderEdit] содержит метод `addOrderLine()`, вызываемый действием `addOrderLine`. Этот метод <<abstractFrame_openWindow,открывает>> экран выбора продукта, передавая в него два параметра:
+
** текущий выбранный покупатель,
+
** список уже добавленных продуктов.
+
Когда пользователь выбирает продукт, открывается экран https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/order/QuantityDialog.java[QuantityDialog], где пользователь вводит количество единиц выбранного продукта. После закрытия этого экрана создаётся новый экземпляр сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/OrderLine.java[OrderLine] и затем добавляется в таблицу строк заказа.
+
[source, java]
----
include::{sourcesdir}/cookbook/window_params.java[]
----

* Экран просмотра https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/product/ProductBrowse.java[ProductBrowse] изменяет свой <<datasource_query_params,источник данных>> в зависимости от переданного покупателя. Если покупатель передан, в таблице отображаются только продукты, имеющие ссылку на этого покупателя либо не связанные ни с одним покупателем. Параметры инжектируются в контроллер экрана с помощью аннотации <<screen_controller_injection_params,@WindowParam>>:
+
[source, java]
----
include::{sourcesdir}/cookbook/window_params_2.java[]
----
+
Также, когда экран выбора продукта открывается для создания строк заказа, в нём программно создаётся и применяется фильтр, который отображает только те продукты, которые ещё не были использованы в этом заказе.
+
[TIP]
====
<<gui_Filter,Фильтры>> нужно создавать в методе `<<abstractWindow_ready,ready()>>`, так как на момент вызова метода `<<abstractFrame_init,init()>>` фильтры ещё не инициализированы.
====
+
[source, java]
----
include::{sourcesdir}/cookbook/window_params_3.java[]
----
+
При создании XML-дескриптора фильтра вы можете опираться на компонент `filterComponent` в {xsd_url}/window.xsd или найти похожий фильтр в столбце `XML` таблицы `SEC_FILTER` в базе данных приложения.

[[screen_params_recipe_picker]]
===== Передача параметров через PickerField

Компонент <<gui_PickerField,PickerField>> и компоненты, его расширяющие, также могут использоваться для передачи параметров в открываемый экран. Параметры задаются для <<picker_actions,действий PickerField>>: `LookupAction` и `OpenAction`.

Допустим, мы хотим изменять заголовок экрана выбора сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/Customer.java[Customer], если он был открыт из компонента `PickerField` в экране редактирования сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/Product.java[Product].

 * В экране https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/product/ProductEdit.java[ProductEdit] мы указываем параметры для действия `PickerField` <<lookupAction,LookupAction>>, используя метод `setLookupScreenParams()`:
+
[source, java]
----
include::{sourcesdir}/cookbook/window_params_6.java[]
----

* Затем мы инжектируем переданные параметры и используем их в методе <<abstractFrame_init,init()>> экрана https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/customer/CustomerBrowse.java[CustomerBrowse]:
+
[source, java]
----
include::{sourcesdir}/cookbook/window_params_7.java[]
----

Теперь, если экран выбора покупателя открывается из редактора продукта, мы сразу можем увидеть, что это за продукт.

[[screen_params_return]]
==== Возврат значений из экрана

<<abstractFrame_openWindow,Методы>>, используемые для открытия экранов (`openWindow()`, `openLookup()`, `openEditor()`) можно использовать и для возврата значений из этих экранов.

Идея состоит в том, чтобы из этих методов вернуть ссылку на контроллер открываемого экрана, а к этой ссылке добавить слушатель `CloseListener`, который будет обрабатывать значения после закрытия экрана.

Экран https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/order/OrderEdit.java[OrderEdit] демонстрирует два способа выбора сущности https://github.com/cuba-platform/ui-recipes/blob/master/modules/global/src/sample/entity/Customer.java[Customer]: из экрана выбора (lookup) и из независимого экрана, и оба способа позволяют вернуть экземпляр `Customer`.

Возврат значения из экрана выбора::
+
--
Метод `openLookup()` позволяет задать обработчик сущностей, выбранных в открываемом экране. С помощью этого обработчика мы установим выбранного покупателя для редактируемого экземпляра сущности `Order`.

[source, java]
----
include::{sourcesdir}/cookbook/window_params_4.java[]
----
--

Возврат значения из обычного экрана::
+
--
Метод `openWindow()` в следующем примере открывает список покупателей в простом диалоговом окне. Слушатель `CloseWithCommitListener` получает сообщение о <<abstractWindow_close,закрытии>> экрана действием с `Window.COMMIT_ACTION_ID` и устанавливает выбранного покупателя для редактируемого экземпляра сущности `Order`.

[source, java]
----
include::{sourcesdir}/cookbook/window_params_5.java[]
----
--

[[oto_single_editor]]
==== Композиция One-to-One в одном редакторе

++++
<div class="manual-live-demo-container">
    <a href="https://demo3.cuba-platform.com/ui/open?screen=sample$Customer.edit" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Сущности, связанные композицией с типом <<composition_oto_recipe,один-к-одному>>, часто бывает удобно создавать в одном общем экране редактирования. Рассмотрим, как можно реализовать такой экран, на примере отношений сущностей https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/customer/Customer.java[Customer] и https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/customer/CustomerDetails.java[CustomerDetails].

* https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/customer/customer-edit.xml[customer-edit.xml] содержит основной источник данных `customerDs` и вложенный в него `detailsDs`:
+
--
[source, xml]
----
include::{sourcesdir}/cookbook/oto_single_editor.xml[]
----

Поля для редактирования обеих сущностей сгруппированы в один компонент `fieldGroup`, где отдельные поля привязаны к вложенному источнику данных:

[source, xml]
----
include::{sourcesdir}/cookbook/oto_single_editor_2.xml[]
----
--

* В контроллере экрана https://github.com/cuba-platform/ui-recipes/blob/master/modules/web/src/sample/web/customer/CustomerEdit.java[CustomerEdit] мы переопределяем метод `initNewItem()`. В нём создаём новый экземпляр `CustomerDetails` и связываем его с только что созданным экземпляром `Customer`:
+
--
[source, java]
----
include::{sourcesdir}/cookbook/oto_single_editor_3.java[]
----

Напоследок обработаем ситуацию, когда пользователь нажимает *Create*, а затем закрывает редактор экрана без каких-либо изменений в полях покупателя. По умолчанию, пользователю будет предложено сохранить или отменить изменения, так как `detailsDs` уже содержит пустой экземпляр `CustomerDetails`, а значит, метод `isModified()` вернёт `true`. Чтобы предотвратить появление такого диалога для пустых сущностей, заставим метод `isModified()` принимать во внимание только изменения в главном источнике данных экрана:

[source, java]
----
include::{sourcesdir}/cookbook/oto_single_editor_4.java[]
----
--

Теперь обе сущности можно создавать и редактировать в одном экране.

[[data_recipes]]
=== Загрузка и сохранение данных

В данном разделе рассматриваются различные способы загрузки и сохранения данных в БД.

[[dm_vs_em]]
==== DataManager vs. EntityManager

И <<dataManager,DataManager>> и <<entityManager,EntityManager>> предназначены для выполнения операций с сущностями (CRUD). Ниже приведены различия между этими интерфейсами.

|===
|DataManager |EntityManager

|DataManager доступен и на среднем слое и на клиентском <<app_tiers,уровне>>.
|EntityManager доступен только на среднем слое.

|DataManager является синглтон-бином.
|Ссылку на EntityManager необходимо получать через интерфейс <<persistence,Persistence>>.

|DataManager содержит несколько высокоуровневых методов для работы с <<entity_states,detached>> сущностями: `load()`, `loadList()`, `reload()`, `commit()`.
|EntityManager в большой степени повторяет стандартный `javax.persistence.EntityManager`.

|===

DataManager на самом деле делегирует выполнение реализациям <<data_store,DataStore>>, поэтому особенности DataManager, перечисленные ниже, актуальны только для наиболее часто встречающегося случая, когда вы работаете с сущностями, хранящимися в реляционной базе данных.

|===
|DataManager |EntityManager

|DataManager всегда стартует новую <<transactions,транзакцию>> внутри.
|Для работы с EntityManager необходима открытая транзакция.

|DataManager загружает _частичные_ сущности в соответствие с <<views,представлением>>. Есть некоторые исключения, см. <<dm_partial_entities,подробности>>.
|EntityManager всегда загружает все локальные атрибуты. Если используется представление, оно влияет только на загрузку ссылочных атрибутов. См. <<em_partial_entities,подробности>>.

|DataManager выполняет только JPQL запросы. Кроме того, он имеет отдельные методы для загрузки сущностей: `load()`, `loadList()`; и скалярных и агрегатных значений: `loadValues()`.
|EntityManager может выполнять любые JPQL или native (SQL) запросы.

|DataManager проверяет <<dm_security,права доступа>>, когда вызывается с клиентского уровня.
|EntityManager не проверяет права доступа.

|===

При работе на клиентском уровне доступен только `DataManager`. На среднем слое, используйте `EntityManager` когда необходимо реализовать атомарную логику внутри транзакции или если его интерфейс лучше подходит для решения задачи. В противном случае, на среднем слое можно использовать любой из интерфейсов на выбор.

Если вам нужно обойти ограничения `DataManager` при работе на клиентском уровне, создайте свой <<services,сервис>> и используйте `EntityManager` для работы с данными. В сервисе можно проверять права пользователя с помощью интерфейса <<security,Security>> и возвращать клиенту данные в виде персистентных или неперсистентных сущностей или произвольных значений.


[[rest_api_v2_usage_example]]
=== Использование REST API

Данный раздел содержит ряд примеров использования <<rest_api_v2,REST API>>.

Детальная информация о методах REST API описана согласно спецификации http://swagger.io/specification[Swagger] и доступна по адресу {rest_swagger_url}.

[[rest_api_v2_ex_get_token]]
==== Получение OAuth токена

OAuth токен необходим для выполнения любого метода REST API (кроме случая <<rest_api_v2_anonymous, анонимного доступа к REST API>>). Получить токен можно выполнив POST запрос по адресу

`\http://localhost:8080/app/rest/v2/oauth/token`

Доступ к данному URL защищен с помощью базовой аутентификации с использованием идентификатора и пароля клиента REST API. Обратите внимание, что это не логин и пароль пользователя приложения. Идентификатор и пароль клиента REST API заданы в свойствах приложения <<cuba.rest.client.id, cuba.rest.client.id>> и <<cuba.rest.client.secret, cuba.rest.client.secret>> (значения по умолчанию для этих свойств: `client` и `secret`). Заголовок Authorization запроса на получение токена должен содержать логин и пароль клиента, разделенные символом ":" и закодированные в base64.

Тип запроса на получение токена должен быть `application/x-www-form-urlencoded`, кодировка `UTF-8`.

Запрос должен содержать следующие параметры:

* `grant_type` - всегда значение `password`.
* `username` - логин пользователя приложения.
* `password` - пароль пользователя приложения.

[source, httprequest]
----
include::{sourcesdir}/rest/rest-access-token-request.txt[]
----

Метод возвращает JSON объект:

[source, json]
----
include::{sourcesdir}/rest/rest-access-token-response.json[]
----

Значение токена содержится в поле `access_token`

Чтобы использовать токен, его нужно передать в заголовке запроса `Authorization` с типом `Bearer`, например:

[source, plain]
----
Authorization: Bearer 29bc6b45-83cd-4050-8c7a-2a8a60adf251
----

Свойство `refresh_token` содержит значение refresh токена. Он не может быть использован для доступа к защищённым ресурсам приложения, но он имеет большее время жизни по сравнению с access токеном и используется для получения нового access токена, когда старый токен истек.

Запрос на получение нового access токена с помощью refresh токена должен содержать следующие параметры:

* `grant_type` - `refresh_token`.
* `refresh_token` - значения refresh токена.

[source, httprequest]
----
include::{sourcesdir}/rest/rest-access-token-using-refresh-request.txt[]
----

См. также следующие свойства приложения, имеющие отношение к токенам:

* <<cuba.rest.client.tokenExpirationTimeSec,cuba.rest.client.tokenExpirationTimeSec>>

* <<cuba.rest.client.refreshTokenExpirationTimeSec,cuba.rest.client.refreshTokenExpirationTimeSec>>

* <<cuba.rest.client.authorizedGrantTypes,cuba.rest.client.authorizedGrantTypes>>

[[rest_api_v2_ldap]]
==== Аутентификация LDAP в REST API

Для настройки LDAP аутентификации в REST API используются следующие свойства приложения:

* `cuba.rest.ldap.enabled` - определяет включен ли вход по LDAP логину/паролю.

* `cuba.rest.ldap.urls` - URL сервера LDAP.

* `cuba.rest.ldap.base` - base DN поиска имен пользователей.

* `cuba.rest.ldap.user` - distinguished name системного пользователя, имеющего право на чтение информации из LDAP.

* `cuba.rest.ldap.password` - пароль системного пользователя, заданного свойством `cuba.rest.ldap.user`.

* `cuba.rest.ldap.userLoginField` - название атрибута пользователя в LDAP, значение которого соответствует логину пользователя. По умолчанию `sAMAccountName` (подходит для Active Directory).

Пример содержимого файла <<app_properties_files,local.app.properties>>:

[source, properties]
----
cuba.rest.ldap.enabled = true
cuba.rest.ldap.urls = ldap://192.168.1.1:389
cuba.rest.ldap.base = ou=Employees,dc=mycompany,dc=com
cuba.rest.ldap.user = cn=System User,ou=Employees,dc=mycompany,dc=com
cuba.rest.ldap.password = system_user_password
----

Получить OAuth токен можно выполнив POST запрос по адресу:

`\http://localhost:8080/app/rest/v2/ldap/token`

Доступ к данному URL защищен с помощью базовой аутентификации с использованием идентификатора и пароля клиента REST API. Обратите внимание, что это не логин и пароль пользователя приложения. Идентификатор и пароль клиента REST API заданы в свойствах приложения <<cuba.rest.client.id, cuba.rest.client.id>> и <<cuba.rest.client.secret, cuba.rest.client.secret>> (значения по умолчанию для этих свойств: `client` и `secret`). Заголовок `Authorization` запроса на получение токена должен содержать логин и пароль клиента, разделенные символом ":" и закодированные в base64.

Запрос должен содержать следующие параметры (соответствуют параметрам стандартной аутентификации):

* `grant_type` - всегда значение `password`.
* `username` - логин пользователя приложения.
* `password` - пароль пользователя приложения.

Тип запроса на получение токена должен быть `application/x-www-form-urlencoded`, кодировка `UTF-8`.

Стандартная аутентификация может быть отключена при помощи свойства `cuba.rest.standardAuthenticationEnabled`:

[source, properties]
----
cuba.rest.standardAuthenticationEnabled = false
----

[[rest_api_v2_custom_auth]]
==== Собственный механизм аутентификации

Различные механизмы аутентификации могут предоставлять токен по ключу, по ссылке, по логину и паролю LDAP и т.д. Стандартный механизм аутентификации в REST API изменить нельзя, но можно создать свой механизм. Для этого необходимо создать REST-контроллер, который предоставит свой URL для входа в приложение.

В этом примере мы рассмотрим механизм аутентификации, позволяющий получить OAuth-токен по промо-коду. За основу возьмём приложение, содержащее сущность `Coupon` (Купон) с атрибутом `code` (промо-код). Значение этого атрибута мы будем передавать в качестве параметра аутентификации в GET-запросе.

. Создайте сущность `Coupon` и добавьте ей атрибут `code`:
+
[source, java]
----
@Column(name = "CODE", unique = true, length = 4)
protected String code;
----

. Создайте нового <<users,пользователя>> с логином *promo-user*, от лица которого будет выполняться аутентификация по промо-коду.

. В корневом каталоге модуля *web* (`com.company.demo`) создайте новый файл конфигурации Spring `rest-dispatcher-spring.xml` со следующим содержанием:
+
[source, xml]
----
include::{sourcesdir}/rest/rest-dispatcher-spring-ex.xml[]
----

. Ссылку на этот файл укажите в свойстве приложения `cuba.restSpringContextConfig` в файле `modules/web/src/web-app.properties`:
+
[source, properties]
----
include::{sourcesdir}/rest/rest-dispatcher-spring.properties[]
----

. Создайте пакет `rest` в корневом каталоге модуля *web*, а в нём - свой контроллер Spring MVC. В контроллере используйте бин `OAuthTokenIssuer`, который позволяет сгенерировать и выдать REST API токен после аутентификации:
+
[source, java]
----
include::{sourcesdir}/rest/customRestController.java[]
----

. Исключите пакет `rest` из сканирования в модулях *web/core*: это необходимо, так как бин `OAuthTokenIssuer` доступен только внутри контекста REST API, и сканирование его в контексте приложения будет вызывать ошибку.
+
[source, xml]
----
include::{sourcesdir}/rest/web-spring-ex.xml[]
----

. Теперь пользователи могут получать код доступа OAuth2 через обычный запрос GET HTTP, передавая значение промо-кода в параметре `code`:
+
`\http://localhost:8080/app/rest/auth-code?code=A325`
+
Результат:
+
  {"access_token":"74202587-6c2b-4d74-bcf2-0d687ea85dca","token_type":"bearer","expires_in":43199,"scope":"rest-api"}
+
Теперь полученный access token нужно передавать в REST API, как описано в общей документации.

[[rest_api_v2_social_login]]
===== Social Login в REST API

Механизм авторизации через социальные сети, или social login, также можно использовать в REST API. Исходный код приложения, описанного в этом примере, доступен на https://github.com/cuba-platform/sample-social-login/[GitHub], а сам пример описан в разделе <<social_login>>. Ниже приведены ключевые моменты этого примера, позволяющие получить OAuth-токен через аккаунт Facebook.

. Создайте пакет `restapi` в корневом каталоге модуля *web* и поместите в него собственный контроллер Spring MVC. Контроллер должен содержать два основных метода: `get()`, возвращающий `ResponseEntity`, и `login()`, в котором мы будем получать OAuth-токен.
+
--
[source,java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/restapi/FacebookAuthenticationController.java[FacebookAuthenticationController.java]
----
include::{sourcesdir}/rest/social_login_rest_1.java[]
----

Здесь мы проверяем переданный код Facebook, получаем код доступа и издаём токен с помощью `OAuthTokenIssuer`:

[source,java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/restapi/FacebookAuthenticationController.java[FacebookAuthenticationController.java]
----
include::{sourcesdir}/rest/social_login_rest_2.java[]
----
--

. Исключите пакет `restapi` из сканирования в модулях *web/core*: это необходимо, так как бин `OAuthTokenIssuer` доступен только внутри контекста REST API, и сканирование его в контексте приложения будет вызывать ошибку.
+
[source, xml]
----
include::{sourcesdir}/rest/social_login_rest_5.xml[]
----

. Создайте файл `facebook-login-demo.html` в каталоге проекта `modules/web/web/VAADIN`. Он будет содержать JavaScript-код, выполняющийся на HTML-странице:
+
--
[source, html]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/web/VAADIN/facebook-login-demo.html[facebook-login-demo.html]
----
include::{sourcesdir}/rest/social_login_rest_3.html[]
----

В этом скрипте мы попробуем залогиниться через Facebook. Сначала удаляем лишний код из URL, затем передаём код в REST API для получения OAuth-токена, и в случае успешной аутентификации мы сможем загружать и сохранять данные как обычно:

[source, js]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/web/VAADIN/facebook-login-demo.html[facebook-login-demo.html]
----
include::{sourcesdir}/rest/social_login_rest_4.js[]
----

Другой пример использования JavaScript-кода в приложениях CUBA вы можете найти в разделе <<rest_api_v2_ex_javascript_usage>>.
--

[[rest_api_v2_ex_get_entities_list]]
==== Получение списка экземпляров сущности

Предполжим, в системе имеется сущность `sales$Order`, и необходимо получить список экземляров этой сущности. При этом, необходимо получить не все записи, а 50 записей, начиная с сотой (для отображения третьей странице в каком-либо списке клиентского приложения). Кроме простых атрибутов сущности `sales$Order` результат должен содержать данные о клиенте (поле `customer`). Заказы должны быть отсортированы по дате.

Базовый URL для получения списка экземпляров сущности `sales$Order`:

`\http://localhost:8080/app/rest/v2/entities/sales$Order`

Для выполнения описанных выше условий необходимо задать параметры запроса:

* *view* - <<views, представление>>, с которым должны быть загружены сущности. В нашем примере представление `order-edit-view` содержит ссылку на `customer`.
* *limit* - количество возвращаемых экземпляров.
* *offset* - позиция первого извлеченного элемента.
* *sort* - имя атрибута сущности, по которому будет произведена сортировка.

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*:

  Authorization: Bearer 29bc6b45-83cd-4050-8c7a-2a8a60adf251

В итоге получаем следующий *GET* http-запрос:

`\http://localhost:8080/app/rest/v2/entities/sales$Order?view=order-edit-view&limit=50&offset=100&sort=date`

Ответ будет выглядеть следующим образом:

[source, json]
----
include::{sourcesdir}/rest/rest-orders-list-response.json[]
----

Обратите внимание, что для каждой сущности загружаются атрибуты `_entityName` с именем сущности и `_instanceName`, содержащий результат вычисления <<namePattern_annotation, короткого имени>> для сущности.

[[rest_api_v2_ex_create_entity]]
==== Создание экземпляра сущности

Для создания нового экземпляра сущности `sales$Order` необходимо выполнить *POST* запрос по адресу:

`\http://localhost:8080/app/rest/v2/entities/sales$Order`

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

Тело запроса должно содержать JSON объект, описывающий новый экземпляр, например:

[source, json]
----
include::{sourcesdir}/rest/rest-create-order-request.json[]
----

В теле запроса передается коллекция позиций заказа `items` и ссылка на клиента `customer`. Рассмотрим, как будут обработаны эти атрибуты.

Саначала посмотрим на класс `Order`:

[source, java]
----
include::{sourcesdir}/features/Order.java[]
----

В сущности `Order` коллекция `items` аннотирована <<composition_annotation, @Composition>>. Методы создания и обновления сущности REST API создают новые экземпляры для всех элементов таких коллекций. Т.е. вместе с заказом (`Order`) будет создано две позиции заказа (`OrderItem`).

Ссылка `customer` не имеет аннотации @Composition, поэтому метод REST API попытается найти клиента с переданным идентификатором и проставить его в поле `customer`. Если клиент не будет найден, заказ не будет создан и метод вернет ошибку.

В случае успеха возвращается полный граф созданной сущности:

[source, json]
----
include::{sourcesdir}/rest/rest-create-order-response.json[]
----

[[rest_api_v2_ex_update_entity]]
==== Изменение существующего экземпляра сущности

Для изменения экземпляра сущности `sales$Order` необходимо выполнить *PUT* запрос по адресу:

`\http://localhost:8080/app/rest/v2/entities/sales$Order/5d7ff8e3-7828-ba94-d6ba-155c5c4f2a50`

Последняя часть запроса здесь - это идентификатор изменяемой сущности.

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

В теле запроса необходимо передать JSON объект, содержащий только поля, которые мы хотим изменить, например:

[source, json]
----
include::{sourcesdir}/rest/rest-update-order-request.json[]
----

В теле ответа будет возвращена измененная сущность:

[source, json]
----
include::{sourcesdir}/rest/rest-update-order-response.json[]
----

[[rest_api_v2_ex_query_get]]
==== Выполнение JPQL-запроса (GET)

Перед выполнением запроса с помощью REST API необходимо описать его в <<rest_api_v2_queries_config, конфигурационном файле>>. В корневом пакете модуля *web* (например, `com.company.sales`) необходимо создать файл `rest-queries.xml`. Затем этот файл объявляется в файле свойств приложения модуля *web* (web-app.properties):

[source, properties]
----
cuba.rest.queriesConfig = +com/company/sales/rest-queries.xml
----

Содержимое файла `rest-queries.xml`:

[source, xml]
----
include::{sourcesdir}/rest/sales-rest-queries.xml[]
----

Для выполнения JPQL запроса, необходимо выполнить *GET* http-запрос к REST API:

`\http://localhost:8080/app/rest/v2/queries/sales$Order/ordersAfterDate?startDate=2016-11-01&endDate=2017-11-01`

Части URL:

* `sales$Order` - имя извлекаемой сущности.
* `ordersAfterDate` - имя запроса из конфигурационного файла.
* `startDate` и `endDate` - параметры запроса со значениями.

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

Метод возвращает JSON-массив со списком извлеченных экземпляров сущности:

[source, json]
----
include::{sourcesdir}/rest/rest-ordersAfterDate-query-response.json[]
----

Список других возможных параметров для метода выполнения запросов можно посмотреть в {rest_swagger_url}[Swagger документации].

[[rest_api_v2_ex_query_post]]
==== Выполнение JPQL-запроса (POST)

JPQL-запрос также может быть выполнен с помощью POST-запроса. Это необходимо для случая, когда параметр JPQL-запроса является коллекцией. В файле конфигурации JPQL-запросов для REST API тип параметра-коллекции должен заканчиваться символами `[]`: `java.lang.String[]`, `java.util.UUID[]` и т.п.

[source, xml]
----
include::{sourcesdir}/rest/sales-rest-queries-post.xml[]
----

Параметры JPQL-запроса должны быть переданы в теле HTTP-запроса в JSON map:

[source, json]
----
include::{sourcesdir}/rest/rest-post-query.json[]
----

URL POST-запроса:

`\http://localhost:8080/app/rest/v2/queries/sales$Order/ordersByIds?returnCount=true`

[[rest_api_v2_ex_service_get]]
==== Вызов метода сервиса (GET)

Предположим, в системе имеется <<services, сервис>> OrderService, реализация которого выглядит следующим образом:

[source, java]
----
include::{sourcesdir}/features/OrderServiceBean.java[]
----

Перед выполнением метода сервиса с помощью REST API необходимо разрешить его вызов в <<rest_api_v2_services_config, конфигурационном файле>>. В корневом пакете модуля *web* (например, `com.company.sales`) необходимо создать файл `rest-services.xml`. Затем этот файл объявляется в файле свойств приложения модуля *web* (web-app.properties):

[source, properties]
----
cuba.rest.servicesConfig = +com/company/sales/rest-services.xml
----

Содержимое файла `rest-services.xml`:

[source, xml]
----
include::{sourcesdir}/rest/sales-rest-services.xml[]
----

Для вызова метода сервиса, необходимо выполнить *GET* http-запрос к REST API вида:

`\http://localhost:8080/app/rest/v2/services/sales_OrderService/calculatePrice?orderNumber=00001`

Части URL:

* `sales_OrderService` - имя сервиса
* `calculatePrice` - имя метода сервиса
* `orderNumber` - аргумент метода со значением

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

Метод сервиса может вернуть как простой тип данных, так и сущность, коллекцию сущностей или произвольный POJO. В нашем случае метод возвращает BigDecimal, поэтому в теле ответа нам вернется число:

  39.2

[[rest_api_v2_ex_service_post]]
==== Вызов метода сервиса (POST)

REST API позволяет выполнять методы сервисов, аргументами которых являются не только простые типы, но также:

* сущности
* коллекции сущностей
* произвольные POJO

Небольшой пример. Предположим, в сервис `OrderService`, созданный в предыдущем разделе, добавлен следующий метод:

[source, java]
----
@Override
public OrderValidationResult validateOrder(Order order, Date validationDate){
    OrderValidationResult result=new OrderValidationResult();
    result.setSuccess(false);
    result.setErrorMessage("Validation of order "+order.getNumber()+" failed. validationDate parameter is: "+validationDate);
    return result;
}
----

Класс `OrderValidationResult` выглядит следующим образом:

[source, java]
----
include::{sourcesdir}/features/OrderValidationResult.java[]
----

Новый метод сервиса принимает сущность `Order` в качестве первого аргумента и возвращает POJO.

Перед вызовом данного метода с помощью REST API необходимо разрешить его, добавив запись в конфигурационный файл `rest-services.xml` (его создание было рассмотрено в <<rest_api_v2_ex_service_get>>):

[source, xml]
----
include::{sourcesdir}/rest/sales-rest-services-2.xml[]
----

Метод `validateOrder` сервиса вызывается *POST* запросом по адресу:

`\http://localhost:8080/app/rest/v2/services/sales_OrderService/validateOrder`

Параметры в случае POST передаются в теле запроса в JSON объекте. Каждое поле JSON объекта соответствует аргументу метода сервиса:

[source, json]
----
include::{sourcesdir}/rest/rest-validateOrder-service-request.json[]
----

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

Метод вернет сериализованный POJO:

[source, json]
----
include::{sourcesdir}/rest/rest-validateOrder-service-response.json[]
----

[[rest_api_v2_ex_file_download]]
==== Скачивание файлов

При {rest_swagger_url}/#!/Files/get_files_id[скачивании файла] передавать токен в заголовке запроса часто оказывается неудобно. Хочется иметь URL для скачивания, который можно подставить например в атрибут *src* тега *img*. В этом случае передача <<<<rest_api_v2_ex_get_token,OAuth-токена>> возможна в самом запросе в параметре с именем *access_token*.

Например, в систему загружено изображение. Идентификатор соответствующего FileDescriptor - `44809679-e81c-e5ae-dd81-f56f223761d6`.

В этом случае URL для загрузки изображения будет выглядеть так:

`\http://localhost:8080/app/rest/v2/files/44809679-e81c-e5ae-dd81-f56f223761d6?access_token=a2f0bb4e-773f-6b59-3450-3934cbf0a2d6`

[[rest_api_v2_ex_file_upload]]
==== Загрузка файлов

Для загрузки файлов вам нужно получить <<rest_api_v2_ex_get_token,OAuth-токен>>, который понадобится в дальнейших запросах.

Используем простую форму для загрузки:

[source, html]
----
<form id="fileForm">
    <h2>Select a file:</h2>
    <input type="file" name="file" id="fileUpload"/>
    <br/>
    <button type="submit">Upload</button>
</form>

<h2>Result:</h2>
<img id="uploadedFile" src="" style="display: none"/>
----

Далее используем jQuery, чтобы получить JSON с объектом {rest_swagger_url}/#!/Files/post_files[data], который, по сути, представляет собой новый `FileDescriptor`. Использовать загруженный файл мы можем по идентификатору созданного экземпляра `FileDescriptor` с токеном в качестве параметра:

[source, js]
----
$('#fileForm').submit(function (e) {
    e.preventDefault();

    var file = $('#fileUpload')[0].files[0];
    var url = 'http://localhost:8080/app/rest/v2/files?name=' + file.name; // send file name as parameter

    $.ajax({
        type: 'POST',
        url: url,
        headers: {
            'Authorization': 'Bearer ' + oauthToken // add header with access token
        },
        processData: false,
        contentType: false,
        dataType: 'json',
        data: file,
        success: function (data) {
            alert('Upload successful');

            $('#uploadedFile').attr('src',
                'http://localhost:8080/app/rest/v2/files/' + data.id + '?access_token=' + oauthToken); // update image url
            $('#uploadedFile').show();
        }
    });
});
----

[[rest_api_v2_ex_javascript_usage]]
==== Пример использования из JavaScript

В данном разделе приведен пример использования REST API v2 из JavaScript, выполняющегося на HTML-странице. На странице изначально отображается форма логина, а после успешного входа - соответствующее сообщение и список сущностей.

Для простоты, в данном примере для хранения файлов HTML/CSS/JavaScript используется каталог `modules/web/web/VAADIN`, так как соответствующий каталог развернутого веб-приложения используется для выдачи статических ресурсов. Поэтому никаких настроек на сервере Tomcat делать не требуется. Результирующий URL будет начинаться с `++http://localhost:8080/app/VAADIN++`, так что данный вариант не стоит использовать в реальном приложении, вместо этого создайте отдельное веб-приложение со своим контекстом.

Загрузите https://jquery.com/download[jQuery] и http://getbootstrap.com/getting-started/#download[Bootstrap] и скопируйте в каталог `modules/web/web/VAADIN` вашего проекта. Создайте файлы `customers.html` и `customers.js`, так что содержимое каталога должно быть примерно таким:

[source, plain]
----
bootstrap.min.css
customers.html
customers.js
jquery-3.1.1.min.js
----

Содержимое файла `customers.html`:

[source, html]
----
include::{sourcesdir}/rest/rest_customers.html[]
----

Содержимое файла `customers.js`:

[source, javascript]
----
include::{sourcesdir}/rest/rest_customers_script.js[]
----

Имя пользователя и пароль из полей ввода передаётся на сервер POST-запросом с закодированными Base64 клиентскими именем и паролем в заголовке `Authorization`, как описано в разделе <<rest_api_v2_ex_get_token>>. В случае успешной аутентификации, страница получает с сервера значение токена доступа, токен записывается в переменную `oauthToken`, скрывается блок `loginForm` и отображается блок `loggedInStatus`.

Чтобы отобразить список покупателей, на сервер отправляется <<rest_api_v2_ex_get_entities_list,запрос на получение списка экземпляров>> сущности `sales$Customer`, передавая значение `oauthToken` в заголовке `Authorization`.

Если запрос выполнен, блок `customers` отображается на экране, и маркированный список `customersList` заполняется элементами, содержащими значения атрибутов name и email сущности Customer.

image::rest_js_1.png[align="center"]

image::rest_js_2.png[align="center"]

[[rest_api_v2_ex_localized_messages]]
==== Получение локализованных сообщений

REST API позволяет получить локализованные заголовки для сущностей, перечислений и их атрибутов.

Например, чтобы получить локализованные сообщения для сущности `sec$User`, необходимо выполнить следующий *GET* запрос:

`\http://localhost:8080/app/rest/v2/messages/entities/sec$User`

OAuth-токен должен быть передан в заголовке запроса `Authorization` с типом *Bearer*.

Явно указать локаль запроса можно с помощью http-заголовка *Accept-Language*.

Ответ будет выглядеть следующим образом:

[source, json]
----
include::{sourcesdir}/rest/rest-user-messages-response.json[]
----

Для получения списка локализованных сообщений для перечисления используется следующий запрос:

`\http://localhost:8080/app/rest/v2/messages/enums/com.haulmont.cuba.security.entity.RoleType`

Если из URL убрать часть с именем сущности или перечисления, то будут возвращены локализованные сообщения для всех сущностей или перечислений.

[[rest_api_v2_ex_json_transformations]]
==== Примеры версионирования модели данных

Атрибут сущности переименован::
+
--
Предположим, атрибут `oldNumber` сущности `sales$Order` был переименован в `newNumber`, а атрибут `date` был переименован в `deliveryDate`. В этом случае конфигурация трансформации будет выглядеть следующим образом:

[source, xml]
----
include::{sourcesdir}/rest/rest-transform-attr-renamed-config.xml[]
----

Если клиентскому приложению необходимо работать со старой версии сущности `sales$Order`, то приложение должно передать значение версии модели данных в параметре URL `modelVersion`:

`\http://localhost:8080/app/rest/v2/entities/sales$Order/c838be0a-96d0-4ef4-a7c0-dff348347f93?modelVersion=1.0`

Будет возвращен следующий результат:

[source, json]
----
include::{sourcesdir}/rest/rest-transform-attr-renamed-response.json[]
----

Видим, что ответ содержит атрибуты `oldNumber` и `date`, хотя сущность в последней версии приложения уже имеет переименованные атрибуты `newNumber` и `deliveryDate`.
--

Имя сущности изменено::
+
--
Предположим, что в одном из следующих релизов приложения имя сущности `sales$Order` также было изменено. Новое имя сущности теперь `sales$NewOrder`.

Конфиг трансформации для версии `1.1` выглядит так:

[source, xml]
----
include::{sourcesdir}/rest/rest-transform-entity-name-changed-config.xml[]
----

В дополнение к конфигу из предыдущего примера здесь появился атрибут `oldEntityName`. Он описывает имя сущности, действительное для версии модели данных `1.1`. Атрибут `currentEntityName` описывает текущее имя сущности.

Хотя сущность с именем `sales$Order` более не существует, следующий запрос будет работать:

`\http://localhost:8080/app/rest/v2/entities/sales$Order/c838be0a-96d0-4ef4-a7c0-dff348347f93?modelVersion=1.1`

Контроллер REST API поймет, что поиск должен быть осуществлен среди экземпляров сущности `sales$NewOrder`, и после того, как сущность с заданным ID будет найдена, имя сущности и имя атрибута `newNumber` будут заменены в JSON:

[source, json]
----
include::{sourcesdir}/rest/rest-transform-entity-name-changed-response.json[]
----

Клиентское приложение также может использовать старую версию модели данных для создания или изменения сущности.

Этот *POST* запрос использует старое имя сущности и имеет JSON в старом формате в теле запроса, однако, запрос будет работать:

`\http://localhost:8080/app/rest/v2/entities/sales$Order`

[source, json]
----
include::{sourcesdir}/rest/rest-transform-entity-name-changed-response.json[]
----
--

Атрибут должен быть удален из JSON::
+
--
Иногда может возникнуть ситуация, когда в сущность был добавлен новый атрибут, но клиент, работающий со старой версией модели данных, не должен получать этот атрибут при запросе к сущности. В этом случае стандартный JSON трансформер может удалить атрибут из результата.

Конфиг трансформации для данного случае выглядит примерно так:

[source, xml]
----
include::{sourcesdir}/rest/rest-transform-attr-removed-config.xml[]
----

Описание трансформации здесь содержит тег `toVersion` с вложенной командой `removeAttribute`. Это значит, что при выполнении трасформации из текущей версии модели данных к определенной версии (например, при запросе списка сущностей) атрибут `discount` будет удален из JSON.

Если выполнить запрос к REST API без атрибута `modelVersion`, то атрибут `discount` будет возвращен.

`\http://localhost:8080/app/rest/v2/entities/sales$Order/c838be0a-96d0-4ef4-a7c0-dff348347f93`

[source, json]
----
include::{sourcesdir}/rest/rest-transform-attr-removed-response-2.json[]
----

Если указать `modelVersion` в запросе, то атрибут `discount` будет удален:

`\http://localhost:8080/app/rest/v2/entities/sales$Order/c838be0a-96d0-4ef4-a7c0-dff348347f93?modelVersion=1.1`

[source, json]
----
include::{sourcesdir}/rest/rest-transform-attr-removed-response.json[]
----
--

Использование кастомных трансформеров::
+
--
Вы также можете создать и зарегистрировать свой собственный трансформер JSON. В качестве примера рассмотрим следующую ситуацию.

Сущность `sales$OldOrder` была переименована в `sales$NewOrder`. В сущности имеется поле `orderDate` с типом дата. В старой версии сущности это поле содержало часть со временем, в новой версии сущности часть со временем в поле отсутствует. Клиент REST API, запрашивающий сущность со старой версией модели данных `1.0` ожидает, что дата будет иметь часть со временем. Получается, что JSON трансформер должен изменить значение в JSON.

Так будет выглядеть конфигурация трансформации для данного случая:

[source, xml]
----
include::{sourcesdir}/rest/rest-transform-custom-config.xml[]
----

Конфигурация содержит элемент `custom` с вложенными элементами `toVersion` и `fromVersion`. Эти элементы содержат ссылки на бины, т.е. кастомный трансформер должен быть зарегистрирован как Spring bean.

Важная деталь: в кастомном трансформере возможно потребуется использовать бин платформы `RestTransformations` (он предоставляет доступ к транформерам для других сущностей). Но бин `RestTransformations` зарегистрирован в Spring контексте сервлета REST API, а не в главном контексте веб-приложения. Это значит, что бин кастомного трансформера также должен быть зарегистрирован в контексте REST API.

Как это сделать. Во-первых, создайте файл `rest-dispatcher-spring.xml` в модуле *web* или *portal* (например в пакете `com.company.test`).

Затем зарегистрируйте этот файл в файле свойств `app.properties` соответствующего модуля.

[source, properties]
----
cuba.restSpringContextConfig = +com/company/test/rest-dispatcher-spring.xml
----

Файл `rest-dispatcher-spring.xml` должен содержать определения бинов для кастомных трансформеров:

[source, xml]
----
include::{sourcesdir}/rest/rest-transform-dispatcher-spring.xml[]
----

Исходный код бина `sales_OrderJsonTransformerToVersion`:

[source, java]
----
include::{sourcesdir}/features/OrderJsonTransformerToVersion.java[]
----

Данный трансформер находит элемент `orderDate` в JSON и изменяет значение элемента, добавляя к нему часть со временем.

Когда сущность `sales$Order` будет запрошена с версией модели данных `1.0`, то JSON результат будет содержать сущность, поле `orderDate` которой содержит часть со временем, хотя текущий тип поля сущности - дата без времени.

Несколько слов о кастомных трансформерах. Они должны реализовывать интерфейс `EntityJsonTransformer`. Вы также можете унаследоваться от класса `AbstractEntityJsonTransformer` и переопределить его метод `doCustomTransformations`. Класс `AbstractEntityJsonTransformer` содержит функциональность стандартных трансформеров.
--

[[rest_api_v2_ex_search_filter]]
==== Поиск сущностей с фильтром

REST API даёт возможность искать экземпляры сущностей по определенным условиям.

Примеры мы рассмотрим на модели данных, состоящей из двух сущностей:

* **Author** с двумя полями: `lastName` и `firstName`
* **Book** с тремя полями: `title` (String), `author` (Author) и `publicationYear` (Integer)

Чтобы выполнить поиск с фильром URL должен выглядеть следующим образом:

`\http://localhost:8080/app/rest/v2/entities/test$Book/search`

Условия поиска должны быть переданы в параметре `filter`. `filter` - это JSON объект, который содержит набор условий поиска. Если поиск выполняется с помощью GET запроса, то параметр `filter` передается в URL.

Пример 1::

Необходимо найти все книги, опубликованные в 2007 году с именем автора, начинающимся с "Alex". JSON фильтр для подобного условия будет выглядеть так:

[source, json]
----
include::{sourcesdir}/rest/rest-entities-filter-ex1.json[]
----

По умолчанию все критерии поиска применяются с условием И.

Данный пример также демонстрирует возможность использования вложенных свойств объекта (`author.firstName`).

Пример 2::

Следующий пример показывает две вещи: как выполнять поиск с помощью POST запроса и как использовать группы ИЛИ. В случае POST все параметры должны быть переданы в JSON объекте в теле запроса. Условия поиска должны быть помещены в поле объекта с именем `filter`. Остальные параметры (имя view, количество выгружаемых сущностей и т.п.) должы быть помещены в поля объекта с соответствующими именами:

[source, json]
----
include::{sourcesdir}/rest/rest-entities-filter-ex2.json[]
----

В этом примере коллекция `conditions` содержит не только объекты с критериями поиска, но и группу ИЛИ (OR). Итоговое условие можно представить так:

  ((author.lastName contains Stev) OR (author.lastName = Duma) AND (publicationDate in [2007, 2008]))

Обратите внимание, что параметр `view` также передан в теле запроса.

[[app_components_recipes]]
=== Работа с компонентами приложений

Любое CUBA-приложение может быть <<app_components,компонентом>> другого приложения. Компонент приложения представляет собой по сути full-stack библиотеку, предоставляющую функциональность на всех уровнях - от схемы БД до бизнес-логики и UI.

Компоненты, опубликованные в https://www.cuba-platform.com/marketplace[маркетплейсе CUBA] в качестве аддонов, расширяют функциональность фреймворка и могут быть использованы в любом приложении, созданном на платформе.

[[app_components_usage]]
==== Использование публичных аддонов

Аддоны, доступные на маркетплейсе CUBA, можно добавить к приложению одним из способов, описанных ниже. Первый и второй способы подразумевают, что в приложении настроен доступ к одному из <<access_to_repo,стандартных репозиториев CUBA>>. Третий подход применим к аддонам с открытым исходным кодом и не требует подключения к какому-либо удалённому репозиторию.

[[app_components_usage_by_studio]]
Подключение из Studio::
+
--
. Откройте экран *Project properties* и на панели *App components* нажмите на кнопку со знаком плюс рядом с *Custom components*.

. Скопируйте координаты аддона из маркетплейса или документации к аддону и вставьте их в поле координат компонента, например:
+
[source, plain]
----
com.haulmont.addon.cubajm:cuba-jm-global:0.3.1
----

. Нажмите *OK* в диалоговом окне. Studio попытается найти бинарные артефакты аддона в репозитории, используемом в проекте в настоящий момент. Если они найдены, диалоговое окно закроется, и аддон появится в списке собственных компонентов.

. Сохраните изменения в свойствах проекта нажатием *OK*.
--

[[app_components_usage_manual_edit]]
Добавление вручную::
+
--
. Откройте файл `build.gradle` на редактирование и добавьте координаты аддона в секцию `dependencies`:
+
[source, groovy]
----
dependencies {
    appComponent("com.haulmont.cuba:cuba-global:$cubaVersion")
    // your add-ons go here
    appComponent("com.haulmont.addon.cubajm:cuba-jm-global:0.3.1")
}
----

. Выполните команду `gradlew idea` из командной строки, чтобы добавить аддон к окружению проекта.

. Добавьте в файлы `web.xml` модулей `core` и `web` идентификатор аддона (он совпадает с Maven groupId) в параметр контекста `appComponents` к списку компонентов приложения, разделённому пробелами:
+
[source, xml]
----
<context-param>
    <param-name>appComponents</param-name>
    <param-value>com.haulmont.cuba com.haulmont.addon.cubajm</param-value>
</context-param>
----
--

[[app_components_usage_from_sources]]
Сборка из исходников::
+
--
. Склонируйте репозиторий аддона в локальный каталог и откройте проект аддона в Studio.

. Выполните команду *Run > Install app component* в главном меню Studio, чтобы установить аддон в локальный репозиторий Maven (по умолчанию это каталог `~/.m2`).

. Откройте основной проект в Studio и поставьте флажок *Use local Maven repository* на вкладке *Advanced* экрана *Project properties*.

. На панели *App components* нажмите на кнопку со знаком плюс рядом с *Custom components* и выберите установленный аддон в выпадающем списке внизу диалога. Координаты аддона появятся в верхнем поле.

. Нажмите *OK* в диалоге и сохраните изменения.
--

[[app_components_dev]]
==== Создание компонентов приложения

В этом разделе описаны рекомендации по созданию компонентов приложения с целью повторного использования.

[[app_components_dev_naming]]
Правила именования::
+
--
. Имя корневого пакета должно следовать нотации reverse-DNS, например, `com.jupiter.amazingsearch`.
+
Имя корневого пакета не должно начинаться с имени любого другого компонента или приложения. К примеру, если корневой пакет вашего приложения `com.jupiter.tickets`, вы НЕ можете использовать пакет `com.jupiter.tickets.amazingsearch` для компонента. Это обусловлено тем, что Spring сканирует classpath бинов, начиная с указанного корневого пакета, и это сканирование должно быть уникальным для всех компонентов.

. Пространство имён используется в качестве префикса таблиц в базе данных, поэтому для публичных компонентов оно должно быть составным, к примеру, `jptams`, а не просто `search`. Это минимизирует риск совпадения имён между компонентов и конечным приложением. В пространстве имён запрещено использовать нижние подчёркивания и дефисы, только буквы и цифры.

. Значение Module prefix должно повторять пространство имён, но может при этом содержать дефисы, например, `jpt-amsearch`.

. Используйте namespace в качестве префикса имён бинов и свойств приложения, например:
+
[source, java]
----
@Component("jptams_Finder")
@Property("jptams.ignoreCase")
----
--

[[app_components_dev_install_local]]
Установка в локальный Maven-репозиторий::
+
--
Чтобы сделать компонент доступным для испольщования в проектах, расположенных на том же компьютере, установите его в локальный репозиторий Maven, выполнив команду *Run > Install app component* в меню Studio. Данная команда просто запускает задачу Gradle `install` после остановки демонов Gradle.
--

[[app_components_dev_upload]]
Загрузка в удалённый Maven-репозиторий::
+
--
. Создайте репозиторий, следуя инструкции в разделе <<private_repo>>.

. Укажите репозиторий и данные для входа в настройках вашего проекта вместо стандартного репозитория CUBA.

. Откройте файл `build.gradle` проекта компонента на редактирование и добавьте секцию `uploadRepository` в секцию `cuba`:
+
[source,groovy]
----
include::{sourcesdir}/cookbook/app_comp_upload_1.groovy[]
----

. Откройте проект компонента в Studio.

. В диалоге *Search* (Alt-/) найдите задачу Gradle `uploadArchives` и выполните её. Вы также можете выполнить эту задачу из командной строки. Артефакты компонента будут загружены в ваш репозиторий.

. Удалите артефакты проекта из локального Maven-репозитория, чтобы убедиться, что они будут загружены из удалённого репозитория при следующей сборке проекта приложения. Для этого просто удалите папку `.m2/repository/com/company` из домашнего каталога пользователя.

. Теперь при сборке и запуске приложения, использующего этот компонент, он будет скачиваться из удалённого репозитория.
--

[[app_components_dev_upload_bintray]]
Загрузка в Bintray::
+
--
. Зарегистрируйтесь на https://bintray.com/signup/oss
+
[TIP]
====
Для входа на Bintray можно использовать social login (через GitHub, Gmail или Twitter), однако позже вам потребуется выполнить сброс пароля, так как для получения API-ключа (см.ниже) понадобится пароль от учетной записи.
====

. Запомните своё имя пользователя Bintray. Его можно взять из URL, который открывается после логина на Bintray. К примеру, в `\https://bintray.com/vividphoenix` именем пользователя будет `vividphoenix`.

. Получите свой API key. Его можно найти через интерфейс Bintray в настройках профиля. В разделе API-key вам потребуется ввести пароль от учетной записи, чтобы ключ высветился. Используйте ключ и имя пользователя для авторизации с помощью плагина:
+
** Вы можете создать для авторизации переменные окружения:
+
[source, plain]
----
BINTRAY_USER=your_bintray_user
BINTRAY_API_KEY=9696c1cb90752357ded8fdf20eb3fa921bf9dbbb
----
+
** Вместо переменных окружения можно использовать эти параметры в явном виде в файле `build.gradle`:
+
[source, plain]
----
bintray {
user = 'bintray_user'
key = 'bintray_api_key'
...
}
----
+
** Как вариант, можно передать параметры доступа Bintray в командной строке:
+
[source, plain]
----
./gradlew clean assemble bintrayUpload -Pcuba.artifact.version=1.0.0 -PbintrayUser=your_bintray_user -PbintrayApiKey=9696c1cb90752357ded8fdf20eb3fa921bf9dbbb
----

. Создайте публичный репозиторий с типом _Maven_. При создании open source (OSS) репозитория обязательно нужно указать тип лицензии.
+
Структура Bintray предполагает использование пакетов (packages) внутри репозиториев. На данном этапе создавать пакет необязательно, так как он будет создан автоматически в ходе задания `gradle bintrayUpload`.

. Добавьте зависимость для плагина загрузки Bintray в файл `build.gradle`:
+
[source, groovy]
----
include::{sourcesdir}/cookbook/bintray_plugin.groovy[]
----

. В конце скрипта `build.gradle` укажите настройки для плагина Bintray:
+
[source, groovy]
----
include::{sourcesdir}/cookbook/bintray_plugin_settings.groovy[]
----
+
** здесь, `pkg:repo` - ваш репозиторий (используйте `main`),
** `pkg:name` - имя пакета (используйте ваше уникальное имя, например, `amazingsearch`),
** `pkg:desc` - необязательное описание пакета, которое будет отображаться в интерфейсе Bintray,
** `pkg:userOrg` - имя организации, к которой должен относиться репозиторий (если не задано, по умолчанию будет использоваться значение `BINTRAY_USER`).

. Теперь вы можете собрать и загрузить проект, используя следующую команду:
+
[source, plain]
----
./gradlew clean assemble bintrayUpload -Pcuba.artifact.version=1.0.0
----

. Если вы публикуете аддон в маркетплейс CUBA, его репозиторий будет привязан к стандартным репозиториям CUBA, и пользователям не придётся дополнительно настраивать репозитории в своих проектах.
--

[[app_components_sample]]
==== Пример создания и использования компонента

В данном разделе рассматривается пример создания компонента приложения и использования его в проекте. Компонент будет предоставлять функциональность "Customer Management" и содержать сущность `Customer` и соответствующие экраны UI. Приложение будет использовать сущность `Customer` из компонента в качестве ссылки в собственной сущности `Order`.

image::app_components_sample.png[align="center"]

Создание компонента Customer Management::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `customers`

* *Project namespace* - `cust`

* *Root package* - `com.company.customers`

. Откройте *Project properties* на редактирование и на вкладке *Advanced* установите значение поля *Module prefix* в `cust`.

. Создайте сущность `Customer` с атрибутом `name`. Переключитесь на вкладку *Instance name* и укажите `name` в атрибутах name pattern.
+
[WARNING]
====
Если компонент содержит персистентные классы, аннотированные `@MappedSuperclass`, убедитесь, что в этом же проекте есть их наследники, являющиеся сущностями (т.е. аннотированные `@Entity`). В противном случае байткод таких базовых классов не будет необходимым образом модифицирован и они не будут правильно работать в приложениях, использующих компонент.
====

. Сгенерируйте скрипты БД и создайте стандартные экраны для сущности `Customer`: `cust$Customer.browse` и `cust$Customer.edit`. После этого откройте дизайнер меню и переименуйте пункт `application` в `customerManagement`.

. Нажмите на ссылку *App component descriptor* на панели *Project properties*. Сохраните сгенерированный <<app-component.xml,описатель компонента>> нажав *OK*.

. Проверьте функциональность Customer Management: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Установите компонент приложения в локальный Maven-репозиторий, выполнив команду главного меню *Run > Install app component*.

Создание приложения Sales::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `sales`

* *Project namespace* - `sales`

* *Root package* - `com.company.sales`

. Откройте *Project properties* на редактирование и на панели *App components* нажмите на кнопку добавления *Custom components*. В диалоге *Custom application component* выберите проект `customers` в списке *Registered project*. Данный список содержит все проекты, зарегистрированные в Studio и имеющие описатель `app-component.xml`. Нажмите в диалоге *OK*. В списке кастомных компонентов проекта появятся Maven-координаты компонента Customer Management. Сохраните страницу свойств проекта нажатием *OK*.

. Создайте сущность `Order` с атрибутами `date` и `amount`. Добавьте атрибут `customer` в виде many-to-one ассоциации с сущностью `Customer` - она должна быть доступна в выпадающем списке *Type*.

. Сгенерируйте скрипты БД и создайте стандартные экраны для сущности `Order`. При создании экранов создайте представление `order-with-customer-view`, включающее атрибут `customer` и используйте его в экранах.

. Проверьте функциональность приложения: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/app++` в веб-браузере. Приложение должно содержать два пункта меню верхнего уровня: *Customer Management* и *Application*.

Модификация компонента Customer Management::

Предположим, что необходимо изменить функциональность компонента (добавить атрибут в сущность `Customer`) и пересобрать приложение для внесения этих изменений.

. Откройте проект `customers` в Studio.

. Откройте сущность `Customer` на редактирование и добавьте атрибут `address`. При сохранении изменений выберите экраны браузера и редактора для включения нового атрибута.

. Сгенерируйте скрипты БД - будет создано новый скрипт обновления с изменением таблицы. Сохраните скрипты.

. Проверьте изменения в компоненте: *Run > Update database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Переинсталлируйте компонент в локальный Maven-репозиторий выполнив команду меню *Run > Install app component*.

. Закройте проект `sales` в Studio (если он открыт) и откройте его снова. Это необходимо для того, чтобы Studio загрузила новые исходники компонента.

. Выполните команды меню *Build > Clean*, затем *Build > Assemble project*.

. Запустите *Run > Update database* - будет выполнен скрипт обновления из компонента Customer Management.

. Выполните *Run > Start application server* и откройте `++http://localhost:8080/app++` в веб-браузере - приложение теперь содержит сущность `Customer` и соответствующие экраны с атрибутом `address`.

[[servlet_registration_sample]]
==== Регистрация DispatcherServlet из компонента приложения

В этом разделе мы рассмотрим, как настроить динамическую регистрацию сервлетов и фильтров, настроенных в <<app_components,компоненте приложения>>, в родительском приложении. Чтобы избежать дублирования кода в файле конфигурации <<web.xml,web.xml>>, необходимо зарегистрировать сервлеты и фильтры с помощью специального бина `ServletRegistrationManager`.

Простой пример такой регистрации рассмотрен на примере <<servlet_registration,HTTP-сервлета>>. Здесь мы рассмотрим более сложный случай: частную реализацию сервлета `DispatcherServlet` в компоненте приложения. Этот сервлет будет загружать параметры своей конфигурации  из файла `demo-dispatcher-spring.xml`, поэтому, чтобы попробовать этот пример на практике, вы должны создать пустой файл с этим именем в корневом каталоге ресурсов проекта (например, `web/src`).

[source,java]
----
include::{sourcesdir}/cookbook/servlet_sample.java[]
----

Чтобы зарегистрировать `DispatcherServlet`, вам нужно вручную загрузить класс, создать его экземпляр и проинициализировать его, в противном случае использование разных типов `ClassLoader` может вызвать проблемы при <<deployment_variants,развёртывании>> в SingleWAR/SingleUberJAR. Кроме того, собственная реализация `DispatcherServlet` должна выдерживать двойную инициализацию - сначала вручную, а затем с помощью servlet container.

Пример компонента для инициализации `WebDispatcherServlet`:

[source,java]
----
include::{sourcesdir}/cookbook/servlet_sample_2.java[]
----

Метод `createServlet()` инжектированного бина `ServletRegistrationManager` принимает <<appContext,контекст приложения>>, полученный из события `ServletContextInitializedEvent`, и полное имя класса `WebDispatcherServlet`. Для инициализации сервлета мы передаём экземпляр `ServletContext`, также полученный из события `ServletContextInitializedEvent`, и имя сервлета. В методе `addMapping()` задаём HTTP-мэппинг для отображения на URL: `/webd/`.

[[misc_recipes]]
=== Разное

В данном разделе собраны рецепты, которые сложно отнести к одной из категорий выше.

[[getting_messages]]
==== Получение локализованных сообщений

В данном разделе рассмотрены способы получения <<localization,локализованных сообщений>> в различных компонентах приложения.

* В <<screen_xml,XML-дескрипторах>> экранов атрибуты компонентов, отображающие статичный текст (например <<gui_attr_caption,caption>>), могут обращаться к локализованным сообщениям по правилам метода <<messageTools.loadString,MessageTools.loadString()>>. Например:

** `caption="msg://roleName"` - получить сообщение, заданное ключом `roleName` в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте `messagesPack` корневого элемента `window`.

** `caption="msg://com.company.sample.entity/Role.name"` - получить сообщение, заданное ключом `Role.name` в пакете сообщений `com.company.sample.entity`.

* В <<screen_controller,контроллерах экранов>> локализованные сообщения можно получать следующими способами:

** Из пакета сообщений текущего экрана:

*** Методом `getMessage()`, унаследованным от базового класса <<abstractFrame,AbstractFrame>>. Например:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Методом `formatMessage()`, унаследованным от базового класса `AbstractFrame`. В этом случае сообщение используется для форматирования переданных параметров по правилам метода `String.format()`. Например:
+
messages.properties:
+
[source, plain]
----
warningMessage = Invalid email address: '%s'
----
+
Java-контроллер:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** Из произвольного пакета сообщений путем инжекции интерфейса инфраструктуры <<messages,Messages>>. Например:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
}
----

* В компонентах, управляемых контейнером Spring (<<managed_beans,управляемых бинах>>, <<services,сервисах>>, <<jmx_beans,JMX-бинах>>, контроллерах Spring MVC модуля *portal*) локализованные сообщения можно получать путем инжекции интерфейса инфраструктуры <<messages,Messages>>:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----
+
Локализованные сообщения для шаблонов https://www.thymeleaf.org/[Thymeleaf] в модуле *portal* также доступны по ключу:
+
.template
[source, xml]
----
<h1 th:text="#{messageKey}"></h1>
----
+
.portal main message pack
[source, plain]
----
messageKey = Localized message
----

* В любом коде приложения, где невозможна инжекция, интерфейс `Messages` может быть получен с помощью статического метода `get()` класса `AppBeans`:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[images_recipe]]
==== Загрузка и вывод изображений

Рассмотрим задачу загрузки, хранения и отображения фотографий сотрудников:

* Сотрудник представлен сущностью `Employee`.

* Файлы изображений хранятся в <<file_storage,FileStorage>>. Сущность `Employee` содержит ссылку на соответствующий `FileDescriptor`.

* Экран редактирования `Employee` отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.

Класс сущности со ссылкой на файл изображения:

[source, java]
----
include::{sourcesdir}/cookbook/images_1.java[]
----

<<views,Представление>> для загрузки `Employee` вместе с `FileDescriptor` должно содержать все локальные атрибуты `FileDescriptor`:

[source, xml]
----
include::{sourcesdir}/cookbook/images_2.xml[]
----

Фрагмент XML-дескриптора экрана редактирования `Employee`:

[source, xml]
----
include::{sourcesdir}/cookbook/images_3.xml[]
----

Компоненты отображения и загрузки/выгрузки фотографии заключены внутрь контейнера <<gui_GroupBoxLayout,groupBox>>. В верхней его части с помощью компонента <<gui_Image,image>> выводится изображение, а в нижней слева направо расположены компонент <<gui_FileUploadField,upload>> для загрузки файла и <<gui_Button,кнопки>> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:

image::images_recipe.png[align="center"]

Теперь рассмотрим <<abstractEditor,контроллер экрана редактирования>>.

[source, java]
----
include::{sourcesdir}/cookbook/images.java[]
----

* В методе `init()` сначала инициализируется компонент `uploadField`, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового `FileDescriptor`, и соответствующий файл отправляется из временного хранилища в постоянное вызовом `FileUploadingAPI.putFileIntoStorage()`. После этого `FileDescriptor` сохраняется в БД вызовом <<dataSupplier,DataSupplier.commit()>>, и сохраненный экземпляр устанавливается в атрибуте `imageFile` редактируемой сущности `Employee`. Затем вызывается метод `displayImage()` контроллера для отображения загруженной фотографии.
+
Далее в методе `init()` источнику данных, содержащему редактируемый экземпляр `Employee`, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.

* Метод `postInit()` вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.

* Метод `onDownloadImageBtnClick()` вызывается при нажатии кнопки `downloadImageBtn` и выполняет выгрузку файла с помощью интерфейса <<file_download,ExportDisplay>>.

* Метод `onClearImageBtnClick()` вызывается при нажатии кнопки `clearImageBtn` и очищает атрибут `imageFile` сущности `Employee`. Удаления файла из хранилища не производится.

* Метод `displayImage()` выгружает файл из хранилища и устанавливает его в качестве содержимого компонента `image`.

[[images_in_table]]
===== Вывод изображений в колонках таблицы

Расширим задачу из предыдущего примера, настроив отображение фотографий на экране просмотра списка сотрудников.

Изображения можно отобразить как в отдельной колонке, так и внутри существующих колонок. В обоих случаях будет использоваться интерфейс <<gui_Table_addGeneratedColumn,Table.ColumnGenerator>>.

Фрагмент XML-дескриптора экрана просмотра списка `Employee`:

[source, xml]
----
include::{sourcesdir}/cookbook/images_4.xml[]
----

Чтобы отображать фотографию рядом с именем сотрудника в колонке `name`, необходимо изменить стандартное представление данных в этой колонке. Например, можно использовать контейнер <<gui_BoxLayout,HBoxLayout>>, поместив внутрь него компонент <<gui_Image,Image>>:

[source, java]
----
include::{sourcesdir}/cookbook/images_5.java[]
----

* В методе `init()` вызывается метод `addGeneratedColumn()`, который принимает два параметра: идентификатор колонки и реализацию интерфейса `Table.ColumnGenerator`, с помощью которого мы зададим своё представление для колонки `name`.

* В этом методе мы создадим компонент `Image`, пользуясь интерфейсом `ComponentsFactory`. Укажем <<gui_Image_scaleMode,режим масштабирования>> компонента (`CONTAIN`) и зададим его размеры.

* Затем получим экземпляр `FileDescriptor` с изображением, которое хранится в <<file_storage,File Storage>>. Ссылка на это изображение хранится в атрибуте `imageFile` сущности `Employee`. Используем тип ресурса `FileDescriptorImageResource`, чтобы задать источник данных для компонента `Image`.

* Атрибут `name` можно отобразить как компонент `Label` рядом с изображением.

* Оба компонента `Image` и `Label` обернём в контейнер `HBoxLayout`, который будет возвращать метод `addGeneratedColumn()` в качестве новой разметки ячейки.

image::image_recipe.png[align="center"]

Можно использовать также более декларативный подход с атрибутом <<gui_Table_column_generator,generator>>.


[[sending_emails_recipe]]
==== Отправка email

В данном разделе рассматривается пример использования <<email_sending,механизма>> рассылки email.

Рассмотрим следующую задачу:

--
* Имеется сущность `NewsItem` и экран ее редактирования `NewsItemEdit`.

* Сущность `NewsItem` имеет следующие атрибуты: `date`, `caption`, `content`.

* Необходимо отсылать электронные письма каждый раз, когда через экран `NewsItemEdit` создается новый экземпляр сущности. Email должен содержать `NewsItem.caption` в качестве темы письма, тело письма должно формироваться на основе шаблона, включающего `NewsItem.content`.
--

. Добавьте следующий код в `NewsItemEdit.java`:
+
--
[source, java]
----
include::{sourcesdir}/cookbook/sending_emails_1.java[]
----

Как видно, метод `sendByEmail()` вызывает сервис `EmailService` и передает ему экземпляр `EmailInfo`, описывающий сообщение. Тело сообщений будет создаваться на основе шаблона `news_item.txt`.
--

. Создайте шаблон тела письма в файле `news_item.txt` в пакете `com.company.demo.templates` модуля *core*:
+
--
[source, plain]
----
include::{sourcesdir}/cookbook/sending_emails_2.txt[]
----

Это шаблон link:http://freemarker.incubator.apache.org[Freemarker], который использует параметры, переданные в `EmailInfo` (в данном случае единственный параметр `newsItem`).
--

. Запустите приложение, откройте браузер сущности `NewsItem` и нажмите *Create*. Откроется экран редактирования сущности. Заполните поля и нажмите *OK*. Появится диалог подтверждения с вопросом об отсылке email. Нажмите *Yes*.

. Перейдите в экран *Administration > Email History* вашего приложения. Вы увидите две записи (по числу получателей) со статусом `Queue`. Он означает, что сообщения находятся в очереди и еще не отосланы.

. Для обработки очереди необходимо создать <<scheduled_tasks_cuba,назначенное задание>>. Перейдите в экран *Administration > Scheduled Tasks* вашего приложения. Создайте новую задачу и установите ей следующие параметры:
+
--
* *Bean Name* - `cuba_Emailer`
* *Method Name* - `processQueuedEmails()`
* *Singleton* - да (этот параметр важен только при эксплуатации кластера серверов middleware)
* *Period, sec* - 10
--
+
Сохраните задачу и нажмите на ней *Activate*.
+
Если вы ранее не настраивали выполнение назначенных заданий для данного приложения ранее, то на данном этапе ничего не произойдет - новая задача не начнет выполняться, пока вы не запустите весь механизм назначенных заданий.

. Откройте файл `modules/core/src/app.properties` и добавьте в него следующее <<cuba.schedulingActive,свойство>>:
+
[source, properties]
----
cuba.schedulingActive = true
----
+
Перезапустите сервер приложения. Механизм выполнения заданий теперь активен и вызывает обработку очереди email.

. Перейдите в экран *Administration > Email History*. Статус сообщений будет либо `Sent`, если они успешно отосланы, либо, что более вероятно, `Sending` или `Queue`, если произошла ошибка отправки. В последнем случае вы можете открыть журнал приложения в файле `build/tomcat/logs/app.log` и выяснить причину. Механизм отсылки email предпримет несколько (по умолчанию 10) попыток и в случае неудачи переведет сообщения в статус `Not sent`.

. Наиболее очевидной причиной ошибки отправки является то, что вы не настроили <<email_sending_properties,параметры>> SMTP-сервера. Эти параметры могут быть заданы в базе данных с помощью  JMX бина `app-core.cuba:type=Emailer` или в свойствах приложения блока middleware. Рассмотрим второй способ. Откройте файл `modules/core/src/app.properties` и добавьте в него требуемые <<email_sending_properties,параметры>>:
+
[source, properties]
----
include::{sourcesdir}/cookbook/sending_emails_3.properties[]
----
+
Перезапустите сервер приложения. Перейдите в экран *Administration > JMX Console*, найдите JMX бин `Emailer` и попробуйте послать самому себе тестовое сообщение с помощью операции `sendTestEmail()`.

. Теперь механизм отсылки email настроен корректно, однако он не будет отсылать сообщения, уже переведенные в статус `Not sent`. Поэтому необходимо создать новый экземпляр `NewsItem` через экран редактирования. Сделайте это и понаблюдайте, как статус новых сообщений в экране *Email History* изменится на `Sent`.

[[own_component_samples]]
==== Создание собственных визуальных компонентов

В разделе <<own_components>> был приведен обзор методов расширения набора стандартных визуальных компонентов в проекте. У вас есть следующие варианты:

. Подключение аддона Vaadin. Много сторонних компонентов Vaadin распространяются в виде дополнений (add-on). Библиотека аддонов находится по адресу https://vaadin.com/directory.

. Подключение компонента, написанного на JavaScript. Vaadin дает возможность создавать серверные компоненты, использующие JavaScript-библиотеку.

. Создание собственного компонента Vaadin с клиентской частью, написанной на GWT.

Далее вы можете интегрировать получившийся компонент Vaadin в универсальный пользовательский интерфейс CUBA, чтобы иметь возможность использовать его декларативно в XML-дескрипторах экранов и привязывать к источникам данных.

Финальным шагом интеграции является поддержка нового компонента в WYSIWYG редакторе экранов Studio.

Далее в этом разделе приводятся примеры создания новых визуальных компонентов каждым из описанных выше способов. Интеграция в Generic UI одинакова для всех трех способов, поэтому она описана только для примера с подключением аддона Vaadin.

[[vaadin_addon_sample]]
===== Подключение аддона Vaadin

Рассмотрим пример использования компонента *Stepper*, доступного по адресу http://vaadin.com/addon/stepper. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.

Создайте новый проект в CUBA Studio и назовите его `addon-demo`.

Для подключения аддона Vaadin проект должен иметь модуль *web-toolkit*. Создайте его, нажав на ссылку *Create web toolkit module* секции *Project properties* навигатора.

Далее нажмите на ссылку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_no_gui.png[align="center"]

Заполните следующие поля:

* *Add-on Maven dependency* - в этом поле необходимо указать Maven-координаты аддона Vaadin для подключения его как зависимости к текущему проекту. Указание координат возможно в двух форматах:

. XML, скопированный с сайта аддона (http://vaadin.com/addon/stepper):
+
[source, xml]
----
<dependency>
   <groupId>org.vaadin.addons</groupId>
   <artifactId>stepper</artifactId>
   <version>2.2.2</version>
</dependency>
----

. Одной строкой в том виде, как вы добавляете зависимости в <<build.gradle,build.gradle>>: `org.vaadin.addons:stepper:2.2.2`

* *Inherited widgetset* - в этом поле необходимо указать имя виджетсета подключаемого аддона:
+
[source]
----
org.vaadin.risto.stepper.widgetset.StepperWidgetset
----

* *Integrate into generic UI* - в данном примере флажок должен быть снят, т.к. мы не интегрируем компонент в универсальный интерфейс платформы.

Нажмите кнопку *OK*.

Если открыть проект в IDE, то можно увидеть, что Студия изменила два файла:

. <<build.gradle, build.gradle>>. В модуле *web* появилась новая зависимость от аддона, содержащего компонент:
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.2.2")
    }
----

. В файл `AppWidgetSet.gwt.xml` модуля *web-toolkit* проекта подключен виджетсет аддона после виджетсета платформы:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />

    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
</module>
----
+
[TIP]
====
Для более быстрой сборки виджетов на время разработки вы можете установить свойство `user.agent`. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.
====

Компонент из аддона Vaadin подключен. Далее мы покажем как использовать его в экранах проекта.

* Создаем новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны. В диалоге генерации стандартных экранов убедитесь что значение поля *In module* - `Web Module`. Экраны, использующие компоненты Vaadin напрямую, должны располагаться в модуле *web*.
+
[TIP]
====
На самом деле экран может располагаться и в модуле *gui*, но тогда код, работающий с Vaadin компонентом, должен быть вынесен в отдельный <<companions,компаньон>>.
====

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и вне ее. Рассмотрим оба способа.
+
--
. В XML-дескрипторе экрана редактирования `customer-edit.xml` для поля `score` компонента `fieldGroup` добавим атрибут `custom = "true"`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-custom-field.xml[]
----
+
В контроллер экрана редактирования `CustomerEdit.java` добавим следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiCustomField.java[]
----
+
Здесь в поле `stepper` создается экземпляр компонента, подключенного из аддона. В методе `init()` производится инициализация кастомного поля `score`. Через `ComponentsFactory` создается экземпляр <<gui_BoxLayout>>, затем из него с помощью <<webComponentsHelper,WebComponentsHelper>> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. `BoxLayout` возвращается для отображения в кастомном поле.
+
Для связи компонента с данными, во-первых, в методе `postInit()` ему устанавливается текущее значение из редактируемого `Customer`, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем.

. Чтобы использовать новый компонент вне `FieldGroup` в произвольном месте экрана в XML-дескрипторе объявим контейнер `scoreBox` и удалим поле `score` из `fieldGroup`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-container.xml[]
----
+
В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiContainer.java[]
----
+
Связь с данными выполняется здесь аналогично примеру с `FieldGroup`.
--

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/com.company.application/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[vaadin_addon_sample_gui]]
===== Подключение аддона Vaadin с интеграцией в Generic UI

В <<vaadin_addon_sample,предыдущем разделе>> мы подключили в проект сторонний компонент Stepper. В данном разделе мы интегрируем его в универсальный пользовательский интерфейс CUBA, что даст разработчикам возможность использовать компонент декларативно в XML-дескрипторах экранов и связывать его с сущностями через <<datasources,источники данных>>.

Создадим новый проект в CUBA Studio и назовем его `addon-gui-demo`.

Создадим модуль *web-toolkit*, нажав на кнопку *Create web toolkit module* секции *Project properties* навигатора Studio.

Далее нажимаем на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выбираем значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_gui.png[align="center"]

Заполним поля *Add-on Maven dependency* и *Inherited widgetset* как описано в <<vaadin_addon_sample,предыдущем разделе>>.

Далее заполним поля в нижней секции:

* *Integrate into Generic UI* указывает на необходимости интеграции компонента в универсальный пользовательский интерфейс платформы.

* *Component XML element* -  имя элемента компонента в XML-дескрипторе экрана. Введите значение `stepper`.

* *Component interface name* - имя интерфейса компонента для универсального UI платформы. Введите `Stepper`.

* *FQN of Vaadin component from add-on* - полное имя класса компонента Vaadin из аддона. В нашем случае это `org.vaadin.risto.stepper.IntStepper`.

После нажатия кнопки *OK* Studio сделает следующее:

* Добавит аддон Vaadin в зависимости модуля *web* в файле `build.gradle`.

* Подключит виджетсет аддона в файле `AppWidgetSet.gwt.xml` модуля *web-toolkit*.

* Сгенерирует заготовки для следующих файлов:

** `Stepper` - интерфейс компонента в подкаталоге *gui* модуля *web*.

** `WebStepper` - реализация компонента в подкаталоге *gui* модуля *web*.

** `StepperLoader` - XML-загрузчик компонента в модуле *web*.

** `ui-component.xsd` - описатель схемы XML для нового компонента. Если файл уже существовал на момент генерации компонента, то информация о новом компоненте будет добавлена в существующий файл.

** `cuba-ui-component.xml` - файл регистрации загрузчика нового компонента в модуле *web*. Если файл существовал, то информация о новом компоненте будет добавлена в существующий файл.

Откройте проект в IDE.

Последовательно пройдемся по сгенерированным Studio заготовкам файлов и внесем в них необходимые изменения.

* Перейдите к интерфейсу `Stepper` в подкаталоге *gui* модуля *web*. Замените его содержимое на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/Stepper.java[]
----
+
В качестве базового для нашего компонента выбран интерфейс `Field`. Это позволяет осуществить связь с данными (data binding), то есть отображать и редактировать значение некоторого атрибута сущности.

* Далее перейдите к классу `WebStepper` - реализации компонента в подкаталоге *gui* модуля *web*. Замените содержимое класса следующим кодом:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/WebStepper.java[]
----
+
В качестве базового класса выбран `WebAbstractField`, который реализует логику интерфейса `Field`.

* `StepperLoader` в модуле *web* загружает компонент из его представления в XML.
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/StepperLoader.java[]
----
+
Логика загрузки базовых свойств компонента `Field` сосредоточена в классе `AbstractFieldLoader`. Нам достаточно загрузить только специфические свойства `Stepper`.

* В файле `cuba-ui-component.xml`, расположенном в корне модуля *web*, регистрируется новый компонент и его загрузчик. Оставляем файл без изменений.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/cuba-ui-component.xml[]
----

* Файл `ui-component.xsd`, расположенный в корне модуля *web*, это описатель XML схемы новых компонентов проекта. Добавим к элементу `stepper` описание его атрибутов.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/ui-component.xsd[]
----

Далее рассмотрим, как добавить новый компонент на экран.

* Создадим новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны.

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и в отдельный контейнер. Рассмотрим оба способа.

. Использование компонента в экране внутри произвольного контейнера.
+
--
* Откройте файл `customer-edit.xml`.

* Объявите новое пространство имен `xmlns:app="http://schemas.company.com/agd/0.1/ui-component.xsd"`

* Удалите поле `score` из `fieldGroup`.

* Добавьте компонент `stepper` на экран.

В результате XML-дескриптор редактора должен выглядеть так:

[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-container.xml[]
----

В данном примере компонент `stepper` подсоединен к атрибуту `score` сущности `Customer`, экземпляр которой находится в источнике данных `customerDs`.
--

. Использование компонента в поле <<gui_FieldGroup>>:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-custom-field.xml[]
----
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/CustomerEditGuiCustomField.java[]
----

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/com.company.application/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[js_library_sample]]
===== Подключение JavaScript библиотеки

В данном примере мы подключим компонент https://jqueryui.com/slider/#range[Slider] из библиотеки *jQuery UI*. Слайдер будет иметь два ползунка, определяющих диапазон значений.

Создайте новый проект в CUBA Studio и назовите его `jscomponent`.

Далее нажмите на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `JavaScript component`.

image::ui_component/studio_js_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `SliderServerComponent`.

Уберите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `SliderServerComponent` - интегрированный с JavaScript компонент Vaadin.

* `SliderState` - класс состояния компонента Vaadin.

* `slider-connector.js` - JavaScript коннектор для компонента Vaadin

Последовательно пройдемся по сгенерированным заготовкам файлов и внесем в них необходимые изменения.

* Класс состояния `SliderState` определяет, какие данные будут пересылаться между сервером и клиентом. В нашем случае мы будем пересылать информацию о минимальном и максимальном возможном значении и выбранных значениях слайдера.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderState.java[]
----

* Серверный компонент Vaadin `SliderServerComponent`.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderServerComponent.java[]
----
+
Серверный компонент Vaadin определяет набор геттеров и сеттеров для работы с состоянием слайдера, а также интерфейс слушателя изменения значений. Класс компонента должен быть унаследован от `AbstractJavaScriptComponent`.
+
Метод `addFunction()` в конструкторе класса объявляет обработчик RPC-вызова функции `valueChanged()` с клиента.
+
Аннотации `@JavaScript` и `@StyleSheet` указывают на файлы, которые должны быть загружены на веб-страницу. В нашем примере это JavaScript файлы библиотеки jQuery UI и коннектора, а также файл со стилями для jQuery UI. Расположим их в одном Java-пакете с серверным компонентом.

Скачайте архив jQuery UI с сайта http://jqueryui.com/download и поместите файлы `jquery-ui.js` и `jquery-ui.css` в пакет с классом `SliderServerComponent`. На странице скачивания jQuery UI у вас будет возможность выбрать компоненты, которые будут помещены в архив. Для нашего примера достаточно выделить пункт `Slider` группы `Widgets`.

image::ui_component/js_project_structure.png[align="center"]

* JavaScript коннектор `slider-connector.js`.
+
[source, javascript]
----
include::{sourcesdir}/ui_component/js/slider-connector.js[]
----
+
Коннектор представляет собой функцию, которая при загрузке веб-страницы проинициализирует JavaScript компонент. Имя функции должно соответствовать полному имени класса серверного компонента, где точки в имени пакета заменены на символ подчеркивания.
+
Vaadin добавляет ряд полезных методов в функцию коннектора. Например, `this.getElement()` возвращает HTML DOM элемент компонента, `this.getState()` возвращает объект-состояние.
+
В нашем примере коннектор делает следующее:
+
--
* Инициализирует компонент `slider` из библиотеки jQuery UI. При изменении положения одного из ползунков будет вызвана функция `slide()`. Мы видим, что она в свою очередь вызывает метод `valueChanged()` коннектора. `valueChanged()` - это метод, который мы объявили на стороне сервера в классе `SliderServerComponent`.

* Объявляет функцию `onStateChange()`. Она будет вызываться при изменении объекта-состояния на стороне сервера.
--

Для демонстрации работы компонента создадим сущность `Product` с тремя атрибутами:

* `name` типа String
* `minDiscount` типа Double
* `maxDiscount` типа Double

Затем сгенерируем стандартные экраны для данной сущности. Обратите внимание, что мы используем не универсальный компонент платформы, а "нативный" компонент Vaadin. Следовательно, экраны должны располагаться в модуле Web, а не в GUI - укажите это в окне генерации стандартных экранов.

В редакторе сущности мы хотим устанавливать минимальное и максимальное значение скидки с помощью компонента `slider`, который мы только что создали.

Перейдите к файлу `product-edit.xml`. Поля `minDiscount` и `maxDiscount` сделайте нередактируемыми, добавив к соответствующим элементам атрибут `editable="false"`. Затем добавьте в `fieldGroup` новое кастомное поле `slider`.

В результате XML-дескриптор экрана редактирования должен выглядеть следующим образом:

[source, xml]
----
include::{sourcesdir}/ui_component/js/product-edit.xml[]
----

Перейдите к файлу `ProductEdit.java`. Замените его содержимое следующим кодом:

[source, java]
----
include::{sourcesdir}/ui_component/js/ProductEdit.java[]
----

В методе `initNewItem()` мы проставляем начальные значения скидок для нового продукта.

В методе `init()` инициализируем кастомное поле для слайдера. Для компонента слайдера мы проставляем текущие значения, максимальное и минимальное значения, а также объявляем слушатель изменений значений. При движении ползунка мы будем проставлять новые значения скидок в соответствующие поля редактируемой сущности.

Запустите проект и откройте экран редактирования продукта. Изменение положения ползунка на слайдере должно изменять значение в соответствующем текстовом поле.

image::ui_component/product_edit.png[align="center"]

[[gwt_component_sample]]
===== Создание GWT компонента

В данном примере мы рассмотрим создание простого GWT-компонента - поля рейтинга в виде 5 звезд, а также использование его в экранах приложения.

image::ui_component/rating_field_component.png[align="center"]

Создадим новый проект в CUBA Studio. Имя проекта - `ratingsample`.

Создайте модуль *web-toolkit*, нажав на кнопку *Create web-toolkit module* секции *Project properties* навигатора Studio.

Далее нажмите на ссылку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `New GWT component`.

image::ui_component/studio_gwt_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `RatingFieldServerComponent`.

Снимите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `RatingFieldWidget.java` - виджет GWT в модуле *web-toolkit*.

* `RatingFieldServerComponent.java` - класс компонента Vaadin.

* `RatingFieldState.java` - класс состояния компонента.

* `RatingFieldConnector.java` - коннектор, связывающий клиентский код с серверным компонентом.

* `RatingFieldServerRpc.java` - класс, определяющий API сервера для клиентской части.

Последовательно рассмотрим сгенерированные студией заготовки файлов и внесем в них необходимые изменения.

* GWT виджет `RatingFieldWidget.java`. Замените содержимое файла на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldWidget.java[]
----
+
Виджет представляет собой клиентский класс, отвечающий за отображение компонента в веб-браузере и реакцию на события. Он определяет интерфейсы для работы с серверной частью. В нашем случае это метод `setValue()` и интерфейс `StarClickListener`.

* Класс компонента Vaadin `RatingFieldServerComponent`. Он определяет API для серверного кода, различные get/set методы, слушатели событий и подключение источников данных. Прикладные разработчики используют в своём коде методы этого класса.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerComponent.java[]
----

* Класс состояния `RatingFieldState` отвечает за то, какие данные будут пересылаться между клиентом и сервером. В нём определяются публичные поля, которые будут автоматически сериализованы на сервере и десериализованы на клиенте.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldState.java[]
----

* Интерфейс `RatingFieldServerRpc` — определяет API сервера для клиентской части, его методы могут вызываться с клиента при помощи механизма удалённого вызова процедур, встроенного в Vaadin. Этот интерфейс мы реализуем в самом компоненте, в данном случае просто вызываем метод `setValue()` нашего поля.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerRpc.java[]
----

* Коннектор `RatingFieldConnector` связывает клиентский код с серверной частью.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldConnector.java[]
----

Код виджета `RatingFieldWidget` не определяет внешний вид компонента, кроме назначения имён стилей ключевым элементам. Для того, чтобы определить внешний вид нашего компонента, создадим файлы стилей. Для этого можно воспользоваться ссылкой *Create theme extension* секции *Project properties* в навигаторе Studio. В появившемся диалоге выбираем тему `halo`. Эта тема использует вместо <<icon_set,значков>> глифы шрифта FontAwesome, чем мы и воспользуемся. Studio создаст пустые файлы SCSS для расширения темы в каталоге `themes` модуля *web*.

Стили каждого компонента принято выделять в отдельный файл `componentname.scss` в каталоге `components/componentname` в формате примеси SCSS. В каталоге `themes/halo` модуля `web` создадим структуру вложенных каталогов: `components/ratingfield`. Затем внутри `ratingfield` создадим файл `ratingfield.scss`:

image::ui_component/gwt_theme_ext_structure.png[align="center"]

[source, css]
----
include::{sourcesdir}/ui_component/gwt/ratingfield.scss[]
----

Подключим этот файл в главном файле темы `halo-ext.scss`:

[source, css]
----
include::{sourcesdir}/ui_component/gwt/halo-ext.scss[]
----

Для демонстрации работы компонента создадим новый экран в модуле *web*.

Назовите файл с экраном `rating-screen.xml`.

image::ui_component/gwt_rating_screen_designer.png[align="center"]

Перейдем к редактированию экрана `rating-screen.xml` в IDE. Нам понадобится контейнер для нашего компонента, объявим его в XML экрана:

[source, xml]
----
include::{sourcesdir}/ui_component/gwt/rating-screen.xml[]
----

Откроем класс контроллера экрана `RatingScreen.java` и добавим код размещения нашего компонента на экране:

[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingScreen.java[]
----

Запускаем сервер приложения и смотрим на результат.

image::ui_component/rating_screen_result.png[align="center"]

[[own_component_in_studio]]
===== Поддержка собственных компонентов в CUBA Studio

В данном разделе описывается, как добавить поддержку новых визуальных компонентов в дизайнер экранов CUBA Studio. Новый компонент появится в палитре компонентов, вы сможете перетаскивать его в рабочую область и редактировать его свойства в панели свойств компонента.

Рассмотрим процесс создания интеграции компонента `stepper`, создание которого было описано в разделе <<vaadin_addon_sample_gui>>.

Откроем проект, содержащий компонент `stepper`.

[TIP]
====
Если указанный проект вы не создавали, то вы можете воспроизвести шаги, описанные ниже, и на новом проекте. Вы увидите поддержку компонента в Studio, но не сможете запустить приложение.
====

Нажмем кнопку *Extend Studio* на панели *Project properties*.

image::ui_component/ui_component_extension_window.png[align="center"]

Рассмотрим поля, которые необходимо заполнить.

* *Configuration name* - идентификатор конфигурации. Введем значение `stepper`.

* *Component XML element* - имя компонента в том виде, как он должен быть добавлен в XML-дескриптор экрана. В нашем случае это `stepper`.
+
Поля *Component class name* и *Component model class name* будут заполнены автоматически на основе введенного значения. Оставьте их значения без изменения.

* *Component namespace URI* - пространство имен из XSD, описывающего компонент. Если вы генерировали новый компонент с помощью Studio, то узнать значение для этого поля вы можете в файле `ui-component.xsd`.

* *Component namespace prefix* - префикс XML-элемента компонента в XML-дескриптор экрана.

* *Standard properties* - стандартные свойства компонента, которые должны быть доступны для редактирования в панели свойств компонента в дизайнере экранов.
+
Выберите `caption`, `datasource` и `property`.
+
[TIP]
====
Свойства `id`, `align`, `height`, `width`, `enable`, `stylename`, `visible` по умолчанию доступны для всех компонентов.
====

* *Custom properties* - в данной таблице добавляются специфичные для компонента свойства, которые должны редактироваться в панели свойств дизайнера экранов.
+
--
Добавим следующие свойства:

* *manualInput*, тип `Boolean`, значение по умолчанию `true`

* *mouseWheel*, тип `Boolean`, значение по умолчанию `true`

* *stepAmount*, тип `Integer`, значение по умолчанию `0`

* *maxValue*, тип `Integer`, значение по умолчанию `0`

* *minValue*, тип `Integer`, значение по умолчанию `0`
--

Далее нажмите кнопку *OK*.

Новые визуальные компоненты инициализируются при старте сервера Studio. Откройте окно сервера Studio, остановите сервер, выйдите из Studio, затем отройте и запустите его снова.

Сгенерируем стандартные экраны для сущности `Customer` заново, чтобы стереть результаты наших прошлых экспериментов.

Переходим в секцию *GENERIC UI* навигатора студии и открываем экран `customer-edit`.

Для начала удалим поле `score` из `fieldGroup`, т.к. мы хотим для его редактирования использовать специальный компонент.

На палитре компонентов найдите новый компонент `Stepper` и перетащите его на экран под `fieldGroup`.

image::ui_component/stepper_in_palette.png[align="center"]

Выделите компонент `stepper` и перейдите на закладку свойств компонента *Properties*.

image::ui_component/stepper_component_properties.png[align="center"]

Заполните необходимые поля:

* *id* - `stepper`

* *caption* - `Stepper`

* *datasource* - `customerDs`

* *property* - `score`

* *maxValue* - `50`

После этого перейдите на закладку *XML*, чтобы увидеть результат.

[source, xml]
----
include::{sourcesdir}/ui_component/studio_support/customer-edit.xml[]
----

В XML экрана объявлено пространство имен компонента с префиксом `app`, компонент `stepper` добавлен на экран, и у него установлены необходимые свойства.

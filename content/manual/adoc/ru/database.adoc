[[databases]]
== Работа с базой данных

В данном разделе приведены практические рекомендации по работе с базой данных на этапах разработки и эксплуатации приложения.

Информация о том, как сконфигурировать приложение для работы с некоторой СУБД, приведена в разделе <<dbms>>.

[[db_update_in_dev]]
=== Создание схемы БД

В процессе разработки приложения возникает необходимость создания и поддержания схемы базы данных, соответствующей моделируемым сущностям. Для решения этой задачи платформа предлагает подход на основе <<db_scripts,скриптов создания и обновления БД>>. Далее рассматриваются практические шаги по применению этого подхода.

Задача по созданию и поддержке схемы БД состоит из двух частей: создание скриптов и их выполнение.

Скрипты могут быть созданы как вручную, так и с помощью Studio. Рассмотрим процесс создания скриптов в Studio. Для этого выполните команду *Generate DB scripts*, расположенную в секции *Entities*. При этом Studio подключается к базе данных, определенной на странице *Project properties*, и сравнивает имеющуюся схему БД с текущей моделью данных.

Если база данных отсутствует, либо в ней нет таблиц *SYS_DB_CHANGELOG* и *SEC_USER*, то генерируются только скрипты инициализации БД. В противном случае создаются также и скрипты обновления. Затем открывается страница, содержащая сгенерированные скрипты.

На вкладке *Update scripts* отображаются скрипты обновления. Скрипты со статусом *new* отражают разницу между текущим состоянием модели данных и схемы БД. Для каждой создаваемой или изменяемой таблицы создается отдельный скрипт. В отдельные скрипты помещаются также наборы ограничений целостности таблиц (referential integrity constraints). При закрытии страницы нажатием *OK* скрипты сохраняются в каталог `db/update/{db_type}` модуля *core*.

Со статусом *applied* отображаются скрипты, уже имеющиеся в проекте и примененные в БД ранее. Они не могут быть отредактированы или удалены.

На вкладке *Update scripts* могут также отображаться скрипты со статусом *to be deleted*. Это файлы, имеющиеся в проекте, но не примененные в БД. При закрытии страницы нажатием *OK* эти файлы будут удалены. Это нормально, если эти скрипты были созданы вами при предыдущей генерации, но не были применены вызовом *Update database*. В этом случае они больше не нужны, так как текущая разница между схемой БД и моделью данных отражена в новых только что сгенерированных скриптах. Если же, например, эти скрипты получены вами из системы контроля версий от другого разработчика, то вам следует отменить сохранение и сначала применить чужие скрипты на своей БД, а уже потом генерировать новые.

Вкладки *Init tables*, *Init constraints*, *Init data* отображают скрипты _создания_ БД, располагающиеся в каталоге `db/init/{db_type}` модуля *core*.

На вкладке *Init tables* отображается скрипт создания таблиц `10.create-db.sql`. Код, относящийся к одной таблице, отделяется комментариями `++begin {table_name} ... end {table_name}++`. При изменении некоторой сущности в модели Studio заменит код только между комментариями для соответствующей таблицы, не трогая остальной код, в который могли быть внесены ручные изменения. Поэтому при ручном редактировании не удаляйте эти комментарии, иначе Studio не сможет правильно встраивать свои изменения в существующие файлы.

На вкладке *Init constraints* отображается скрипт создания ограничений целостности `20.create-db.sql`. В нем также присутствуют разделяющие таблицы комментарии, которые нельзя удалять.

На вкладке *Init data* отображается скрипт `30.create-db.sql`, предназначенный для внесения дополнительной информации при инициализации БД. Это могут быть, например, функции, триггеры, или DML операторы для наполнения базы необходимыми данными. Содержимое данного скрипта создается вручную при необходимости.

[TIP]
====
На начальной стадии разработки приложения, когда модель данных активно меняется, рекомендуется пользоваться только скриптами _создания_ БД (расположенными на вкладках *Init tables*, *Init constraints*, *Init data*), а скрипты обновления на вкладке *Update scripts* удалять сразу после вызова команды *Generate DB scripts*. Это наиболее простой и надежный способ поддержания БД в актуальном состоянии. Разумеется, он имеет один существенный недостаток - при применении скриптов БД пересоздается с нуля, поэтому все внесенные в нее данные теряются. Этот недостаток можно частично компенсировать на этапе разработки, добавив в скрипт *Init data* команды для создания первичных данных при инициализации.

Скрипты _обновления_ становятся удобным и необходимым инструментом разработки и сопровождения БД на более позднем этапе, когда модель данных относительно стабильна, а в базах данных у разработчиков и в эксплуатации накоплены данные, которые нельзя терять при пересоздании БД с нуля.
====

Для применения скриптов используйте механизм <<db_update_gradle,выполнения скриптов БД задачами Gradle>>: чтобы пересоздать базу данных полностью, вызовите в главном меню пункт *Run* → *Create database*, а чтобы применить скрипты обновления - пункт *Run* → *Update database*. Следует иметь в виду, что эти пункты доступны, только если сервер приложения остановлен. Разумеется, соответствующие задачи Gradle (`createDb` и `updateDb`) можно вызвать в любой момент из командной строки, но если при этом база данных или какие-либо ее объекты заняты, выполнение скриптов завершится с ошибкой.

[[db_mssql_features]]
=== Особенности MS SQL Server

*Microsoft SQL Server* использует кластерные индексы для таблиц.

По умолчанию кластерный индекс создается по первичному ключу таблицы, однако используемые в CUBA-приложении ключи типа `UUID` плохо подходят для кластерного индекса. Мы рекомендуем создавать первичные ключи типа UUID с модификатором `nonclustered`:

[source, sql]
----
create table SALES_CUSTOMER (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    primary key nonclustered (ID)
)^
----

[[db_oracle_features]]
=== Особенности Oracle Database

В связи с политикой распространения JDBC драйвера Oracle его можно скачать только вручную с сайта link:$$http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html$$[http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html].

После скачивания скопируйте JAR с драйвером `ojdbc6.jar` в подкаталог `lib` Studio и подкаталог `lib` установленного сервера Tomcat. После этого необходимо остановить Studio, остановить демона Gradle, выполнив

[source, plain]
----
gradle --stop
----

в командной строке, а затем снова запустить Studio.

Для версии Studio SE скопируйте JAR-файл с драйвером в подкаталог `~/.haulmont/studio/lib/` Studio и подкаталог `lib`  установленного сервера Tomcat.

[[db_mysql_features]]
=== Особенности MySQL

JDBC-драйвер MySQL не распространяется в составе CUBA Studio в связи с его лицензией, поэтому его нужно установить отдельно:

* Загрузите архив с драйвером со страницы https://dev.mysql.com/downloads/connector/j

* Извлеките JAR-файл и переименуйте его в `mysql-connector-java.jar`

* Положите JAR-файл в каталог `~/.haulmont/studio/lib/` и в подкаталог `lib` установленного сервера Tomcat

* После этого остановите Studio и демона Gradle, выполнив в командной строке `gradle --stop`, а затем снова запустите Studio

MySQL не поддерживает частичные (partial) индексы, поэтому единственная возможность создать ограничение уникальности для <<soft_deletion,soft deleted>> сущности - это использовать в составе индекса колонку `DELETE_TS`. Однако, существует другая проблема: MySQL позволяет иметь несколько NULLs в колонке с ограничением уникальности. Так как стандартная колонка `DELETE_TS` является nullable, она не может быть использована в уникальном индексе. Рекомендуется следующий способ создания уникальных ограничений для сущностей с мягким удалением:

. Создайте в таблице колонку `DELETE_TS_NN` с параметром not null и значением по умолчанию:
+
[source, sql]
----
create table DEMO_CUSTOMER (
    ...
    DELETE_TS_NN datetime(3) not null default '1000-01-01 00:00:00.000',
    ...
)
----

. Создайте триггер, изменяющий `DELETE_TS_NN` когда меняется `DELETE_TS`:
+
[source, sql]
----
create trigger DEMO_CUSTOMER_DELETE_TS_NN_TRIGGER before update on DEMO_CUSTOMER
for each row
    if not(NEW.DELETE_TS <=> OLD.DELETE_TS) then
        set NEW.DELETE_TS_NN = if (NEW.DELETE_TS is null, '1000-01-01 00:00:00.000', NEW.DELETE_TS);
    end if
----

. Создайте уникальный индекс, включающий в себя уникальные колонки и `DELETE_TS_NN`:
+
[source, sql]
----
create unique index IDX_DEMO_CUSTOMER_UNIQ_NAME on DEMO_CUSTOMER (NAME, DELETE_TS_NN)
----

[[db_schema_connection]]
=== Использование произвольной схемы БД

PostgreSQL и Microsoft SQL Server поддерживают подключение к произвольной схеме внутри базы данных. По умолчанию на PostgreSQL используется схема `public`, на SQL Server - схема `dbo`.

*PostgreSQL*

Для использования произвольной схемы на PostgreSQL укажите параметр `currentSchema` в свойстве `connectionParams` задач сборки <<build.gradle_createDb,createDb>> и <<build.gradle_updateDb,updateDb>>, например:

[source, groovy]
----
include::{sourcesdir}/database/db_schema_connection_1.groovy[]
----

При использовании Studio, добавьте этот параметр в поле *Connection params* страницы *Project properties*. При этом Studio автоматически обновит `build.gradle`. После этого можно запускать обновление или пересоздание БД, все таблицы будут созданы в указанной схеме.

*Microsoft SQL Server*

На Microsoft SQL Server указания параметра подключения недостаточно, необходимо также создать связь между пользователем БД и схемой. Ниже приведен пример создания базы данных и использования схемы.

* Создайте login:
+
[source, sql]
----
create login JohnDoe with password='saPass1'
----

* Создайте новую БД:
+
[source, sql]
----
create database my_db
----

* Подключитесь к новой БД как `sa`, создайте схему, затем создайте пользователя и дайте ему права владельца:
+
[source, sql]
----
create schema my_schema

create user JohnDoe for login JohnDoe with default_schema = my_schema

exec sp_addrolemember 'db_owner', 'JohnDoe'
----

После этого необходимо указать параметр подключения `currentSchema` в свойстве `connectionParams` задачи сборки <<build.gradle_updateDb,updateDb>> (или в свойствах проекта в Studio). На самом деле, данный параметр никак не обрабатывается драйвером JDBC для SQL Server, но он указывает Studio и плагину Gradle какую схему использовать.

[source, groovy]
----
include::{sourcesdir}/database/db_schema_connection_2.groovy[]
----

Имейте в виду, что пересоздавать БД SQL Server из Studio или выполнением `createDb` в командной строке нельзя, так как использование не-дефолтной схемы требует ассоциации с пользователем. Однако можно выполнять *Update database* в Studio или `updateDb` в командной строке, и все необходимые таблицы будут созданы в существующей базе данных и в указанной схеме.

[[db_update_in_prod]]
=== Создание и обновление БД при эксплуатации приложения

В данном разделе рассматриваются способы создания и обновления базы данных на этапе развертывания и эксплуатации приложения. Для знакомства с устройством и правилами создания скриптов БД см. <<db_scripts,Скрипты создания и обновления БД>> и <<db_update_in_dev,Создание схемы БД>>.

[[db_update_in_prod_by_server]]
==== Использование механизма выполнения скриптов БД сервером

<<db_update_server,Механизм выполнения скриптов БД сервером>> можно использовать как для первичной инициализации базы данных, так и для ее последующего обновления в процессе развития приложения и изменения схемы данных.

Чтобы инициализировать новую базу данных, нужно выполнить следующее:

* Включите свойство приложения <<cuba.automaticDatabaseUpdate,cuba.automaticDatabaseUpdate>>, добавив следующую строку в файл <<app_properties_files,local.app.properties>> блока Middleware:
+
[source, properties]
----
cuba.automaticDatabaseUpdate = true
----
+
В случае <<fast_deployment,быстрого развертывания>> в Tomcat этот файл находится в каталоге `tomcat/conf/app-core`. Если файл не существует, создайте его.

* Создайте пустую базу данных, соответствующую URL, заданному в описании источника данных в <<context.xml,context.xml>>.

* Запустите сервер приложения, содержащий блок *Middleware*. На старте приложения БД будет проинициализирована и сразу же готова к работе.

В дальнейшем при каждом старте сервера приложения механизм выполнения скриптов будет сравнивать набор скриптов, находящийся в <<db_dir,каталоге скриптов базы данных>>, со списком выполненных скриптов, зарегистрированным в БД. При появлении в каталоге новых скриптов они будут выполнены и также зарегистрированы. Таким образом, достаточно в каждую новую версию приложения включать скрипты обновления, и при рестарте сервера приложения база данных будет приводиться в актуальное состояние.

При эксплуатации механизма выполнения скриптов на старте сервера следует иметь в виду следующее:

* При любой ошибке выполнения скрипта блок *Middleware* прерывает инициализацию и становится неработоспособным. Клиентские блоки выдают сообщения о невозможности подключения к *Middleware*.
+
Для выяснения причин сбоя необходимо открыть файл лога `app.log` в <<log_dir,каталоге журналов>> сервера и найти сообщения о выполнении SQL от логгера `com.haulmont.cuba.core.sys.DbUpdaterEngine`, и, возможно, последующие сообщения об ошибках.

* Скрипты обновления, а также отделенные символом "^" команды DDL и SQL внутри скриптов выполняются в отдельных транзакциях. Поэтому при возникновении ошибки при обновлении существует большая вероятность того, что часть скриптов, или даже отдельных команд последнего скрипта, выполнилась и зафиксирована в БД.
+
В связи с этим рекомендуется непосредственно перед запуском сервера с новой версией приложения делать резервное сохранение БД. Тогда после устранения причины ошибки достаточно восстановить БД и запустить автоматический процесс вновь.
+
Если бэкап БД отсутствует, то после устранения причины ошибки необходимо выяснить, какая часть вызвавшего ошибку скрипта выполнилась и закоммичена. Если скрипт не выполнился целиком, то можно сразу снова запускать автоматический процесс. Если же часть команд до ошибочной была отделена символом "^", выполнялась в отдельной транзакции и была закоммичена, то необходимо выполнить оставшуюся часть команд, а затем зарегистрировать данный скрипт в *SYS_DB_CHANGELOG* вручную. После этого можно стартовать сервер, механизм автоматического обновления продолжит работу со следующего невыполненного скрипта.
+
CUBA Studio генерирует скрипты обновления с символом ";" в качестве разделителями для всех типов БД, кроме Oracle. Если команды скрипта разделены точками с запятой, они выполняются в одной транзакции, и в случае ошибки скрипт откатывается целиком. Тем самым обеспечивается постоянное соответствие между структурой БД и списком выполненных скриптов обновления.

[[db_update_in_prod_cmdline]]
==== Инициализация и обновление БД из командной строки

Скрипты создания и обновления БД могут быть запущены из командной строки с помощью класса `com.haulmont.cuba.core.sys.utils.DbUpdaterUtil`, входящего в состав блока *Middleware* платформы. При запуске должны быть переданы следующие аргументы:

* `dbType` – <<dbms_types,тип СУБД>>, возможные значения: postgres, mssql, oracle, mysql.

* `dbVersion` – <<dbms_version,версия СУБД>> (необязательный аргумент).

* `dbDriver` - имя класса JDBC-драйвера (необязательный аргумент). Если не передан, имя класса драйвера определяется исходя из `dbType`.

* `dbUser` - имя пользователя БД.

* `dbPassword` - пароль пользователя БД.

* `dbUrl` - URL для подключения к БД. Для выполнения первичной инициализации указанная база данных должна быть пустой, никакой предварительной очистки ее не производится.

* `scriptsDir` - абсолютный путь к каталогу, содержащему скрипты в стандартной структуре. Как правило, используется <<db_dir,каталог скриптов базы данных>>, поставляемый с приложением.

* одна из возможных команд:

** `create` - выполнить инициализацию базы данных.

** `check` - отобразить список невыполненных скриптов обновления.

** `update` - выполнить обновление базы данных.

Пример скрипта для Linux, запускающего `DbUpdaterUtil`:

[source, bash]
----
include::{sourcesdir}/database/dbupdate.sh[]
----

Данный скрипт рассчитан на работу с БД с именем `mydb`, расположенной на локальном сервере PostgreSQL. Скрипт должен быть расположен в каталоге `bin` сервера Tomcat, и запускаться с параметрами `{имя пользователя}`, `{пароль}`, `{команда}`, например:

[source]
----
./dbupdate.sh cuba cuba123 update
----

Ход выполнения скриптов отображается в консоли. При возникновении ошибок обновления следует поступать так же, как описано в предыдущем разделе для механизма автоматического обновления.

[WARNING]
====
При обновлении БД из командной строки имеющиеся Groovy-скрипты запускаются, но реально отрабатывает только их основная часть. По причине отсутствия контекста сервера PostUpdate-часть игнорируется с выдачей в консоль соответствующего сообщения.
====

[[db_hsql_connect]]
=== Подключение к HSQLDB с помощью Squirrel SQL

*HSQLDB*, он же *HyperSQL*, является удобной СУБД для прототипирования приложений, так как не требует установки, и запускается автоматически в CUBA Studio, если для проекта выбрано использование этой СУБД. В данном разделе описан способ подключения к базе данных HSQLDB через внешний инструмент, позволяющий работать со структурой и данными напрямую средствами SQL.

*SQuirreL SQL Client* является свободно распространяемым Java-приложением, позволяющим работать с базами данных через JDBC. Загрузить Squirrel SQL можно по адресу link:$$http://squirrel-sql.sourceforge.net$$[http://squirrel-sql.sourceforge.net].

Перед запуском *Squirrel SQL* найдите файл `hsqldb-x.x.x.jar` в подкаталоге `lib` каталога установки *CUBA Studio* и скопируйте его в подкаталог `lib` каталога установки *Squirrel SQL*.

Запустите *Squirrel SQL* и откройте вкладку *Drivers*. Убедитесь что драйвер *HSQLDB Server* активен.

Откройте вкладку *Aliases* и нажмите на кнопку *Create a new Alias*.

В открывшемся окне укажите параметры подключения - Database URL, пользователя и пароль. По умолчанию пользователь - sa, пароль отсутствует. Database URL можно найти на вкладке *Project properties* в CUBA Studio или скопировать из файла `modules/core/web/META-INF/context.xml` проекта.

image::db_hsql_setAliasProperties.png[align="center"]
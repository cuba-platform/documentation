[[development]]
== Разработка приложений

Данная глава содержит практическую информацию по созданию приложений на основе платформы.

[[recommended_code_style]]
=== Рекомендуемый стиль кода

*Форматирование кода*

* Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе http://www.oracle.com/technetwork/java/codeconvtoc-136057.html[Code Conventions for the Java Programming Language]. При программировании в *IntelliJ IDEA* для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш *Ctrl-Alt-L*.
+
Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

* XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

*Соглашения по именованию*

[cols="3*.^", frame="all", options="header"]
|===

^| Идентификатор ^| Правило именования ^| Пример

3+^| *Java и Groovy классы*

| Класс контроллера экрана
| UpperCamelCase

Контроллер экрана списка сущностей − `{КлассСущности}Browse`

Контроллер экрана редактирования − `{КлассСущности}Edit`

| `CustomerBrowse`

`OrderEdit`

3+^| *XML дескрипторы экранов*

| Идентификатор компонента, имена параметров в запросах
| lowerCamelCase, только буквы и цифры
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Идентификатор источника данных
| lowerCamelCase, только буквы и цифры, оканчивается на Ds
| `attributesDs`

3+^| *SQL скрипты*

| Зарезервированные слова| lowercase| `create table`

| Таблицы | UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.| `++SALES_CUSTOMER++`

| Колонки | UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

|Колонки внешних ключей | UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.| `++CUSTOMER_ID++`

| Индексы | UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс. | `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Файловая структура проекта

Рассмотрим файловую структуру проекта на примере простого приложения *Sales*, состоящего из <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal*.

.Файловая структура проекта
image::project_structure.png[align="center"]

В корне проекта расположены скрипты сборки `build.gradle`, `settings.gradle` и проектные файлы *IntelliJ IDEA*.

В каталоге `modules` расположены подкаталоги <<app_modules,модулей>> проекта − *global*, *core*, *gui*, *portal, web*. 

.Структура модуля global
image::project_structure_global.png[align="center"]

Модуль *global* содержит каталог исходных текстов `src`, в корне которого располагаются конфигурационные файлы <<metadata.xml,metadata.xml>>, <<persistence.xml,persistence.xml>> и <<views.xml,views.xml>>. Пакет `com.sample.sales.service` содержит интерфейсы сервисов *Middleware*, пакет `com.sample.sales.entity` - классы <<data_model,сущностей>> и <<message_packs,файлы локализации>> для них.

.Структура модуля core
image::project_structure_core.png[align="center"]

Модуль *core* содержит следующие каталоги:

* `db` - каталог <<db_scripts,скриптов создания и обновления>> базы данных.

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Middleware* и конфигурационный файл <<spring.xml,spring.xml>>. Пакет `com.samples.sales.service` содержит классы реализации <<services,сервисов>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Middleware*: <<context.xml,context.xml>> и <<web.xml,web.xml>>.

.Структура модуля gui
image::project_structure_gui.png[align="center"]

Модуль *gui* содержит каталог исходных текстов `src`, в корне которого располагается конфигурационный файл <<screens.xml,screens.xml>>. Пакет `com.sample.sales.gui` содержит XML-дескрипторы и контроллеры экранов и <<message_packs,файлы локализации>> для них.

.Структура модуля web
image::project_structure_web.png[align="center"]

Модуль *web* содержит следующие каталоги:

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Web Client* и конфигурационные файлы <<menu.xml,web-menu.xml>>, <<permissions.xml,web-permissions.xml>>, <<screens.xml,web-screens.xml>> и <<spring.xml,web-spring.xml>>. Пакет `com.samples.sales.web` содержит главный класс блока *Web Client* (наследник `DefaultApp`) и <<main_message_pack,главный пакет локализованных сообщений>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Web Client*: <<context.xml,context.xml>> и <<web.xml,web.xml>>.

[[build_scripts]]
=== Скрипты сборки

Для сборки проектов на основе платформы используется система сборки *Gradle*. Скрипты сборки представляют собой два файла в корневом каталоге проекта: 

* `settings.gradle` - задает название и состав <<app_modules,модулей>> проекта

* `build.gradle` - определяет конфигурацию сборки.

В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.

[[build.gradle]]
==== Структура build.gradle

В данном разделе описывается структура и основные элементы скрипта `build.gradle`.

buildscript::
+
--
В секции `buildscript` задается следующее:

* Версия платформы, на которой основан данный проект.

* Набор репозиториев, из которых будут загружаться зависимости проекта. Настройка доступа к репозиториям описана <<access_to_repo,ниже>>.

* Зависимости, используемые системой сборки, включая плагин CUBA для Gradle.

После секции `buildscript` объявляются несколько переменных, используемых далее в скрипте.
--

cuba::
+
--
Логика сборки, специфичная для CUBA, сосредоточена в Gradle плагине `cuba`. Он подключается в корне скрипта и в секциях `configure` каждого модуля:

[source, groovy]
----
apply(plugin: 'cuba')
----

Параметры плагина *cuba* задаются в секции `cuba`:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Рассмотрим доступные параметры:

* `artifact` - задает группу и версию собираемых <<artifact,артефактов>> проекта. Имена артефактов формируются на основе имен модулей, заданных в `settings.gradle`.

** `group` - группа артефактов.
** `version` - версия артефактов.
** `isSnapshot` - если установлено в `true`, то в именах артефактов будет присутствовать суффикс `SNAPSHOT`.
+
Версию артефактов можно переопределить в командной строке, например:
+
[source, plain]
----
gradle assemble -Pcuba.artifact.version=1.1.1
----

* `tomcat` - задает параметры сервера Tomcat, который используется для <<fast_deployment, быстрого развертывания>>.

** `dir` - расположение каталога <<build.gradle_setupTomcat, установки>> Tomcat.
** `port` - порт сервера; по умолчанию 8080.
** `debugPort` - порт для подключения Java отладчика; по умолчанию 8787.
** `shutdownPort` - порт для передачи команды `SHUTDOWN`; по умолчанию 8005.
** `ajpPort` - порт AJP connector; по умолчанию 8009.

* `ide` - задает некоторые параметры для Studio и IDE.

** `vcs` - тип используемой в проекте VCS. В данный момент поддерживаются только `Git` и `svn`.
** `copyright` - текст Copyright Notice, вставляемый в начало файлов исходных текстов.
** `classComment` - текст комментария, который будет расположен над объявлением класса в исходных текстах Java.

* `uploadRepository` - задает параметры <<artifact_repository,репозитория>>, в который будут выгружаться собранные артефакты проекта при выполнении задачи `uploadArchives`.
+
** `url` - URL репозитория. По умолчанию используется репозиторий Haulmont.
** `user` - имя пользователя репозитория.
** `password` - пароль пользователя репозитория.
+
Параметры репозитория выгрузки артефактов можно передать в командной строке с помощью следующих аргументов:
+
[source]
----
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
----
--

dependencies::
+
--
Данная секция описывает набор <<app_components,компонентов приложения>>, используемых в проекте. Компоненты указываются координатами артефакта их модуля *global*. В примере ниже используются три компонента: `com.haulmont.cuba` (компонент *cuba* платформы), `com.haulmont.reports` (премиум-дополнение *reports*) и `com.company.base` (кастомный компонент):

[source, groovy]
----
dependencies {
  appComponent("com.haulmont.cuba:cuba-global:$cubaVersion")
  appComponent("com.haulmont.reports:reports-global:$cubaVersion")
  appComponent("com.company.base:base-global:0.1-SNAPSHOT")
}
----
--

configure::
+
--
Секции `configure` описывают конфигурацию <<app_modules,модулей>>. Наиболее важная часть конфигурации - описание зависимостей, например:

[source,groovy]
----
include::{sourcesdir}/development/build_gradle_2.groovy[]
----

Нестандартные зависимости модулей можно задавать в Studio на вкладке *Project properties > Advanced*. См. также контекстную помощь Studio.
--

[TIP]
====
В случае транзитивных зависимостей и конфликта версий будет использована стандартная стратегия разрешения версий Maven. Согласно этой стратегии, релизные версии имеют приоритет над snapshot-версиями, а более точный числовой квалификатор имеет приоритет над более общим. При прочих равных, строковые квалификаторы приоритизируются в алфавитном порядке. Пример:

[source, plain]
----
1.0-beta1-SNAPSHOT         // низкий приоритет
1.0-beta1
1.0-beta2-SNAPSHOT         |
1.0-rc1-SNAPSHOT           |
1.0-rc1                    |
1.0-SNAPSHOT               |
1.0                        |
1.0-sp                     V
1.0-whatever
1.0.1                      // высокий приоритет
----
====

[[access_to_repo]]
==== Настройка доступа к репозиторию

Основной репозиторий::
+
--
При создании нового проекта в CUBA Studio вам необходимо выбрать основной репозиторий, содержащий артефакты платформы. По умолчанию имеется два таких репозитория (может быть больше если установлен <<private_repo,приватный репозиторий>>):

* `++https://repo.cuba-platform.com/content/groups/work++` - репозиторий, расположенный на сервере Haulmont. Он требует передачи общих имени и пароля, которые указываются прямо в скрипте сборки (`cuba` / `cuba123`).

* `++https://dl.bintray.com/cuba-platform/main++` - репозиторий, находящийся в https://bintray.com[JFrog Bintray]. Он предоставляет анонимный доступ.

Оба репозитория имеют идентичное содержимое для последних версий платформы, но Bintray не содержит снэпшотов. Мы предполагаем, что Bintray является более надежным для доступа из любой точки мира.

В случае Bintray, скрипт сборки сконфигурирован также для использования репозиториев Maven Central, JCenter и Vaadin Add-ons по отдельности.
--

[[access_to_premium_repo]]
Доступ к премиум-дополнениям CUBA::
+
--
Если ваш проект использует премиум-дополнения, Studio добавляет еще один репозиторий:

* В случае `repo.cuba-platform.com` это `++https://repo.cuba-platform.com/content/groups/premium++`

* В случае Bintray это `++https://cuba-platform.bintray.com/premium++`

Если используется <<private_repo,приватный репозиторий>>, автоматически ничего не добавляется, так как предполагается, что он проксирует все CUBA-репозитории, включая премиум.

Оба репозитория премиум-дополнений требуют указания имени пользователя и пароля, которые предоставляются по подписке на разработчика. Первая часть лицензионного ключа до тире представляет собой имя пользователя, вторая часть после тире - пароль. Например, если ваш ключ `111111222222-abcdefabcdef`, то имя - `111111222222`, пароль - `abcdefabcdef`

Studio передает Gradle параметры подключения когда запускает скрипт сборки. При сборке проекта вне Studio передайте `premiumRepoUser` и `premiumRepoPass` в командной строке в аргументах `-P`. В случае Bintray, к имени пользователя нужно в конце добавить `@cuba-platform`.

Пример сборки используя `repo.cuba-platform.com`:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Пример сборки используя Bintray:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222@cuba-platform -PpremiumRepoPass=abcdefabcdef
----

Чтобы при сборке проекта из командной строки не передавать имя и пароль каждый раз, можно однократно задать их одним из следующих способов.

* Либо создать файл `~/.gradle/gradle.properties` и указать параметры в нем:

[source]
----
premiumRepoUser=111111222222
premiumRepoPass=abcdefabcdef
----

* Либо указать параметры в следующих переменных среды операционной системы:

* `CUBA_PREMIUM_USER` - используется если не передан `premiumRepoUser`.

* `CUBA_PREMIUM_PASSWORD` - используется если не передан `premiumRepoPass`.
--

[[custom_repositories]]
Дополнительные репозитории::
+
--
Проект может использовать любые дополнительные репозитории, содержащие <<app_components,компоненты приложения>>. Они должны быть вручную указаны в `build.gradle` *после* основного репозитория, например:

[source,groovy]
----
include::{sourcesdir}/development/access_to_repo_1.groovy[]
----
--

[[build.gradle_tasks]]
==== Задачи сборки

Исполняемыми единицами в Gradle являются _задачи_ (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в `build.gradle`. 

[[build.gradle_buildInfo]]
===== buildInfo

Задача `buildInfo` автоматически добавляется в конфигурацию модуля `global` плагином CUBA для Gradle. Она записывает файл `build-info.properties` с информацией о приложении в артефакт `global` (например, `app-global-1.0.0.jar`). Во время работы приложения, эта информация читается бином `BuildInfo` и отображается на экране *Help > About*. Данный бин может также вызываться другими механизмами для получения информации о имени, версии и т.д. приложения.

В проекте можно явно указать следующие параметры задачи:

* `appName` - имя приложения. По умолчанию используется имя проекта, заданное в `settings.gradle`.

* `artifactGroup` - группа артефактов, которая по конвенции равна корневому пакету проекта.

* `version` - версия приложения. По умолчанию используется версия, заданная в свойстве `cuba.artifact.version`.

* `properties` - мэп произвольных свойств. По умолчанию пусто.

Пример указания параметров задачи:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildInfo_1.groovy[]
----

[[build.gradle_buildUberJar]]
===== buildUberJar

`buildUberJar` – задача типа `CubaUberJarBuilding`, выполняющая сборку приложения и его зависимостей в JAR-файл вместе со встроенным HTTP-сервером Jetty. Можно создать либо один all-in-one JAR, либо несколько по числу <<app_tiers,блоков>> приложения, используемых в проекте, например, `app-core.jar` для Middleware и `app.jar` для Web Client.

Задача должна быть объявлена в корне скрипта `build.gradle`. Собранные JAR-файлы находятся в подкаталоге `build/distributions` проекта. Руководство по запуску собранных JAR-файлов смотрите в разделе  <<uberjar_deployment>>.

[TIP]
====
Эту задачу можно настроить на странице *Deployment settings > Uber JAR* в Studio. См. контекстную помощь.
====

Параметры задачи:

* `coreJettyEnvPath` - обязательный параметр, содержащий относительный (от корня проекта) путь к файлу, в котором содержатся определения ресурсов JNDI для HTTP-сервера Jetty. Как минимум, этот файл должен содержать определение источника данных JDBC для основной базы данных. Studio может сгенерировать этот файл, используя установленные параметры подключения к базе данных.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    coreJettyEnvPath = 'modules/core/web/META-INF/jetty-env.xml'
    // ...
}
----
+
Вы можете передавать разные настройки подключения к БД для одного UberJar во время работы приложения, используя несколько файлов <<jetty-env,jetty-env.xml>> и аргумент <<uberjar_deployment,командной строки>> `-jettyEnvPath`.

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `WEB-INF/local.app.properties` внутри создаваемых JAR.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    appProperties = ['cuba.automaticDatabaseUpdate' : true]
    // ...
}
----

* `singleJar` - если установлен в `true`, то создается единый JAR, включающий все модули проекта (core, web, portal). По умолчанию `false`.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    singleJar = true
    // ...
}
----

* `webPort` - порт встроенного HTTP-сервера для единого (если `singleJar=true`) или web JAR. Если не установлен, имеет значение `8080`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `corePort` - порт встроенного HTTP-сервера для core JAR. Если не установлен, имеет значение `8079`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `portalPort` - порт встроенного HTTP-сервера для portal JAR. Если не установлен, имеет значение `8081`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `appName` - имя приложения, по умолчанию `app`. Его можно изменить для всего проекта, заполнив поле *Module prefix* на вкладке *Project Properties > Advanced* в Studio, либо установить его только для задачи `buildUberJar`, использовав этот параметр, например:
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    appName = 'sales'
    // ...
}
----
+
После изменения имени приложения на `sales` задача создаст файлы `sales-core.jar` и `sales.jar`, и веб-клиент будет доступен по адресу `++http://localhost:8080/sales++`. Вы также можете изменить веб-контекст (последнюю часть URL после /) во время работы приложения, не изменяя заранее имени приложения, с помощью аргумента командной строки `-contextName`, или просто переименовав сам JAR файл.

* `logbackConfigurationFile` - задает относительный путь к файлу, в котором содержится конфигурация логирования.
+
Например:
+
[source, groovy]
----
logbackConfigurationFile = "/modules/global/src/logback.xml"
----

* `useDefaultLogbackConfiguration` - пока установлено значение `true` (по умолчанию), задача будет копировать конфигурацию из её собственного стандартного файла `logback.xml`.

* `webJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для единого JAR (если `singleJar=true`) или web JAR (если `singleJar=false`). См. https://www.eclipse.org/jetty/documentation/9.4.x/jetty-xml-config.html.

* `coreJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для core JAR (если `singleJar=false`),

* `portalJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для portal JAR (если `singleJar=false`).

* `coreWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля core.

* `webWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля web.

* `portalWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля portal.

* `excludeResources` - шаблон файлов ресурсов, которые не должны быть включены в JAR.

* `mergeResources` - шаблон файлов ресурсов, которые необходимо объединить в JAR.

* `webContentExclude` - шаблон файлов ресурсов, которые не должны быть включены в web JAR.

* `coreProject` - проект Gradle, представляющий модуль core (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль web (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль portal (Web Portal). Если не установлено, используется стандартный модуль *portal* проекта.

* `polymerProject` - проект Gradle, представляющий модуль <<polymer_ui,Polymer UI>>. Если не установлено, используется стандартный модуль *polymer-client* проекта.

* `polymerBuildDir` - имя каталога, в который <<polymer_build_and_structure,собирается Polymer UI>>. По умолчанию `es6-unbundled`. Установите данный параметр, если вы изменили build preset в файле `polymer.json`.

[[build.gradle_buildWar]]
===== buildWar

`buildWar` - задача типа `CubaWarBuilding`, выполняющая сборку приложения и его зависимостей в WAR-файл. Должна быть объявлена в корне скрипта `build.gradle`. Собранные WAR-файлы находятся в подкаталоге `build/distributions` проекта.

[TIP]
====
Эту задачу можно настроить на странице *Deployment settings > WAR* в Studio. См. контекстную помощь.
====

Любое CUBA-приложение состоит как минимум из двух <<app_tiers,блоков>>: Middleware и Web Client. Поэтому наиболее естественный способ развертывания приложения это создание двух файлов WAR: один для Middleware, второй для Web Client. Это также позволяет <<scaling,масштабировать>> приложение при увеличении нагрузки. Однако раздельные WAR-файлы содержат дублированные зависимости, что увеличивает их общий размер. Кроме того, часто расширенные возможности развертывания не нужны и только усложняют процесс. Задача `CubaWarBuilding` может создавать WAR-файлы обоих типов: один файл на блок или единственный WAR, содержащий оба блока. В последнем случае блоки приложения загружаются в раздельные class loaders внутри одного веб-приложения.

Создание раздельных WAR-файлов для Middleware и Web Client::
+
--
Для создания двух отдельных WAR-файлов для Middleware и Web Client используйте следующую конфигурацию:
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Параметры задачи:

* `appName` - имя приложения. По умолчанию совпадает с *Modules prefix*, например, `app`.

* `appHome` - путь к <<app_home,домашнему каталогу>> приложения. В параметре `appHome` можно указать как абсолютный или относительный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера.

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `/WEB-INF/local.app.properties` внутри создаваемых WAR.

* `singleWar` - должен быть установлен в `false` для создания раздельных WAR-файлов.

* `includeJdbcDriver` - включить JDBC драйвер, который используется в проекте. По умолчанию `false`.

* `includeContextXml` - включить файл `context.xml`, который используется в проекте. По умолчанию `false`.

* `coreContextXmlPath` - относительный путь к файлу, который должен быть использован вместо проектного `context.xml` если параметр `includeContextXml` установлен в `true`.

* `hsqlInProcess` - если установлен в `true`, то URL подключения к БД в `context.xml` будет изменен на подключение к HSQL в режиме in-process.

* `coreProject` - проект Gradle, представляющий модуль *core* (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль *web* (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль *portal* (Web Portal). Установите данное свойство, если в проекте используется модуль *portal*. Например, `portalProject = project(':app-portal')`.

* `coreWebXmlPath`, `webWebXmlPath`, `portalWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` соответствующего блока приложения.
+
Пример использования собственных `web.xml`:
+
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_4.groovy[]
----

* `logbackConfigurationFile` - задает относительный путь к файлу, в котором содержится конфигурация логирования.
+
Например:
+
[source, groovy]
----
logbackConfigurationFile = "/modules/global/src/logback.xml"
----

* `useDefaultLogbackConfiguration` - пока установлено значение `true` (по умолчанию), задача будет копировать конфигурацию из её собственного стандартного файла `logback.xml`.

* `polymerBuildDir` - имя каталога, в который собирается <<polymer_build_and_structure,собирается Polymer UI>>. По умолчанию `es6-unbundled`. Установите данный параметр, если вы изменили build preset в файле `polymer.json`.
--

[[build.gradle_buildWar_single]]
Создание единого WAR-файла::
+
--
Для создания единого файла WAR, включающего в себя блоки Middleware и Web Client, используйте следующую конфигурацию:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

Следующие параметры должны быть указаны в дополнение к описанным выше:

* `singleWar` - должен быть опущен или установлен в `true`.

* `webXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` единого WAR. Этот файл задает два servlet context listeners, которые загружают блоки приложения: `SingleAppCoreServletListener` и `SingleAppWebServletListener`. Все параметры инициализации передаются через параметры контекста.
+
Пример файла `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Все фильтры и сервлеты при развёртывании в единый WAR-файл необходимо программно зарегистрировать, см. <<servlet_registration_single_war,Регистрация сервлетов для развертывания в единый WAR-файл>>.

Единый WAR файл содержит только модули *core* и *web* (Middleware и Web Client). Для развертывания модуля *portal* используйте раздельные WAR-файлы.
--

В разделе <<war_deployment>> содержатся пошаговые инструкции по некоторым вариантам развертывания WAR-файлов.

[[build.gradle_buildWidgetSet]]
===== buildWidgetSet

`buildWidgetSet` - задача типа `CubaWidgetSetBuilding`, которая собирает кастомный GWT widgetset если в проекте есть модуль `web-toolkit`. Данный модуль позволяет разрабатывать <<own_components,собственные визуальные компоненты>>.

Доступные параметры:

* `style` - стиль вывода скрипта: `OBF`, `PRETTY` или `DETAILED`. По умолчанию `OBF`.

* `logLevel` - уровень логирования: `ERROR`, `WARN`, `INFO`, `TRACE`, `DEBUG`, `SPAM`, or `ALL`. По умолчанию `INFO`.

* `draft` - компилировать быстро с минимумом оптимизаций. По умолчанию `false`.

Пример использования:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWidgetSet_1.groovy[]
----

[[build.gradle_createDb]]
===== createDb

`createDb` - задача типа `CubaDbCreation`, создающая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Объявляется в модуле *core*. Параметры:

* `dbms` - <<dbms_types, тип СУБД>>, задаваемый в виде строки `hsql`, `postgres`, `mssql`, или `oracle`.

* `dbName` - имя базы данных.

* `dbUser` - имя пользователя СУБД.

* `dbPassword` - пароль пользователя СУБД.

* `host` - хост и, опционально, порт СУБД в формате `host[:port]`. Если не задан, используется `localhost`.

* `connectionParams` - опциональная строка параметров которая будет добавлена в конец URL подключения.

* `masterUrl` - URL для подключения при создании БД. Если не задан, используется значение по умолчанию, зависящее от типа СУБД и параметра `host`.

* `dropDbSql` - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `createDbSql` - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `driverClasspath` - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом ":" на Linux и символом ";" на Windows. Если не задан, используются зависимости, входящие в конфигурацию `jdbc` данного модуля. Явное задание `driverClasspath` актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях.

* `oracleSystemPassword` - при использовании Oracle пароль пользователя SYSTEM.
+
Пример для PostgreSQL:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----
+
Пример для MS SQL Server:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
    connectionParams = ';instance=myinstance'
}
----
+
Пример для Oracle:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_debugWidgetSet]]
===== debugWidgetSet

`debugWidgetSet` - задача типа `CubaWidgetSetDebug`, которая запускает GWT Code Server для отладки виджетов в веб-браузере.

Пример использования:

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
----

Убедитесь, что кофигурация `runtime` модуля `web-toolkit` содержит зависимость от библиотеки Servlet API:

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
----

См. <<debug_widgets,Отладка виджетов в веб-браузере>> для получения информации о том как отлаживать код в веб-браузере.

[[build.gradle_deploy]]
===== deploy

`deploy` - задача типа `CubaDeployment`, выполняющая <<fast_deployment,быстрое развертывание>> модуля в Tomcat. Объявляется в модулях *core*, *web*, *portal*. Параметры:

* `appName` - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри `tomcat/webapps`.

* `jarNames` - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог `WEB-INF/lib` веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в `tomcat/shared/lib`.

Например:

[source, java]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
===== deployThemes

`deployThemes` - задача типа `CubaDeployThemeTask`, выполняющая сборку и развертывание определенных в проекте <<web_theme,тем>> в запущенное веб-приложение, развернутое задачей <<build.gradle_deploy,deploy>>. Изменения в темах применяются без рестарта сервера.

Например:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_deployWar]]
===== deployWar

`deployWar` - задача типа `CubaJelasticDeploy`, выполняющая развёртывание WAR-файла на сервер Jelastic.

[TIP]
====
Эту задачу можно настроить на странице *Deployment settings > Cloud* в Studio. См. контекстную помощь.
====

Пример использования:

[source, groovy]
----
task deployWar(type: CubaJelasticDeploy, dependsOn: buildWar) {
   email = '<your@email.address>'
   password = '<your password>'
   context = '<app contex>'
   environment = '<environment name or ID>'
   hostUrl = '<Host API url>'
}
----

Параметры задачи:

* `appName` - имя приложения. По умолчанию совпадает с *Modules prefix*, например, `app`.

* `email` - логин учётной записи сервера Jelastic.

* `password` - пароль учётной записи сервера Jelastic.

* `context` - контекст приложения. Значение по умолчанию: `ROOT`.

* `environment` - окружение, в которое будет развернут WAR. Можно указать как имя, так и ID окружения.

* `hostUrl` - URL-адрес API хостинга. Обычно это `app.jelastic.<host name>`.

* `srcDir` - директория, в которой находится WAR. По умолчанию это `"${project.buildDir}/distributions/war"`.

[[build.gradle_enhance]]
===== enhance

`enhance` - задача типа `CubaEnhancing`, выполняющая bytecode enhancement (weaving) классов сущностей. Объявляется в <<app_modules,модуле>> *global*.

Например:

[source, java]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - позволяет явно указать набор файлов <<persistence.xml, persistence.xml>>. Если не установлено, задача будет обрабатывать все персистентные сущности, перечисленные в файлах `*persistence.xml`, найденных в CLASSPATH.

* `metadataXml` - позволяет явно указать файл <<metadata.xml, metadata.xml>> проекта. Если не установлено, задача будет обрабатывать все неперсистентные сущности, перечисленные в файле `*metadata.xml`, найденном в дереве исходных текстов модуля.

[[build.gradle_restart]]
===== restart

`restart` - задача, выполняющая остановку, <<fast_deployment,быстрое развертывание>> и старт локального сервера Tomcat.

[[build.gradle_setupTomcat]]
===== setupTomcat

`setupTomcat` - задача типа `CubaSetupTomcat`, выполняющая установку и инициализацию локального сервера Tomcat для последующего <<fast_deployment,быстрого развертывания>> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно. Каталог установки Tomcat задается свойством `tomcat.dir` секции `cuba`. По умолчанию это подкаталог `build/tomcat` проекта.

[[build.gradle_start]]
===== start

`start` - задача типа `CubaStartTomcat`, выполняющая запуск локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_startDb]]
===== startDb

`startDb` - задача типа `CubaHsqlStart`, выполняющая запуск локального сервера HSQLDB. Параметры:

* `dbName` - имя базы данных, по умолчанию `cubadb`.

* `dbDataDir` - каталог, в котором размещена база данных, по умолчанию подкаталог `deploy/hsqldb` проекта.

* `dbPort` - порт сервера, по умолчанию 9001.

Например:

[source, java]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
----

[[build.gradle_stop]]
===== stop

`stop` - задача типа `CubaStopTomcat`, выполняющая остановку локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_stopDb]]
===== stopDb

`stopDb` - задача типа `CubaHsqlStop`, выполняющая остановку локального сервера HSQLDB. Параметры аналогичны задаче `startDb`.

[[build.gradle_tomcat]]
===== tomcat

`tomcat` – задача типа `Exec`, выполняющая запуск локального сервера Tomcat в текущем окне терминала, которое остаётся открытым даже в случае ошибок при старте. Это упрощает диагностику ошибок запуска Tomcat, например, связанных с версией Java.

[[build.gradle_updateDb]]
===== updateDb

`updateDb` - задача типа `CubaDbUpdate`, обновляющая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Аналогична задаче `createDb`, за исключением отсутствия параметров `dropDbSql` и `createDbSql`.

[[build.gradle_zipProject]]
===== zipProject

`zipProject` - задача типа `CubaZipProject`, создающая ZIP-архив проекта. Архив не будет содержать проектные файлы IDE, результаты сборки и сервер Tomcat. Однако база данных HSQL включается в архив (если присутствует в подкаталоге `build`).

Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build_task_start]]
==== Запуск задач сборки

Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:

* Если работа с проектом ведется с помощью CUBA Studio, то при выполнении пунктов меню *Build* и *Run* производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.

* С помощью исполняемого скрипта `gradlew` (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды *Build* → *Create Gradle wrapper*.

* С помощью установленного вручную Gradle версии {gradleVersion}. В этом случае используется исполняемый файл `gradle`, находящийся в подкаталоге `bin` установленного Gradle.

[TIP]
====
Рекомендуется запускать команды `gradlew` или `gradle` с ключом `--daemon`, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.

Для удаления демона из памяти используется ключ `--stop`
====

Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:

[source]
----
gradlew --daemon assemble
----

[WARNING]
====
Если ваш проект использует премиум-дополнения, и вы запускаете сборку вне Studio, необходимо передать в Gradle имя и пароль доступа к премиум-репозиторию. См. раздел <<access_to_premium_repo, выше>> для получения подробной информации.
====

Рассмотрим типичные задачи сборки в обычном порядке их использования.

* `idea`, `eclipse` - создать проектные файлы IntelliJ IDEA или Eclipse. При выполнении этой задачи из репозитория артефактов в локальный кэш Gradle загружаются зависимости вместе со своими исходными кодами.

* `cleanIdea`, `cleanEclipse` - удалить проектные файлы IntelliJ IDEA или Eclipse.

* `assemble` - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах `build` модулей.

* `clean` - удалить подкаталоги `build` всех модулей проекта.

* <<build.gradle_setupTomcat,setupTomcat>> - установить сервер *Tomcat* в путь, заданный свойством `ext.tomcatDir` скрипта `build.gradle`. 

* <<build.gradle_deploy,deploy>> - <<fast_deployment,быстрое развертывание>> приложения на сервере *Tomcat*, предварительно установленном задачей `setupTomcat`.

* <<build.gradle_createDb,createDb>> - создание базы данных приложения и выполнение соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_updateDb,updateDb>> - обновление существующей базы данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_start,start>> - запуск сервера Tomcat.

* <<build.gradle_stop,stop>> - остановка запущенного сервера Tomcat.

* <<build.gradle_restart,restart>> - последовательное выполнение задач `stop`, `deploy`, `start`. 

[[private_repo]]
==== Установка приватного репозитория артефактов

В этом разделе рассказывается, как установить приватный Maven репозиторий, чтобы использовать его для хранения артефактов платформы и других зависимостей, вместо публичного репозитория CUBA. Это рекомендуется делать в следующих случаях:

- У вас нестабильное или слабое интернет-соединение. Несмотря на то что Gradle кэширует артефакты на компьютере разработчика, время от времени все-таки необходимо подключаться к репозиторию артефактов, например, при первом запуске проекта или при переключении на новую версию платформы.
- У вас ограничен доступ к интернету из-за политики безопасности организации.
- Вы не собираетесь продлевать подписку на премиум-дополнения, но вы бы хотели продолжить разработку вашего приложения в будущем, используя загруженные версии артефактов.

Процесс установки приватного репозитория состоит из следующих шагов:

- Разверните локальный менеджер репозиториев, подключенный к интернету.
- Настройте приватный репозиторий как прокси для публичного репозитория CUBA.
- Настройте build-скрипт вашего проекта на использование приватного репозитория. Это можно сделать через Studio, либо через правку файла `build.gradle`.
- Выполните полную сборку проекта, чтобы все необходимые артефакты закэшировались в приватный репозиторий.
- Если требуется разрабатывать приложение CUBA в изолированной сети, то установите еще одну копию менеджера репозиториев в изолированной сети и скопируйте в него содержимое кэша из первого репозитория.

[[private_repo_install]]
===== Установка менеджера репозиториев

В данном руководстве будет рассмотрен пример установки менеджера репозитория Sonatype Nexus OSS в операционной системе Microsoft Windows.

- link:http://www.sonatype.org/downloads/nexus-latest-bundle.zip[Скачайте] на компьютер программу Sonatype Nexus OSS версии 2.x (протестирована версия 2.14.3)
- Распакуйте архив в папку `c:\nexus-2.14.3-02`
- Измените параметры в файле настроек `c:\nexus-2.14.3-02\conf\nexus.properties`
+
** Вы можете указать сетевой порт, по умолчанию установлен 8081
** Настройте путь к папке с данными кэша:
+
--
замените
--
+
[source]
----
nexus-work=${bundleBasedir}/../sonatype-work/nexus
----
+
--
на
--
+
[source]
----
nexus-work=${bundleBasedir}/nexus/sonatype-work/content
----

- Перейдите в папку `c:\nexus-2.14.3-02\bin`
-  Чтобы иметь возможность запускать *nexus* как службу, установите wrapper (запустите команду с правами Администратора):
+
[source]
----
nexus.bat install
----

- Запустите службу *nexus*.
- Откройте в браузере адрес `++http://localhost:8081/nexus++` и войдите, используя данные по умолчанию: логин `admin` и пароль `admin123`.

[[private_repo_configure]]
===== Настройка прокси-репозитория

Щелкните на ссылку *Repositories* в панели слева.

На открывшейся странице нажмите кнопку *Add*, затем выберите пункт *Proxy Repository*. Будет создан новый репозиторий. Заполните обязательные поля на вкладке *Configuration*:

- *Repository ID*: `cuba-work`
- *Repository Name*: `cuba-work`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/work++`
- Отключите опцию *Auto Blocking Enabled*: `false`
- Включите опцию *Authentication*, задайте имя пользователя *Username*: `cuba`, пароль *Password*: `cuba123`
- Нажмите кнопку *Save*.

Создайте группу репозиториев. В Nexus нажмите кнопку *Add*, затем выберите *Repository Group* и проделайте следующие шаги на вкладке *Configuration*:

- Введите *Group ID*: `cuba-group`
- Введите *Group Name*: `cuba-group`
- Выберите *Provider*: `Maven2`
- Перенесите репозиторий *cuba-work* из *Available Repositories* в *Ordered Group Repositories*
- Нажмите кнопку *Save*.

Если у вас есть подписка на Премиум-дополнения, то создайте еще один репозиторий со следующими настройками:

- *Repository ID*: `cuba-premium`
- *Repository Name*: `cuba-premium`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/premium++`
- Отключите опцию *Auto Blocking Enabled*: `false`
- Включите опцию *Authentication*, используйте первую часть лицензионного ключа (до дефиса) в поле *Username* и вторую часть ключа (после дефиса) в поле *Password*
- Нажмите кнопку *Save*
- Нажмите кнопку *Refresh*
- Щелкните по репозиторию *cuba-group*
- На вкладке *Configuration* добавьте репозиторий *cuba-premium* в группу *cuba-group* следом за репозиторием *cuba-work*
- Нажмите кнопку *Save*.

[[private_repo_usage]]
===== Использование приватного репозитория

Теперь приватный репозиторий готов к работе. Найдите URL группы *cuba-group* в верхней части экрана, например:
----
http://localhost:8081/nexus/content/groups/cuba-group
----

- Если вы создаете новый проект, нажмите кнопку в поле *Repository* окна *New project*.
- Для существующего проекта, откройте на редактирование *Project properties* и нажмите кнопку в поле *Repository*.
- В открывшемся диалоге, нажмите *Add*, введите URL репозитория и имя/пароль доступа к нему: `admin / admin123`.
- Выберите новый репозиторий и нажмите *OK* для использования его в проекте.
- Если вы создаете новый проект, нажмите *OK* в окне *New project*.
- Если вы работаете с существующим проектом, сохраните изменения на странице *Project properties* и соберите проект.

Во время первой сборки проекта ваш новый репозиторий скачает артефакты и сохранит их в кэше для дальнейшего использования. Вы можете найти эти файлы в папке `c:\nexus-2.14.3-02\sonatype-work`.

[[private_repo_in_isolated_network]]
===== Репозиторий в изолированной сети

Если вам требуется разработка приложения CUBA в сети без доступа к Интернет, то проделайте следующие шаги:

- Разверните копию менеджера репозиториев в указанной сети.
- Скопируйте содержимое <<private_repo_configure,репозитория>> из открытой сети в изолированную. Если вы следовали инструкциям выше, то данные находятся в папке
+
----
c:\nexus-2.14.3-02\sonatype-work
----
+
- Перезапустите службу *nexus*.

Если вам нужно добавить артефакты от новой платформы в изолированный репозиторий, вам потребуется вернуться в окружение, подключенное к интернету, затем выполнить сборку проекта через онлайн-репозиторий и скопировать содержимое кэша репозитория в изолированное окружение.

[[private_repo_studio_in_isolated_network]]
===== CUBA Studio в изолированной сети

Сейчас вы можете открыть CUBA Studio в изолированной сети:

- Скачайте https://services.gradle.org/distributions/[Gradle] (требуется версия {gradleVersion}) и установите на компьютер разработчика.
- Откройте окно CUBA Studio Server.
- Нажмите кнопку *Advanced* и задайте путь к папке, где установлен Gradle.
- Следуйте инструкции <<private_repo_usage,выше>> для конфигурации вашего проекта.

[[project_creation]]
=== Создание проекта

Рекомендуемый способ создания нового проекта - использование *CUBA Studio*. Пример рассмотрен в главе <<qs_create_project,Быстрый старт>> данного руководства.

После создания проекта вы можете продолжить разрабатывать его в Studio, либо создать файлы проекта для *IntelliJ IDEA* или *Eclipse* и открыть проект в IDE.

[[logging]]
=== Логирование

Для ведения логов в платформе используется фреймворк *Logback*.

Для вывода в лог используйте *SLF4J* API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
---- 

Настройка логирования для <<app_tiers,блоков>> Middleware, Web Client и Web Portal производится на уровне сервера приложения - в варианте <<fast_deployment,быстрого развертывания>> это Tomcat. Блок Desktop Client имеет самостоятельную настройку логирования.

[[logging_setup_tomcat]]
==== Настройка логирования в Tomcat

В данном разделе рассматривается настройка логгирования на этапе разработки приложения.

При выполнении задачи Gradle <<build.gradle_setupTomcat,setupTomcat>> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге `tomcat/bin` создаются файлы `setenv.bat` и `setenv.sh`, а в подкаталоге `tomcat/conf` файл `logback.xml`.

Файлы `setenv.*` в переменной `CATALINA_OPTS` в числе прочего устанавливают параметры загрузки конфигурационного файла `logback.xml`.

Файл `logback.xml` определяет конфигурацию логирования. Рассмотрим структуру этого файла.

* Элементы `appender` задают "устройства вывода" логов. Основными аппендерами являются `FILE` и `CONSOLE`. В параметре `level` элемента `filter` можно задать порог уровня сообщения. По умолчанию порог для файла - `DEBUG`, для консоли - `INFO`. Это означает, что в файл выводятся сообщения с уровнями `ERROR`, `WARN`, `INFO`, `DEBUG`, а в консоль - с уровнями `ERROR`, `WARN` и `INFO`.
+
Для файлового аппендера в параметре `file` задается путь к файлу лога. По умолчанию это файл `tomcat/logs/app.log`.

* Элементы `logger` задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена логгеров иерархические, то есть например настройки для логгера `com.company.sample` влияют на логгеры `com.company.sample.core.CustomerServiceBean`, `com.company.sample.web.CustomerBrowse`, если для них явно не заданы собственные настройки.
+
Минимальный уровень указывается в атрибуте `level`. Например, если для логгера задан приоритет `INFO`, то сообщения с уровнями `DEBUG` и `TRACE` выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.

Оперативно изменять уровни для логгеров и пороги аппендеров для работающего сервера можно с помощью экрана *Administration > Server Log*, доступного в веб-клиенте. Сделанные настройки логирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <<log_dir,каталога журналов>> сервера `tomcat/logs`.

Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:

* _приложение_ - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (Middleware, Web Client), так как они выводятся в один файл.

* _пользователь_ - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.

Например, следующее сообщение в логе выведено кодом блока Middleware (`app-core`), работающим от имени пользователя `admin`:

[source, plain]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Настройка логирования в десктоп-клиенте

Для десктоп клиента файл `logback.xml` должен находиться в каталоге исходников модуля *desktop* проекта. При сборке приложения он упаковывается в соответствующий JAR файл и доступен в CLASSPATH.

Для настройки логирования в своем проекте выполните следующее:

* Создайте в каталоге `src` модуля *desktop* новый файл, например, `sample-logback.xml`, и скопируйте в него содержимое файла `cuba-logback.xml`. Файл `cuba-logback.xml` находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE.

* Установите путь к файлу лога в параметре `file` аппендера `FILE`.

* Добавьте настройки для логгеров вашего проекта.

* В классе-наследнике `com.haulmont.cuba.desktop.App` вашего проекта, например `SampleApp`, переопределите метод `getDefaultLogConfig()` и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства <<logback.configurationFile,logback.configurationFile>>.

[[debuging]]
=== Отладка

В данном разделе содержится информация об использовании пошаговой отладки CUBA-приложений.

[[debug_setup]]
==== Подключение отладчика

Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки

`gradle start`

либо запуском командного файла `++bin/debug.*++` установленного *Tomcat*.

После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле `bin/setenv.*` в переменной `++JPDA_OPTS++`.

Для пошаговой отладки в *Intellij IDEA* необходимо в проекте приложения создать новый элемент *Run/Debug Configuration* типа *Remote*, и в его поле *Port* указать 8787.

[[debug_version]]
==== Простая отладка в веб-браузере

Самый простой способ отладки ошибок на клиентской стороне без использования *GWT Super Dev Mode* - это использовать конфигурацию отладки внутри модуля *web*.

. Добавьте новую конфигурацию внутри блока `webModule`:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_1.groovy[]
----

. Добавьте зависимость для отладчика в блок `dependencies` блока `webModule`:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_2.groovy[]
----
+
Если у вас подключено премиум-дополнение *charts*, используйте зависимость `debug("com.haulmont.charts:charts-web-toolkit:$cubaVersion:debug@zip")`.

. Добавьте задачу `deploy.doLast` в блок конфигурации `webModule`:
+
[source, groovy]
----
include::{sourcesdir}/development/debug_3.groovy[]
----

Сценарии отладки будут развёрнуты в папке `$cuba.tomcat.dir/webapps/app/VAADIN/widgetsets/com.haulmont.cuba.web.toolkit.ui.WidgetSet`.

[[debug_widgets]]
==== Отладка виджетов в веб-браузере

Для отладки виджетов на стороне браузера можно использовать *GWT Super Dev Mode*.

. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`.

. Разверните приложение и запустите Tomcat.

. Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.

. Откройте страницу `++http://localhost:8080/app?debug&superdevmode++` в браузере Chrome и подождите, пока widgetset будет построен первый раз.

. Откройте консоль отладки браузера: 
+
image::debugWidgetSet_chrome_console.png[align="center"]

. После изменения Java-кода в модуле `web-toolkit` обновляйте страницу в браузере. Widgetset будет инкрементально перестраиваться примерно за 8-10 секунд.

[[testing]]
=== Тестирование

[[unit_tests]]
==== Модульные тесты

Модульные тесты (unit tests) можно создавать и выполнять и на <<app_tiers,уровне>> *Middleware*, и на клиентском уровне. Для этого платформа включает в себя фреймворки link:$$http://junit.org$$[JUnit] и link:$$http://jmockit.github.io/$$[JMockit].

Допустим, имеется следующий контроллер экрана:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

Тогда можно написать следующий тест, проверяющий работу метода `init()`:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Интеграционные тесты Middleware

На уровне Middleware можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере Spring с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри Middleware - от сервисов до ORM.

Для того, чтобы выполнять тесты из IDE, создайте каталог `test` в модуле *core* рядом с `src`. После этого пересоздайте проектные файлы IDE.

Платформа содержит класс `TestContainer`, который может быть использован в качестве базового для тестовых контейнеров приложения. Создайте наследника этого класса в каталоге `test` модуля *core* и в его конструкторе переопределите параметры загрузки <<app_components, компонентов>> и <<app_properties_files, свойств приложения>>, а также параметры подключения к тестовой БД. Например:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

Пример собственного файлв `test-app.properties`:

[source, java]
----
include::{sourcesdir}/development/testing_11.java[]
----

В качестве базы данных рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей <<build.gradle_createDb, задачей>> в `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

Тестовый контейнер используется в классах тестов в качестве JUnit rule, указанного с помощью аннотации `@ClassRule`:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

В данном примере тестовый контейнер инициализируется один раз для всех тестовых методов класса, и уничтожается после того, как все они выполнены.

Так как запуск контейнера занимает некоторое время, имеет смысл инициализировать контейнер один раз для тестов из нескольких (или всех) классов. Для этого создайте общий синглтон-экземпляр тестового контейнера, например:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

И используйте его в тестовых классах:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

Полезные методы тестового контейнера::
+
--
Класс `TestContainer` содержит следующие методы, которые можно использовать в коде тестов (см. пример `CustomerLoadTest` выше):

* `persistence()` - возвращает ссылку на интерфейс <<persistence,Persistence>>.

* `metadata()` - возвращает ссылку на интерфейс <<metadata,Metadata>>.

* `deleteRecord()` - этот набор перегруженных методов предназначен для использования в `@After` методах для удаления тестовых объектов из БД.
--

Логирование::
+
--
Класс `TestContainer` настраивает логирование в соответствие с файлом `test-logback.xml`, предоставляемым платформой. Данный файл содержится в артефакте `cuba-core-tests`.

Для того, чтобы настроить уровни логирования в своих тестах, необходимо выполнить следующее:

* Скопируйте файл `test-logback.xml` из артефакта платформы в корень каталога `test` модуля `core` проекта, например как `my-test-logback.xml`.

* Сконфигурируйте параметры логирования в `my-test-logback.xml`.

* Добавьте блок статической инициализации в класс тестового контейнера проекта и укажите местоположение файла конфигурации Logback в системном свойстве `logback.configurationFile`:
+
[source, java]
----
include::{sourcesdir}/development/testing_9.java[]
----
--

Дополнительные хранилища::
+
--
Если в вашем проекте используются <<data_store,дополнительные хранилища>>, необходимо создать соответствующие источники данных JDBC в тестовом контейнере. Например, если у вас есть хранилище `mydb`, являющееся базой данных PostgreSQL, добавьте следующий метод в класс тестового контейнера:

[source, java]
----
include::{sourcesdir}/development/testing_10.java[]
----
--


[[integration_tests_client]]
==== Интеграционные тесты клиентского уровня

Интеграционные тесты на клиентском уровне реализуются с применением фреймворка link:$$http://jmockit.github.io/$$[JMockit]. С его помощью тест изолируется от *Middleware*, а также создаются необходимые объекты инфраструктуры.

Класс клиентского интеграционного теста должен быть унаследован от `CubaClientTestCase`. В методе `@Before` необходимо вызвать унаследованные методы `addEntityPackage()`, `setViewConfig()` и затем `setupInfrastructure()` для создания объектов <<metadata,Metadata>> и <<configuration,Configuration>> и развертывания метаданных по выбранным сущностям. Далее в методе `@Before` можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции `Expectations` или `NonStrictExpectations`.

Пример инициализирующего метода `@Before` одного из тестов платформы:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

[[hot_deploy]]
=== Hot Deploy

Платформа CUBA поддерживает технологию Hot Deploy, которая позволяет мгновенно отображать сделанные в проекте изменения в работающем приложении без необходимости перезапускать сервер. Принцип работы Hot deploy заключается во временном копировании изменённых ресурсов и исходных файлов Java проекта в <<conf_dir,конфигурационный каталог>> приложения, откуда они загружаются и компилируются работающим приложением.

Как это работает::
+
--
Когда в каком-то файле исходного кода производятся изменения, Studio копирует этот файл в конфигурационный каталог веб-приложения (`tomcat/conf/app` или `tomcat/conf/app-core`). Ресурсы в конфигурационном каталоге имеют приоритет над ресурсами в JAR-файлах приложения, поэтому работающее приложение загрузит именно эти ресурсы, когда они понадобятся. Если загружается файл исходного кода на Java, то приложение компилирует его на лету и загружает результирующий класс.

Кроме того, Studio посылает приложению специальные сигналы для того чтобы заставить его очистить кэши и перезагрузить измененные ресурсы. Это кэш локализованных сообщений и конфигурации представлений, зарегистрированных экранов и меню.

При перезагрузке сервера приложения все файлы в конфигурационном каталоге удаляются, и JAR-файлы содержат последние версии вашего кода.
--

Какие изменения применяются через hot deploy::
+
--
* <<screen_xml,XML-дескрипторы>> и <<screen_controller,контроллеры>> экранов (включая статические методы), расположенные в <<app_modules,модулях>> *web* и *gui*.
* Реализации <<services,сервисов>> среднего слоя, расположенные в модуле *core*.

Изменения в прочих классах и бинах UI и среднего слоя, включая их статические методы, могут применяться на лету только тогда, когда изменяется ещё хотя бы один файл экрана или реализации сервиса, который их используют.

Причина такого поведения в том, что перезагрузка классов вызывается только по сигналу: для контроллера экрана это переоткрытие этого экрана пользователем, а для сервисов Studio генерирует особый файл-триггер, который будет распознан сервером и использован для перезагрузки конкретного класса сервиса и всех его зависимостей.
--

Какие изменения не применяются через hot deploy::
+
--
* Любые классы в модуле *global*, включая интерфейсы сервисов среднего слоя, <<base_entity_classes,сущности>>, <<entity_listeners,entity listeners>> и т.д.
--

Использование hot deploy в Studio::
+
--
Настройки Hot deploy можно изменить в Studio на странице *Help > Settings*:

* Диалог *Hot deploy settings* позволяет конфигурировать отображение между каталогами исходного кода и каталогами Tomcat.

* Флажок *Instant hot deploy* позволяет отключить автоматический hot deploy для текущего проекта.

Если мгновенный hot deploy отключен, применение изменений можно вызвать вручную командой меню *Run > Hot deploy conf*.
--
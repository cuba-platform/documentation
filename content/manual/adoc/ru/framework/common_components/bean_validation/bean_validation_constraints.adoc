:sourcesdir: ../../../../../source

[[bean_validation_constraints]]
===== Задание ограничений

Ограничения bean validation задаются с помощью аннотаций пакета `javax.validation.constraints` или собственных аннотаций. Аннотации указываются на декларации класса сущности или POJO, на поле или getter-методе, а также на методе <<services,сервиса>> middleware.

Пример использования стандартных аннотаций валидации на полях сущности:

[source, java]
----
include::{sourcesdir}/common/bean_validation_1.java[]
----

Пример использования собственной аннотации уровня класса (см. <<bean_validation_custom_constraints,ниже>>):

[source, java]
----
include::{sourcesdir}/common/bean_validation_2.java[]
----

Пример валидации параметров и возвращаемого значения метода сервиса:

[source, java]
----
include::{sourcesdir}/common/bean_validation_3.java[]
----

Аннотация `@Valid` может быть использована для каскадной валидации параметров метода. В примере выше все ограничения, заданные для объекта `Task`, также будут валидированы.

[[bean_validation_constraint_groups]]
Группы ограничений::
+
--
Группы ограничений позволяют применять подмножество всех заданных ограничений в зависисмости от логики приложения. Например, вы можете заставить пользователя ввести значение некоторого атрибута сущности в UI, и а то же время иметь возможность установить данный атрибут в null в некотором внутреннем механизме. Для этого необходимо указать атрибут `groups` в аннотации ограничения, и оно будет действовать только когда эта же группа передается в механизм валидации.

Платформа передает в механизм валидации следующие группы ограничений:

* `RestApiChecks` - при валидации в <<rest_api_v2,REST API>>.
* `ServiceParametersChecks` - при валидации параметров сервисов.
* `ServiceResultChecks` - при валидации возвращаемых значений сервисов.
* `UiComponentChecks` - при валидации отдельных полей в UI.
* `UiCrossFieldChecks` - при валидации ограничений уровня класса на коммите экрана редактора сущности.
* `javax.validation.groups.Default` - данная группа передается во всех случаях кроме коммита экрана редактора сущности.
--

[[bean_validation_messages]]
Сообщения валидации::
+
--
Ограничения могут иметь сообщения для отображения пользователям.

Сообщения могут быть указаны непосредственно в аннотациях валидации, например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_4.java[]
----

Сообщения можно также поместить в <<message_packs,пакет локализованных сообщений>> и использовать следующий формат указания сообщения в аннотации: `{msg://message_pack/message_key}` или, в сокращённом виде, `{msg://message_key}` (только для сущностей). Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_5.java[]
----

или, если ограничение задано для сущности и сообщение находится в пакете сообщений данной сущности:

[source, java]
----
include::{sourcesdir}/common/bean_validation_19.java[]
----

Сообщения могут содержать параметры и выражения. Параметры заключаются в фигурные скобки `{}` и представляют собой либо указатели на локализованные сообщения (см. выше) или параметры аннотации, например `{min}`, `{max}`, `{value}`. Выражения заключаются в фигурные скобки со знаком доллара `${}` и могут включать валидируемое значение в виде переменной `validatedValue`, параметры аннотации типа `value` или `min`, и выражения JSR-341 (EL 3.0). Например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_6.java[]
----

Значения локализованных сообщений также могут содержать параметры и выражения.
--

[[bean_validation_custom_constraints]]
Собственные ограничения::
+
--
В проекте можно создать собственные ограничения с программной или декларативной валидацией.

Для создания ограничения с программной валидацией выполняет следующее:

. Создайте аннотацию в модуле *global* проекта и добавьте ей аннотацию `@Constraint`. Ваша аннотация должна содержать атрибуты `message`, `groups` и `payload`:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_7.java[]
----

. Создайте класс валидатора в модуле *global* проекта:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_8.java[]
----

. Используйте аннотацию:
+
[source, java]
----
include::{sourcesdir}/common/bean_validation_9.java[]
----

Собственные аннотации могут также быть созданы как композиции имеющихся, например:

[source, java]
----
include::{sourcesdir}/common/bean_validation_10.java[]
----

При использовании композитных ограничений результирующий набор нарушений `ConstraintViolation` будет содержать отдельные записи для каждого включенного ограничения. Для того, чтобы получить одну запись нарушения, добавьте `@ReportAsSingleViolation` классу вашей аннотации.
--

[[bean_validation_related_objects]]
Валидация связанных объектов::
+
--
Для каскадной валидации связанных объектов на ссылочные поля необходимо добавить аннотацию `@Valid`:

[source, java]
----
include::{sourcesdir}/common/bean_validation_11.java[]
----

В примере выше, при валидации экземпляра `Cart` список продуктов будет проверен на наличие хотя-бы одной записи, и все экземпляры `Product` в списке будут также провалидированы.
--

[[bean_validation_cuba_annotations]]
Аннотации валидации, заданные в CUBA::
+
--
Кроме стандартных аннотаций из пакета `javax.validation.constraints` можно использовать следующую аннотацию, определенную в платформе:

* `@RequiredView` - может быть добавлена на методы сервисов для того, чтобы во время выполнения убедиться, что в сущностях загружены все атрибуты, заданные в требуемых <<views,представлениях>>. Если аннотация задана на методе, то проверяется результат метода. Если аннотация задана на параметре, проверяется этот параметр. Если параметр или результат являются коллекцией, то проверяются все элементы этой коллекции. Пример использования:

[source, java]
----
include::{sourcesdir}/common/bean_validation_18.java[]
----
--


:sourcesdir: ../../../../source

[[composite_components]]
==== Композитные компоненты

++++
<div class="manual-since-container">
    <a href="http://files.cuba-platform.com/cuba/release-notes/7.1/" class="since-btn" target="_blank">
        <span class="since-btn-caption">Since</span><span class="since-btn-version">7.1</span>
    </a>
</div>
++++

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=composite-component" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Композитный компонент – это компонент, состоящий из других компонентов. Так же как фрагменты экранов, композитные компоненты позволяют переиспользовать некоторую компоновку и логику презентации. Композитные компоненты рекомендуется использовать в следующих случаях:

* Функциональность компонента может быть реализована комбинацией существующих компонентов универсального пользовательского интерфейса. Если вам требуются какие-либо нестандартные возможности, создавайте <<own_components, собственный компонент>> путем оборачивания компонента Vaadin или библиотеки JavaScript, или используйте <<jsComponent>>.
* Компонент относительно прост и не загружает/сохраняет данные самостоятельно. В противном случае рассмотрите возможность создания <<using_screen_fragments,фрагмента экранов>>.

Класс композитного компонента должен расширять базовый класс `CompositeComponent`. Композитный компонент должен иметь единственный компонент в качестве корня внутреннего дерева компонентов. Корневой компонент можно получить методом `CompositeComponent.getComposition()`.

Внутренние компоненты удобно определять декларативно в XML. В этом случае класс компонента должен иметь аннотацию `@CompositeDescriptor`, задающую путь к дескриптору компоновки. Если значение аннотации не начинается с символа `/`, файл дескриптора загружается из файла, находящегося в том же пакете, что и класс компонента.

[TIP]
====
Обратите внимание, что идентификаторы внутренних компонентов должны быть уникальны в экране во избежание противоречий в слушателях и при инжектировании. Используйте идентификаторы с префиксами, например `myCompositeComponent_currency`.
====

Альтернативой является создание дерева внутренних компонентов программно, в обработчике события `CreateEvent`.

`CreateEvent` посылается фреймворком, когда он заканчивает инициализацию компонента. В этот момент, если компонент использует XML-дескриптор, он загружен, и метод `getComposition()` возвращает корневой внутренний компонент. Данное событие можно использовать как для дополнительной инициализации компонента, так и для создания внутренних компонентов без XML.

Ниже описывается пошаговое создание компонента Stepper, предназначенного для редактирования целочисленного значения в поле ввода и нажатием на кнопки вверх/вниз рядом с полем.

. <<composite_components_xml,Дескриптор компоновки компонента>>

. <<composite_components_class,Класс имплементации компонента>>

. <<composite_components_loader,Загрузчик компонента>>

. <<composite_components_registration,Регистрация компонента>>

. <<composite_components_xsd,XSD компонента>>

. <<composite_components_usage,Использование компонента>>

. <<composite_components_style,Собственный стиль>>

Далее предполагается, что проект имеет базовый пакет `com/company/demo`.

[[composite_components_xml]]
Дескриптор компоновки компонента::
+
--
Создайте XML-дескриптор компоновки в файле `com/company/demo/web/components/stepper/stepper-component.xml` модуля `web`:

[source, xml]
----
include::{sourcesdir}/gui/composite/composite_xml.xml[]
----

<1> - XSD определяет возможное содержимое дескриптора
<2> - единственный корневой компонент
<3> - любое количество вложенных компонентов
--

[[composite_components_class]]
Класс имплементации компонента::
+
--
Создайте класс имплементации компонента в том же пакете:

[source, java]
----
include::{sourcesdir}/gui/composite/composite_class.java[]
----

<1> - аннотация `@CompositeDescriptor` указывает путь к дескриптору компоновки компонента, который находится в том же пакете что и класс.
<2> - класс компонента наследуется от `CompositeComponent`, параметризованного типом корневого компонента.
<3> - компонент реализует интерфейс `Field<Integer>`, так как он предназначен для отображения и редактирования целочисленных значений.
<4> - набор интерфейсов с дефолтными методами для реализации стандартной функциональности Generic UI компонента.
<5> - имя компонента, используемое для регистрации в файле `ui-component.xml` (см. ниже).
<6> - поля, содержащие ссылки на внутренние компоненты.
<7> - свойство компонента, задающее значение изменения при нажатии на кнопки вверх/вниз. Свойство имеет публичные getter/setter методы и может быть назначено в XML экрана.
<8> - инициализация компонента производится в слушателе события `CreateEvent`.
--

[[composite_components_loader]]
Загрузчик компонента::
+
--
Создайте загрузчик компонента для того, чтобы компонент можно было использовать в XML-дескрипторах экранов:

[source, java]
----
include::{sourcesdir}/gui/composite/composite_loader.java[]
----

<1> - загрузчик должен наследоваться от класса `AbstractComponentLoader`, параметризованного типом компонента. В нашем случае, так как компонент реализует интерфейс `Field`, необходимо воспользоваться более специфичным базовым классом `AbstractFieldLoader`.
<2> - создание компонента по его имени.
<3> - загрузка свойства `step` из XML, если оно указано.
--

[[composite_components_registration]]
Регистрация компонента::
+
--
Для регистрации компонента и его загрузчика во фреймворке, создайте файл `com/company/demo/ui-component.xml` в модуле `web`:

[source, xml]
----
include::{sourcesdir}/gui/composite/composite_registration.xml[]
----

Добавьте следующее свойство в `com/company/demo/web-app.properties`:

[source, properties]
----
cuba.web.componentsConfig = +com/company/demo/ui-component.xml
----

Теперь фреймворк сможет распознать новый компонент в XML-дескрипторах экранов приложения.

Если приложение, в котором определен композитный компонент, оформлено в виде <<app_components,компонента приложения>>  - требуется повторно создать его дескриптор.
--

[[composite_components_xsd]]
XSD компонента::
+
--
XSD требуется для использования компонента в XML-дескрипторах экранов. Определите ее в файле `com/company/demo/ui-component.xsd` модуля `web`:

[source, xml]
----
include::{sourcesdir}/gui/composite/composite_xsd.xsd[]
----

<1> - наследование всех базовых свойств поля.
<2> - определение атрибута для свойства `step` компонента.
--

[[composite_components_usage]]
Использование компонента::
+
Пример использования созданного компонента в экране приложения:

--
[source, xml]
----
include::{sourcesdir}/gui/composite/composite_usage.xml[]
----

<1> - namespace ссылается на XSD компонента.
<2> - композитный компонент, соединенный с некоторым атрибутом `limit` сущности.
--

[[composite_components_style]]
Собственный стиль::
+
--
Теперь давайте добавим собственные стили для улучшения визуального представления компонента.

Сначала измените корневой компонент на <<gui_CssLayout,CssLayout>>  и назначьте стили внутренним компонентам. Кроме стилей, определенных в проекте (см. ниже), здесь используются следующие предопределенные стили: {sampler_url}/open?screen=styles-containers[v-component-group], {sampler_url}/open?screen=styles-button[icon-only].

[source, xml]
----
include::{sourcesdir}/gui/composite/composite_xml_cssLayout.xml[]
----

Измените класс компонента соответственно:

[source, java]
----
include::{sourcesdir}/gui/composite/composite_class_cssLayout.java[]
----

Сгенерируйте расширение темы в проекте (см. {studio_man_url}/#generic_ui_themes[здесь] как это сделать в Studio) и добавьте следующий код в файл `modules/web/themes/hover/com.company.demo/hover-ext.scss`:

[source, css]
----
include::{sourcesdir}/gui/composite/composite_class_css.css[]
----

Перезапустите сервер приложения и откройте экран с компонентом. Форма, содержащая наш композитный компонент Stepper, должна выглядеть так:

image::gui_composite/stepper_final.png[align="center"]
--

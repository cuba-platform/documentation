:sourcesdir: ../../../../source

[[entityChangedEvent]]
==== EntityChangedEvent

`EntityChangedEvent` - это `ApplicationEvent`, который посылается фреймворком на среднем слое, когда некоторый экземпляр сущности сохраняется в базу данных. Данное событие может быть обработано как внутри текущей транзакции, так и после ее завершения (при использовании https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-event[@TransactionalEventListener]).

[TIP]
=====
Событие посылается только если на сущности есть аннотация `@PublishEntityChangedEvents`. Не забудьте добавить эту аннотацию классам сущностей, для которых вы хотите обрабатывать `EntityChangedEvent`.
=====

Объект `EntityChangedEvent` содержит не сам измененный экземпляр сущности, а только его id. Кроме того, метод `getOldValue(attributeName)` возвращает идентификаторы ссылок вместо самих объектов. Поэтому при необходимости, разработчик должен загрузить требуемые сущности с указанием требуемого представления и других параметров.

Ниже приведен пример обработки `EntityChangedEvent` для сущности `Customer` в текущей транзакции и после ее завершения:

[source,java]
----
include::{sourcesdir}/middleware/entityChangedEvent_usage_1.java[]
----
<1> - данный обработчик вызывается внутри текущей транзакции. Для этого можно использовать либо аннотацию `@EventListener`, либо `@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)`.
<2> - id измененной сущности.
<3> - тип изменения: `CREATED`, `UPDATED` or `DELETED`.
<4> - можно проверить, изменился ли определенный атрибут.
<5> - можно получить старое значение измененного атрибута.
<6> - данный обработчик вызывается после коммита транзакции.
<7> - после коммита событие содержит те же значения что и внутри транзакции.

Если обработчик вызывается внутри транзакции, ее можно откатить путем выбрасывания исключения. При этом в БД никакие изменения не сохранятся. Если вы не хотите, чтобы пользователь получил какое-либо оповещение, используйте `SilentException`.

При обработке `EntityChangedEvent` внутри транзакции, используйте <<transactionalDataManager,TransactionalDataManager>> для загрузки текущего состояния измененной сущности из базы данных. В обработчике, вызываемом после коммита транзакции, можно использовать `DataManager`, который создаст новую транзакцию для загрузки данных.

Ниже приведен пример использования `EntityChangedEvent` для изменения связанных сущностей.

Предположим, имеются сущности `Order`, `OrderLine` и `Product`, как в примере https://www.cuba-platform.com/learn/quickstart/studio/part3/#chapter0[Quick Start Sales Application], но сущность `Product` дополнительно имеет булевский атрибут `special`, а у сущности `Order` есть атрибут `numberOfSpecialProducts`, который должен быть пересчитан при создании и удалении экземпляров `OrderLine` в составе `Order`.

Создадим следующий класс с методом, аннотированным `@EventListener`, который будет вызываться при изменении сущностей `OrderLine` перед коммитом транзакции:

[source,java]
----
include::{sourcesdir}/middleware/entityChangedEvent_usage_2.java[]
----
<1> - если экземпляр `OrderLine` не удален, можно загрузить его из БД по идентификатору.
<2> - метод `event.getEntityId()` возвращает id измененного экземпляра `OrderLine`.
<3> - используем представление, которое содержит `OrderLine` вместе с `Order`, которому он принадлежит. Представление должно содержать атрибут `Order.numberOfSpecialProducts`, так как его необходимо будет обновить.
<4> - получаем `Order` из загруженного `OrderLine`.
<5> - если экземпляр `OrderLine` был только что удален, его нельзя загрузить из БД, но метод `event.getChanges()` возвращает все атрибуты удаленной сущности, включая идентификаторы связанных сущностей. Поэтому можно загрузить связанный `Order` по его id.
<6> - загружаем все экземпляры `OrderLine` для данного `Order`, отфильтровываем по `Product.special` и считаем их. Представление должно содержать `OrderLine` вместе со связанным `Product`.
<7> - сохраняем `Order` после изменения его атрибута.
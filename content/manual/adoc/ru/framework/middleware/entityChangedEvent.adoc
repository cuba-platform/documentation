:sourcesdir: ../../../../source

[[entityChangedEvent]]
==== EntityChangedEvent

[TIP]
====
Руководство https://www.cuba-platform.com/guides/decouple-business-logic-with-app-events#entity_changes_through_entitychangedevent[Decouple Business Logic with Application Events] демонстрирует использование `EntityChangedEvent`.
====

`EntityChangedEvent` - это `ApplicationEvent`, который посылается фреймворком на среднем слое, когда некоторый экземпляр сущности сохраняется в базу данных. Данное событие может быть обработано как внутри текущей транзакции (используя `@EventListener`), так и после ее завершения (при использовании https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-event[@TransactionalEventListener]).

[TIP]
=====
Событие посылается только если на сущности есть аннотация `@PublishEntityChangedEvents`. Не забудьте добавить эту аннотацию классам сущностей, для которых вы хотите обрабатывать `EntityChangedEvent`.
=====

Объект `EntityChangedEvent` содержит не сам измененный экземпляр сущности, а только его id. Кроме того, метод `getOldValue(attributeName)` возвращает идентификаторы ссылок вместо самих объектов. Поэтому при необходимости, разработчик должен загрузить требуемые сущности с указанием требуемого представления и других параметров.

Ниже приведен пример обработки `EntityChangedEvent` для сущности `Customer` в текущей транзакции и после ее завершения:

[source,java]
----
include::{sourcesdir}/middleware/entityChangedEvent_usage_1.java[]
----
<1> - данный обработчик вызывается внутри текущей транзакции.
<2> - id измененной сущности.
<3> - тип изменения: `CREATED`, `UPDATED` or `DELETED`.
<4> - можно проверить, изменился ли определенный атрибут.
<5> - можно получить старое значение измененного атрибута.
<6> - данный обработчик вызывается после коммита транзакции.
<7> - после коммита событие содержит те же значения что и внутри транзакции.

Если обработчик вызывается внутри транзакции, ее можно откатить путем выбрасывания исключения. При этом в БД никакие изменения не сохранятся. Если вы не хотите, чтобы пользователь получил какое-либо оповещение, используйте `SilentException`.

Если "after commit" обработчик выбрасывает исключение, оно будет залоггировано, но не передано клиенту (т.е. пользователь не получит сообщения об ошибке в UI).

[WARNING]
====
При обработке `EntityChangedEvent` внутри транзакции (`@EventListener` или `@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT`), обязательно используйте <<transactionalDataManager,TransactionalDataManager>> для загрузки текущего состояния измененной сущности из базы данных. Если использовать <<dataManager,DataManager>>, то будет создана новая транзакция, что может повлечь дедлок в базе данных при попытке чтения незакоммиченных данных.

В обработчике, вызываемом после коммита транзакции (`TransactionPhase.AFTER_COMMIT`), используйте `DataManager`, или создайте новую транзакцию явно перед использованием `TransactionalDataManager`.
====

Ниже приведен пример использования `EntityChangedEvent` для изменения связанных сущностей.

Предположим, имеются сущности `Order`, `OrderLine` и `Product`, как в приложении https://github.com/cuba-platform/sample-sales-cuba7[Sales], но сущность `Product` дополнительно имеет булевский атрибут `special`, а у сущности `Order` есть атрибут `numberOfSpecialProducts`, который должен быть пересчитан при создании и удалении экземпляров `OrderLine` в составе `Order`.

Создадим следующий класс с методом, аннотированным `@EventListener`, который будет вызываться при изменении сущностей `OrderLine` перед коммитом транзакции:

[source,java]
----
include::{sourcesdir}/middleware/entityChangedEvent_usage_2.java[]
----
<1> - если экземпляр `OrderLine` не удален, можно загрузить его из БД по идентификатору.
<2> - метод `event.getEntityId()` возвращает id измененного экземпляра `OrderLine`.
<3> - используем представление, которое содержит `OrderLine` вместе с `Order`, которому он принадлежит. Представление должно содержать атрибут `Order.numberOfSpecialProducts`, так как его необходимо будет обновить.
<4> - получаем `Order` из загруженного `OrderLine`.
<5> - если экземпляр `OrderLine` был только что удален, его нельзя загрузить из БД, но метод `event.getChanges()` возвращает все атрибуты удаленной сущности, включая идентификаторы связанных сущностей. Поэтому можно загрузить связанный `Order` по его id.
<6> - загружаем все экземпляры `OrderLine` для данного `Order`, отфильтровываем по `Product.special` и считаем их. Представление должно содержать `OrderLine` вместе со связанным `Product`.
<7> - сохраняем `Order` после изменения его атрибута.
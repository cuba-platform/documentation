[[gui_framework]]
=== Универсальный пользовательский интерфейс

Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя XML и Java. Созданные таким образом экраны одинаково работоспособны в двух стандартных клиентских <<app_tiers,блоках>>: *Web Client* и *Desktop Client*.

.Структура универсального пользовательского интерфейса 
image::ClientStructure.png[align="center"]

Здесь в центре изображены основные составляющие экранов универсального пользовательского интерфейса:

* <<screen_xml,XML-дескрипторы>> - файлы XML, содержащие информацию об источниках данных и компоновке экрана

* <<screen_controller,Контроллеры>> - классы Java, содержащие логику инициализации экрана и обработки событий от элементов пользовательского интерфейса.

Код экранов приложения, расположенный в <<app_modules,модуле>> *gui*, взаимодействует с интерфейсами визуальных компонентов (VCL Interfaces), реализованными по отдельности в модулях *web* и *desktop* <<app_components,базового проекта>> *cuba*. Для *Web Client* реализация основана на фреймворке *Vaadin*, для *Desktop Client* – на фреймворке *Java Swing*.

<<gui_vcl,Библиотека визуальных компонентов>> (Visual Components Library, VCL) содержит большой набор готовых компонентов для отображения данных.

Механизм <<datasources,источников данных>> (Datasources) предоставляет унифицированный интерфейс, обеспечивающий функционирование связанных с данными визуальных компонентов.

Инфраструктура клиента (Infrastructure) включает в себя главное окно приложения, механизмы отображения и взаимодействия экранов UI, а также средства взаимодействия со средним слоем.

[[screens]]
==== Экраны

Экран универсального пользовательского интерфейса состоит из <<screen_xml,XML-дескриптора>> и класса <<screen_controller,контроллера>>. Дескриптор содержит ссылку на класс контроллера. 

Для того чтобы экран можно было вызывать из главного меню или из Java кода (например, из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <<screens.xml,screens.xml>> проекта. Экран, который должен быть открыт по умолчанию после входа в систему, можно задать с помощью <<app_properties,свойства приложения>> <<cuba.web.defaultScreenId,cuba.web.defaultScreenId>>.

Главное меню приложения формируется отдельно для *Web Client* и *Desktop Client* на основе файлов <<menu.xml,menu.xml>>, расположенных соответственно в модулях *web* и *desktop* проекта.

[[screen_types]]
===== Типы экранов

В данном разделе рассматриваются основные типы экранов:

* <<frame,Фрейм>>

* <<screen_simple,Простой экран>>

* <<screen_lookup,Экран выбора>>

* <<screen_edit,Экран редактирования>>

* <<screen_combined,Комбинированный экран>>

[[frame]]
====== Фрейм

Фреймы представляют собой части экранов, которые применяются для декомпозиции и многократного использования. Для подключения фрейма в XML экрана используется элемент <<gui_Frame,frame>>.

Контроллер фрейма должен быть унаследован от класса <<abstractFrame,AbstractFrame>>.

[TIP]
====
Фрейм можно создать в Studio с помощью шаблона *Blank frame*.
====

Правила взаимодействия экрана и вложенного в него фрейма:

* Из экрана обращаться к компонентам фрейма можно через точку: `++frame_id.component_id++`

* Из контроллера фрейма получить компонент экрана можно обычным вызовом `++getComponent(component_id)++`, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.

* Из фрейма получить <<datasources,источник данных>> экрана можно простым вызовом `++getDsContext().get(ds_id)++` или <<screen_controller_injection,инжекцией>>, либо в <<datasource_query,запросе>> `++ds$ds_id++`, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).

* Из экрана получить источник данных фрейма можно только через итерацию по `getDsContext().getChildren()`

При коммите экрана вызывается также коммит измененных источников данных всех вложенных фреймов.

[[screen_simple]]
====== Простой экран

Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экземпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы и работать с <<datasources,источниками данных>>.

Контроллер простого экрана должен быть унаследован от класса <<abstractWindow,AbstractWindow>>.

[TIP]
====
Простой экран можно создать в Studio с помощью шаблона *Blank screen*.
====

[[screen_lookup]]
====== Экран выбора

Экран выбора (lookup) предназначен для выбора и возврата экземпляров и списков сущностей. Стандартное действие <<lookupAction,LookupAction>> в таких визуальных компонентах, как <<gui_PickerField,PickerField>> и <<gui_LookupPickerField,LookupPickerField>>, вызывает экраны выбора для поиска связанных сущностей.

При вызове экрана выбора методом `openLookup()` отображается панель с кнопками для выбора. Когда пользователь выбирает один или несколько экземпляров, экран вызывает переданный ему обработчик, тем самым возвращая вызывающему коду результаты выбора. При вызове методом `openWindow()` или, например, из главного меню, панель с кнопками выбора не отображается, что превращает экран выбора в <<screen_simple,простой экран>>.

Контроллер экрана выбора должен быть унаследован от класса <<abstractLookup,AbstractLookup>>. В XML экрана в атрибуте `lookupComponent` должен быть указан компонент (например, `<<gui_Table,Table>>`), из которого будет взят экземпляр сущности при выборе.

[TIP]
====
Экран выбора для сущности можно создать в Studio с помощью шаблонов *Entity browser* или *Entity combined screen*.
====

По умолчанию, действие <<lookupAction,LookupAction>> использует экран, зарегистрированный в файле <<screens.xml,screens.xml>> с идентификатором вида `{имя_сущности}.lookup` или `{имя_сущности}.browse`, например, `sales$Customer.lookup`. Поэтому при использовании вышеупомянутых компонентов убедитесь, что такой экран создан. Studio регистрирует browse-экраны с идентификаторами вида `{имя_сущности}.browse`, поэтому они автоматически вызываются в качестве экранов выбора.

[[screen_lookup_customization]]
Настройка вида и поведения экрана выбора::
+
--
* Для того, чтобы заменить панель выбора (кнопки *Select* и *Cancel*) для всех экранов выбора в проекте, создайте фрейм и зарегистрируйте его с идентификатором `lookupWindowActions`. Стандартный фрейм расположен в файле `/com/haulmont/cuba/gui/lookup-window.actions.xml`. Новый фрейм должен содержать кнопку, связанную с действием `lookupSelectAction` (которое автоматически добавляется в экран, когда он открывается как экран выбора).

* Чтобы заменить панель выбора в некотором экране, создайте в нем кнопку, связанную с действием `lookupSelectAction`. В этом случае стандартный фрейм не будет показан. Например:
+
[source, xml]
----
include::{sourcesdir}/gui/screen_lookup_1.xml[]
----

* Чтобы заменить стандартное действие выбора своим, просто добавьте его в контроллере:
+
[source, java]
----
include::{sourcesdir}/gui/screen_lookup_2.java[]
----
+
В качестве базового класса используйте `com.haulmont.cuba.gui.components.SelectAction`, переопределив требуемые методы.
--

[[screen_edit]]
====== Экран редактирования

Экран редактирования предназначен для отображения и редактирования экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <<gui_Action,действия>> по коммиту изменений в базу данных. Экран редактирования должен вызываться методом `openEditor()` с передачей экземпляра сущности.

Стандартные действия <<createAction,CreateAction>> и <<editAction,EditAction>> открывают экран, зарегистрированный в файле <<screens.xml,screens.xml>> с идентификатором вида `{имя_сущности}.edit`, например, `sales$Customer.edit`.

Контроллер экрана редактирования должен быть унаследован от класса <<abstractEditor,AbstractEditor>>.

[TIP]
====
Экран редактирования для сущности можно создать в Studio с помощью шаблона *Entity editor*.
====

В XML экрана в атрибуте `datasource` указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:

* `editWindowActions` (файл `com/haulmont/cuba/gui/edit-window.actions.xml`) - содержит кнопки *OK* и *Cancel*

* `extendedEditWindowActions` (файл `com/haulmont/cuba/gui/extended-edit-window.actions.xml`) - содержит кнопки *OK & Close*, *OK* и *Cancel*

В экране редактирования неявно создаются следующие действия:

* `windowCommitAndClose` (соответствует константе `++Window.Editor.WINDOW_COMMIT_AND_CLOSE++`) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается при наличии в экране визуального компонента с идентификатором `windowCommitAndClose`, в частности, при использовании вышеописанного стандартного фрейма `extendedEditWindowActions` отображается кнопкой *OK & Close*.

* `windowCommit` (соответствует константе `++Window.Editor.WINDOW_COMMIT++`) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия `windowCommitAndClose` после коммита закрывает экран. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *OK*.

* `windowClose` (соответствует константе `++Window.Editor.WINDOW_CLOSE++`) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *Cancel*.

Таким образом, если в экран добавлен фрейм `editWindowActions`, то кнопка *OK* коммитит изменения и закрывает экран, а кнопка *Cancel* - закрывает без коммита. Если же добавлен фрейм `extendedEditWindowActions`, то кнопка *OK* только коммитит изменения, оставляя экран открытым, кнопка *OK & Close* коммитит и закрывает экран, кнопка *Cancel* - закрывает без коммита.

Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например, <<gui_LinkButton,LinkButton>>.

[[screen_combined]]
====== Комбинированный экран

Комбинированный экран позволяет отобразить список сущностей слева и форму редактирования выбранного экземпляра справа. Таким образом, это комбинация экранов <<screen_lookup,выбора>> и <<screen_edit,редактирования>>.

Контроллер экрана редактирования должен быть унаследован от класса <<entityCombinedScreen,EntityCombinedScreen>>.

[TIP]
====
Комбинированный экран для сущности можно создать в Studio с помощью шаблона *Entity combined screen*.
====

[[screen_xml]]
===== XML-дескриптор

XML-дескриптор - это файл формата XML, описывающий <<datasources,источники данных>> и расположение визуальных компонентов экрана.

Схема XML доступна по адресу {xsd_url}/window.xsd.

Рассмотрим структуру дескриптора.

`window` − корневой элемент.

Атрибуты `window`:

* `class` − имя класса <<screen_controller,контроллера>>

* `messagesPack` − <<message_packs,пакет сообщений>> данного экрана, который будет использован при получении локализованных строк без указания пакета из XML-дескриптора и из контроллера методом `getMessage()`

* `caption` − заголовок экрана, может содержать <<messageTools.loadString,ссылку на сообщение>> из вышеуказанного пакета, например, 
+
[source, properties]
----
caption="msg://caption"
----

* `focusComponent` − идентификатор компонента, который получит фокус ввода при отображении экрана

* `lookupComponent` - обязательный для <<screen_lookup,экрана выбора>> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):

** `Table`

** `Tree`

** `LookupField`

** `PickerField`

** `OptionsGroup`

* `datasource` - обязательный для <<screen_edit,экрана редактирования>> атрибут, задающий идентификатор <<datasources,источника данных>>, в который будет проставлен экземпляр редактируемой сущности.

Элементы `window`:

* `metadataContext` − элемент для инициализации <<views,представлений>> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле `<<views.xml,views.xml>>`, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.

* `dsContext` − определяет <<datasources,источники данных>> данного экрана.

* `dialogMode` - определяет параметры геометрии и поведения экрана при открытии его в виде диалогового окна.
+
--
Атрибуты `dialogMode`:

** `closeable` - определяет наличие в диалоговом окне кнопки закрытия. Возможные значения: `true`, `false`.

** `closeOnClickOutside` - определяет возможность закрыть окно кликом по окружающей области, если диалог открыт в модальном режиме. Возможные значения: `true`, `false`.

** `forceDialog` - указывает, что экран должен всегда открываться в режиме диалога, независимо от того, какой `WindowManager.OpenType` был выбран в вызывающем коде. Возможные значения: `true`, `false`.

** `height` - устанавливает высоту диалогового окна.

** `maximized` - если выбрано значение `true`, диалог будет развёрнут во весь экран. Возможные значения: `true`, `false`.

** `modal` - устанавливает модальный режим диалогового окна. Возможные значения: `true`, `false`.

** `positionX` - задаёт положение левого верхнего угла диалога по оси `x`.

** `positionY` - задаёт положение левого верхнего угла диалога по оси `y`.

** `resizable` - определяет возможность пользователя изменять размеры диалога. Возможные значения: `true`, `false`.

** `width` - устанавливает ширину диалогового окна.

Пример использования `dialogMode`:

[source, xml]
----
include::{sourcesdir}/gui/dialogs_4.xml[]
----
--

* `actions` - определяет список <<gui_Action,действий>> данного экрана.

* `timers` - определяет список таймеров данного экрана.

* `companions` - определяет список классов-<<companions,компаньонов>> данного контроллера
+
Элементы `companions`:

** `web` - задает компаньон, реализованный в модуле *web*

** `desktop` - задает компаньон, реализованный в модуле *desktop*
+
Каждый из этих элементов содержит атрибут `class`, задающий класс компаньона.

* `layout` − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>.
+
Атрибуты `layout`:

** <<gui_attr_spacing,spacing>>

** <<gui_attr_margin,margin>>

** <<gui_attr_expand,expand>>

** <<gui_attr_stylename,stylename>>

** <<gui_attr_height,height>>

** <<gui_attr_width,width>>

[[screen_controller]]
===== Контроллер экрана

Контроллер экрана - это `Java` или `Groovy` класс, связанный с <<screen_xml,XML-дескриптором>>, и содержащий логику инициализации и обработки событий экрана.

Контроллер должен быть унаследован от одного из следующих базовых классов:

* <<abstractFrame,AbstractFrame>> − предназначен для реализации <<frame,фреймов>>.

* <<abstractWindow,AbstractWindow>> − предназначен для реализации <<screen_simple,простых экранов>>.

* <<abstractLookup,AbstractLookup>> − предназначен для реализации <<screen_lookup,экранов выбора>>.

* <<abstractEditor,AbstractEditor>> − предназначен для реализации <<screen_edit,экранов редактирования>>.

[TIP]
====
Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс `AbstractWindow`, `AbstractLookup` или `AbstractEditor`, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.
====

Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте `class` корневого элемента `window`.

.Базовые классы контроллеров
image::Controllers.png[align="center"]

[[abstractFrame]]
====== AbstractFrame

`AbstractFrame` является корнем иерархии классов контроллеров. Рассмотрим его основные методы:

[[abstractFrame_init]]
* `init()` - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.
+
--
В метод `init()` из вызывающего кода передается мэп параметров, которые могут быть использованы внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе `openWindow()`, `openLookup()` или `openEditor()`), так и установлены в файле регистрации экранов `<<screens.xml,screens.xml>>`.

Метод `init()` следует имплементировать при необходимости инициализации компонентов экрана, например:

[source, java]
----
include::{sourcesdir}/gui/abstractframe_1.java[]
----
--

[[abstractFrame_getMessage]]
* `getMessage()`, `formatMessage()` - методы получения локализованных сообщений из <<message_packs,пакета>>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса `<<messages,Messages>>`.

[[abstractFrame_openFrame]]
* `openFrame()` - загрузить фрейм по идентификатору, зарегистрированному в <<screens.xml,screens.xml>>, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_3.java[]
----
+
Контейнер не обязательно сразу передавать в метод `openFrame()`, вместо этого можно загрузить фрейм, а затем добавить его в нужный контейнер:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_4.java[]
----

[[abstractFrame_openWindow]]
* `openWindow()`, `openLookup()`, `openEditor()` - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.
+
При открытии экрана в режиме диалога метод `openWindow()` может быть вызван с параметрами, к примеру:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_7.java[]
----
Эти параметры будут учитываться, если они не конфликтуют с более приоритетными параметрами самого вызываемого экрана. Последние могут быть заданы в методе <<dialogOptions,getDialogOptions()>> контроллера экрана или в <<screen_xml,XML-дескрипторе>> этого экрана:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_8.xml[]
----
+
Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа `CloseListener`, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5.java[]
----
+
`CloseWithCommitListener` можно использовать в случае, если необходимо реагировать только при закрытии экрана действием с именем `Window.COMMIT_ACTION_ID` (то есть кнопкой *OK*), например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5_1.java[]
----

[[abstractFrame_showMessageDialog]]
* `showMessageDialog()` - отобразить диалоговое окно с сообщением.

[[abstractFrame_showOptionDialog]]
* `showOptionDialog()` - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа `<<gui_Action,Action>>`, которые в диалоге отображаются посредством соответствующих кнопок.
+
Для отображения стандартных кнопок типа *OK*, *Cancel* и других рекомендуется использовать объекты типа `DialogAction`, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_6.java[]
----

[[abstractFrame_showNotification]]
* `showNotification()` - отобразить всплывающее окно с сообщением.

[[abstractFrame_showWebPage]]
* `showWebPage()` - открыть указанную веб-страницу в браузере.

'''

API::
<<abstractFrame_getMessage,formatMessage()>> -
<<abstractFrame_getMessage,getMessage()>> -
<<abstractFrame_init,init()>> -
<<abstractFrame_openFrame,openFrame()>> -
<<abstractFrame_openWindow,openEditor()>> -
<<abstractFrame_openWindow,openLookup()>> -
<<abstractFrame_openWindow,openWindow()>> -
<<abstractFrame_showMessageDialog,showMessageDialog()>> -
<<abstractFrame_showNotification,showNotification()>> -
<<abstractFrame_showOptionDialog,showOptionDialog()>> -
<<abstractFrame_showWebPage,showWebPage()>>

'''

[[abstractWindow]]
====== AbstractWindow

`AbstractWindow` является наследником `<<abstractFrame,AbstractFrame>>`, и определяет следующие собственные методы:

[[dialogOptions]]
* `getDialogOptions()` - получить объект `DialogOptions` для управления геометрией и поведением экрана когда он открывается в режиме диалога (`WindowManager.OpenType.DIALOG`). Эти параметры могут быть заданы при инициализации экрана, а также могут изменяться на лету.
+
Установка ширины и высоты:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_2.java[]
----
+
Установка положения диалога на экране:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_9.java[]
----
+
Возможность закрыть диалог кликом по окружающей области:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_7.java[]
----
+
Указание того, что диалог должен быть немодальным и с изменяемыми размерами:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_3.java[]
----
+
Указание того, что диалог должен быть развёрнут во весь экран:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_8.java[]
----
+
Указание того, что экран должен всегда открываться в режиме диалога, независимо от того, какой `WindowManager.OpenType` был выбран в вызывающем коде:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_4.java[]
----

[[abstractWindow_contentSwitchMode]]
* `setContentSwitchMode()` - определяет режим переключения вкладок <<cuba.web.mainTabSheetMode,главного TabSheet>> для вкладки, содержащей данное окно: скрывать содержимое или полностью выгружать его.
+
--
Доступны следующие режимы:

* `DEFAULT` - режим переключения определяется режимом главного TabSheet, установленном в свойстве приложения <<cuba.web.managedMainTabSheetMode,cuba.web.managedMainTabSheetMode>>.

* `HIDE` - содержимое вкладки должно быть только скрыто, независимо от режима главного TabSheet.

* `UNLOAD` - содержимое вкладки должно быть выгружено, независимо от режима главного TabSheet.
--

[[abstractWindow_saveSettings]]
* `saveSettings()` - сохраняет настройки экрана для текущего пользователя в базе данных при закрытии экрана.
+
К примеру, на экране имеется чекбокс *showPanel*, управляющий отображением некой панели. Мы переопределяем метод `saveSettings()`: создаём в нём XML-элемент для этого чекбокса, добавляем ему атрибут `showPanel`, содержащий текущее значение чекбокса, а затем сохраняем элемент `settings` в XML-файл для текущего пользователя в базе данных.
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_6.java[]
----

[[abstractWindow_applySettings]]
* `applySettings()` - восстанавливает настройки экрана для текущего пользователя из базы данных при открытии экрана.
+
Переопределим метод для восстановления настроек из предыдущего примера. Получаем XML-элемент чекбокса, проверяем, что нужный нам атрибут `showPanel` не равен `null`, а затем восстанавливаем для чекбокса предыдущее сохранённое значение:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_5.java[]
----
+
Другой пример управления настройками экрана можно увидеть на стандартном экране *Server Log* в меню *Administration* приложения CUBA, который автоматически сохраняет и восстанавливает последние открытые пользователем лог-файлы.

[[abstractWindow_ready]]
* `ready()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента открытия экрана. Метод `ready()` вызывается фреймворком после метода `init()` непосредственно перед показом экрана в главном окне приложения.

[[abstractWindow_validateAll]]
* `validateAll()` - валидация экрана. Реализация по умолчанию вызывает метод `validate()` у всех компонентов экрана, реализующих интерфейс `Component.Validatable`, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает `false`, иначе возвращает `true`.
+
Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод `postValidate()`.

[[abstractWindow_postValidate]]
* `postValidate()` - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект `ValidationErrors` используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_1.java[]
----

[[abstractWindow_showValidationErrors]]
* `showValidationErrors()` - метод, который отображает сообщение об ошибках валидации экрана. Чтобы изменить поведение стандартных сообщений, метод можно переопределить. Тип уведомления определяется свойством приложения <<cuba.gui.validationNotificationType,cuba.gui.validationNotificationType>>.
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_10.java[]
----

[[abstractWindow_close]]
* `close()` - закрыть данный экран. 
+
Метод принимает строковое значение, передаваемое далее в шаблонный метод `preClose()` и слушателям `CloseListener`. Таким образом, заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу `++Window.COMMIT_ACTION_ID++`, без коммита изменений - константу `++Window.CLOSE_ACTION_ID++`.
+
Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения `<<cuba.gui.useSaveConfirmation,cuba.gui.useSaveConfirmation>>`.
+
Вариант метода `close()` с параметром `force = true` закрывает экран без вызова `preClose()` и без предупреждения, независимо от наличия несохраненных изменений.
+
Метод `close()` возвращает `true`, если экран был успешно закрыт, и `false` - если закрытие было прервано.

[[abstractWindow_preClose]]
* `preClose()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода `close()`.
+
Если метод `preClose()` возвращает `false`, то процесс закрытия экрана прерывается.

[[abstractWindow_addBeforeCloseWithCloseButtonListener]]
* `addBeforeCloseWithCloseButtonListener()` - добавляет слушатель, который отслеживает закрытие окна одним из следующих способов: кнопка закрытия окна, панель breadcrumbs или действия для закрытия вкладок `TabSheet` (Close, Close All, Close Others). Чтобы предотвратить случайное закрытие окна пользователем, можно вызвать метод `preventWindowClose()` события `BeforeCloseEvent`:
+
[source, java]
----
addBeforeCloseWithCloseButtonListener(BeforeCloseEvent::preventWindowClose);
----

[[abstractWindow_addBeforeCloseWithShortcutListener]]
* `addBeforeCloseWithShortcutListener` - добавляет слушатель, который отслеживает закрытие окна горячими клавишами (например, нажатием `Esc`). Чтобы предотвратить случайное закрытие окна пользователем, можно вызвать метод `preventWindowClose()` события `BeforeCloseEvent`:
+
[source, java]
----
addBeforeCloseWithShortcutListener(BeforeCloseEvent::preventWindowClose);
----

'''

API::
<<abstractWindow_addBeforeCloseWithCloseButtonListener,addBeforeCloseWithCloseButtonListener()>> -
<<abstractWindow_addBeforeCloseWithShortcutListener,addBeforeCloseWithShortcutListener()>> -
<<abstractWindow_applySettings,applySettings()>> -
<<abstractWindow_close,close()>> -
<<abstractWindow_contentSwitchMode,setContentSwitchMode()>> -
<<dialogOptions,getDialogOptions()>> -
<<abstractWindow_postValidate,postValidate()>> -
<<abstractWindow_preClose,preClose()>> -
<<abstractWindow_ready,ready()>> -
<<abstractWindow_saveSettings,saveSettings()>> -
<<abstractWindow_validateAll,validateAll()>>

'''

[[abstractLookup]]
====== AbstractLookup

`AbstractLookup` базовый класс контроллеров <<screen_lookup,экранов выбора>>, является наследником `<<abstractWindow,AbstractWindow>>`, и определяет следующие собственные методы:

[[abstractLookup_setLookupComponent]]
* `setLookupComponent()` - установить компонент, из которого будет производиться выбор экземпляров сущности.
+
Как правило, компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.

[[abstractLookup_setLookupValidator]]
* `setLookupValidator()` - установить для экрана объект типа `Window.Lookup.Validator`, метод `validate()` которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если `validate()` возвращает `false`, процесс выбора и закрытия экрана прерывается.
+
По умолчанию валидатор не установлен.

'''

API::
<<abstractLookup_setLookupComponent,setLookupComponent()>> -
<<abstractLookup_setLookupValidator,setLookupValidator()>>

'''

[[abstractEditor]]
====== AbstractEditor

`AbstractEditor` − базовый класс контроллеров <<screen_edit,экранов редактирования>>, является наследником `<<abstractWindow,AbstractWindow>>`.

При создании конкретного класса контроллера рекомендуется параметризовать `AbstractEditor` типом редактируемой сущности. При этом методы `getItem()` и `initNewItem()` будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_1.java[]
----

`AbstractEditor` определяет следующие собственные методы:

[[abstractEditor_getItem]]
* `getItem()` - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте `datasource` корневого элемента XML-дескриптора).
+
Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <<views,представлением>>, указанным для главного источника данных. 
+
Изменения, вносимые в экземпляр, возвращаемый `getItem()`, отражаются на состоянии источника данных, и будут отправлены на *Middleware* при коммите экрана.
+
[WARNING]
====
Следует иметь в виду, что `getItem()` возвращает значение только после инициализации экрана методом `setItem()`. До этого момента, например, в методах `init()` и `initNewItem()`, данный метод возвращает `null`.

Однако в методе `init()` экземпляр сущности, переданный в `openEditor()`, можно получить из параметров следующим образом:

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_2.java[]
----

В метод `initNewItem()` экземпляр передается явно и нужного типа.

В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.
====

[[abstractEditor_setItem]]
* `setItem()` - вызывается фреймворком при открытии экрана методом `openEditor()` для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова созданы все компоненты и источники данных экрана, и отработал метод `init()` контроллера.
+
Для инициализации экрана редактирования вместо переопределения `setItem()` рекомендуется имплементировать специальные шаблонные методы `initNewItem()` и `postInit()`.

[[initNewItem]]
* `initNewItem()` - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.
+
[TIP]
====
Метод `initNewItem()` вызывается только для нового, только что созданного экземпляра сущности. Если редактируется <<entity_states,detached>> экземпляр, метод не вызывается.
====
+
Данный метод можно имплементировать в контроллере при необходимости инициализации нового экземпляра сущности перед его установкой в источник данных, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_3.java[]
----
+
Более сложный пример использования `initNewItem()` приведен в разделе <<init_values_in_initNewItem,рецептов разработки>>.

[[abstractEditor_postInit]]
* `postInit()` - шаблонный метод, вызываемый фреймворком сразу после установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать `getItem()`, который будет возвращать новый или перезагруженный при инициализации экрана экземпляр сущности.
+
Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_4.java[]
----

[[abstractEditor_commit]]
* `commit()` - валидировать экран и отправить изменения через `<<dataSupplier,DataSupplier>>` на *Middleware*.
+
Если используется вариант метода с параметром `validate = false`, то валидация перед коммитом не производится.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

[[abstractEditor_commitAndClose]]
* `commitAndClose()` - валидировать экран, отправить изменения на *Middleware* и закрыть экран. В метод `preClose()` и зарегистрированным слушателям `CloseListener` будет передано значение константы `++Window.COMMIT_ACTION_ID++`.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

[[abstractEditor_preCommit]]
* `preCommit()` - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как валидация завершена успешно и перед отправкой данных на *Middleware*.
+
Данный метод можно имплементировать в контроллере. Если метод возвращает `false`, процесс коммита (и закрытия экрана, если был вызван `commitAndClose()`), прерывается. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_5.java[]
----

[[abstractEditor_postCommit]]
* `postCommit()` - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:

** `committed` - установлен в `true`, если в экране действительно были изменения, и они отправлены на *Middleware*;

** `close` - установлен в `true`, если экран после коммита будет закрыт.
+
Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод `postInit()`.
+
Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_6.java[]
----

Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.

.Инициализация экрана редактирования
image::EditorInit.png[align="center"]

.Коммит и закрытие экрана с фреймом editWindowActions
image::EditorCommit.png[align="center"]

.Коммит экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommit.png[align="center"]

.Коммит и закрытие экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommitAndClose.png[align="center"]

'''

API::

<<abstractEditor_commit,commit()>> -
<<abstractEditor_commitAndClose,commitAndClose()>> -
<<abstractEditor_getItem,getItem()>> -
<<initNewItem,initNewItem()>> -
<<abstractEditor_postCommit,postCommit()>> -
<<abstractEditor_postInit,postInit()>> -
<<abstractEditor_preCommit,preCommit()>> -
<<abstractEditor_setItem,setItem()>>

'''

[[entityCombinedScreen]]
====== EntityCombinedScreen

`EntityCombinedScreen` − базовый класс контроллеров <<screen_combined,комбинированных экранов>>, является наследником <<abstractLookup,AbstractLookup>>.

Класс `EntityCombinedScreen` ищет ключевые компоненты экрана, такие как таблица, field group и некоторые другие, по зашитым в код идентификаторам. Если эти компоненты в вашем экране названы по другому, переопределите protected-методы класса и возвращайте из них ваши идентификаторы, чтобы контроллер мог найти нужные компоненты. См. JavaDocs класса для более подробной информации.

[[screen_controller_injection]]
====== Инжекция зависимостей контроллеров

В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:

* `@Inject` - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода

* `@Named("someName")` - вариант с явным указанием имени искомого объекта

Инжектировать в контроллеры можно следующие объекты: 

* Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Component`, в текущем экране будет произведен поиск компонента с соответствующим именем. 

* Действия, определенные в XML-дескрипторе - см. <<gui_Action,Действия. Интерфейс Action>>

* <<datasources,Источники данных>>, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Datasource`, в текущем экране будет произведен поиск источника данных с соответствующим именем. 

* `UserSession`. Если тип атрибута - `<<userSession,UserSession>>`, будет инжектирован объект текущей пользовательской сессии.

* `DsContext`. Если тип атрибута - `DsContext`, будет инжектирован `DsContext` текущего экрана. 

* `WindowContext`. Если тип атрибута - `WindowContext`, будет инжектирован `WindowContext` текущего экрана. 

* `DataSupplier`. Если тип атрибута - `<<dataSupplier,DataSupplier>>`, будет инжектирован соответствующий экземпляр.

* Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:

** импортируемые клиентом <<services,сервисы>> *Middleware*

** <<config_interfaces,конфигурационные интерфейсы>>

** `ComponentsFactory`

** `WindowConfig`

** `ExportDisplay`

** `<<background_tasks,BackgroundWorker>>`

* Если ничего из вышеперечисленного не подошло и контроллер имеет <<companions,компаньонов>>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.

[[screen_controller_injection_params]]
С помощью специальной аннотации `@WindowParam` можно инжектировать в контроллер параметры, передаваемые в мэп метода `init()`. Аннотация имеет атрибут `name`, в котором указывается имя параметра (ключ в мэп), и опциональный атрибут `required`. Если `required = true`, то при отсутствии в мэп соответствующего параметра в лог выводится сообщение с уровнем `WARNING`.

Пример инжекции объекта типа `Job`, передаваемого в метод `init()` контроллера:

[source, java]
----
include::{sourcesdir}/gui/cdi_1.java[]
----

[[companions]]
====== Компаньоны контроллеров

Базовые классы контроллеров расположены в <<app_modules,модуле>> *gui* <<app_components,базового проекта>> *cuba* и не содержат ссылок на классы реализации визуальных компонентов (*Swing* или *Vaadin*), что дает возможность использовать их в клиентах обоих типов.

В то же время конкретные классы контроллеров могут быть расположены как в модуле *gui*, так и в *web* или *desktop*, в зависимости от применяемых в проекте клиентских <<app_tiers,блоков>> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых _классах-компаньонах_. 

Класс-компаньон располагается в модуле клиента соответствующего типа (*web* или *desktop*) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе `companions` XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом `getCompanion()`, и в нужный момент передать ему управление, например, для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. 

Например, необходимо раздельно для веб и десктоп клиентов проинициализировать таблицу некоторого экрана. Тогда в контроллере экрана, расположенном в модуле *gui*, определяем интерфейс компаньона и делегируем ему инициализацию таблицы:

[source, java]
----
include::{sourcesdir}/gui/companion_1.java[]
----

В модулях *web* и *desktop* создаем соответствующие классы реализации компаньона:

[source, java]
----
include::{sourcesdir}/gui/companion_2.java[]
----

[source, java]
----
include::{sourcesdir}/gui/companion_3.java[]
----

И регистрируем классы реализации компаньона в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui/companion_4.xml[]
----

Так как классы-компаньоны расположены в *web* и *desktop* модулях, в них можно использовать метод `unwrap()` классов <<webComponentsHelper,WebComponentsHelper>> и <<desktopComponentsHelper,DesktopComponentsHelper>> для извлечения из интерфейса <<gui_Table,Table>> ссылок на реализующие таблицу Vaadin и Swing компоненты, и работать с ними непосредственно.

[[screen_agent]]
===== Screen Agent

Указание агента позволяет выбрать экран в зависимости от текущего устройства и параметров его дисплея. Например, можно создать два экрана с различной компоновкой (и, возможно, различной функциональностью), и зарегистрировать их в файле <<screens.xml,screens.xml>> с одним идентификатором. Тогда во время выполнения платформа выберет экран, который лучше подходит для дисплея, с которого пользователь работает с приложением.

В платформе предопределены три агента: `DESKTOP`, `TABLET`, `PHONE`. Они заданы следующими классами: `DesktopScreenAgent`, `TabletScreenAgent`, `PhoneScreenAgent`. В проекте приложения можно определить собственные агенты путем создания <<managed_beans,бинов>>, реализующих интерфейс `ScreenAgent`.

Агент указывается для экрана в файле <<screens.xml,screens.xml>>. Значением атрибута `agent` должна быть либо одна из вышеперечисленных констант, либо имя бина, реализующего `ScreenAgent`.

В Studio агент задается на вкладке *Properties* дизайнера экранов.


include::gui_vcl.adoc[]

[[datasources]]
==== Источники данных

Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.

Визуальные компоненты сами не обращаются к *Middleware*, а получают экземпляры сущностей из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.

Связь визуального компонента и источника данных проявляется в следующем:

* При изменении пользователем значения в компоненте новое значение проставляется в атрибуте сущности, находящейся в источнике.

* При изменении атрибута сущности из кода новое значение проставляется и отображается в визуальном компоненте. 

* Для слежения за вводом пользователя можно использовать как <<datasource_listeners,слушатель источника данных>>, так и слушатель значения визуального компонента - они срабатывают друг за другом. 

* При необходимости прочитать или записать значение атрибута сущности в коде предпочтительнее использовать источник данных, а не компонент. Рассмотрим пример чтения атрибута: 
+
[source, java]
----
include::{sourcesdir}/gui/datasources_1.java[]
---- 
+
Как видно из примера, работа со значениями атрибутов сущностей через компонент - не самый прямолинейный способ. В первом случае он требует приведения типа и указания поля <<gui_FieldGroup,FieldGroup>> в виде строки. Второй пример более безопасный и прямой, но он требует знания ещё и типа поля, которое должно быть <<screen_controller_injection,инжектировано>> в контроллер. В то же время, получив методом `getItem()` из источника данных хранящийся в нем экземпляр, можно напрямую читать и изменять значения его атрибутов.

[WARNING]
====
Как правило, визуальный компонент привязывается к атрибуту, непосредственно принадлежащему сущности, находящейся в источнике данных. В приведенном выше примере компонент привязан к атрибуту `customer` сущности `Order`. 

Можно также привязать компонент к атрибуту связанной сущности, например к `customer.name`. В этом случае компонент будет корректно отображать значение атрибута `name`, но при его изменении пользователем слушатели источника данных вызваны не будут, и изменения не будут сохранены. Поэтому привязывать компонент к атрибутам второго и более порядка имеет смысл только для отображения, например в <<gui_Label,Label>>, колонке <<gui_Table,Table>> или установив для <<gui_TextField,TextField>> свойство `editable = false`.
====

Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на *Middleware* для сохранения в базе данных.

Рассмотрим основные интерфейсы источников.

.Интерфейсы источников данных
image::Datasources.png[align="center"]

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/Datasource.html[Datasource] − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом `setItem()` и доступен через `getItem()`.
+
Стандартной реализацией такого источника является класс `DatasourceImpl`, который используется, например, как главный источник данных в <<screen_edit,экранах редактирования>> сущностей.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/CollectionDatasource.html[CollectionDatasource] − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода `refresh()`, ключи экземпляров доступны через метод `getItemIds()`. Метод `setItem()` устанавливает, а `getItem()` возвращает "текущий" экземпляр коллекции, т.е., например, соответствующий выбранной в данный момент строке таблицы.
+
Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с Middleware через <<dataManager,DataManager>>, при этом для формирования JPQL запроса используются методы `setQuery()`, `setQueryFilter()`.
+
Стандартной реализацией такого источника является класс `CollectionDatasourceImpl`, который используется в экранах, отображающих списки сущностей.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/GroupDatasource.html[GroupDatasource] − подвид `CollectionDatasource`, предназначенный для работы с компонентом `<<gui_GroupTable,GroupTable>>`.
+
Стандартной реализацией является класс `GroupDatasourceImpl`.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/HierarchicalDatasource.html[HierarchicalDatasource] − подвид `CollectionDatasource`, предназначенный для работы с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Стандартной реализацией является класс `HierarchicalDatasourceImpl`.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/NestedDatasource.html[NestedDatasource] - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом `getMaster()`, а <<metaProperty,мета-свойство>>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод `getProperty()`.
+
Например, в источнике `dsOrder` установлен экземпляр сущности `Order`, содержащий ссылку на экземпляр `Customer`. Тогда для связи экземпляра `Customer` с визуальными компонентами достаточно создать `NestedDatasource`, у которого хозяином является `dsOrder`, а мета-свойство указывает на атрибут `Order.customer`.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/PropertyDatasource.html[PropertyDatasource] - подвид `NestedDatasource`, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).
+
Стандартные реализации: для работы с одним экземпляром - `PropertyDatasourceImpl`, для работы с коллекцией - `CollectionPropertyDatasourceImpl`, `GroupPropertyDatasourceImpl`, `HierarchicalPropertyDatasourceImpl`. Последние реализуют также интерфейс `CollectionDatasource`, однако некоторые его нерелевантные методы, связанные с загрузкой, например, `setQuery()`, выбрасывают `UnsupportedOperationException`.

** http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/EmbeddedDatasource.html[EmbeddedDatasource] - подвид `NestedDatasource`, содержащий экземпляр встроенной сущности.
+
Стандартной реализацией является класс `EmbeddedDatasourceImpl`.

* http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/data/RuntimePropsDatasource.html[RuntimePropsDatasource] − специфический источник, предназначенный для работы с <<dynamic_attributes,динамическими атрибутами>> сущностей.

Как правило, источники данных объявляются декларативно в секции `dsContext` <<screen_xml,дескриптора экрана>>.

[[datasource_auto_refresh]]
Автоматическое обновление CollectionDatasource::
+
--
При открытии экрана, его визуальные компоненты, соединенные с источниками типа `CollectionDatasource`, заставляют эти источники загрузить данные. В результате, <<gui_Table,таблицы>> отображают данные сразу после открытия экрана, без всякого дополнительного действия пользователя. Если вы хотите предотвратить автоматическую загрузку, то установите параметр экрана `DISABLE_AUTO_REFRESH` в `true` в методе `init()` этого экрана, или передайте его из вызывающего кода. Данный параметр определен в перечислении `WindowParams`, поэтому он может быть задан следующим образом:

[source, java]
----
@Override
public void init(Map<String, Object> params) {
    WindowParams.DISABLE_AUTO_REFRESH.set(params, true);
}
----

В этом случае, источники данных типа `CollectionDatasource` будут загружены только когда будет вызван их метод `refresh()`. Это может быть сделано как кодом приложения, так и в случае, если пользователь нажмет кнопку *Search* компонента <<gui_Filter,Filter>>.
--

[[datasource_creation]]
===== Создание источников данных

Объекты источников данных могут быть созданы как декларативно - путем объявления в XML-дескрипторе экрана, так и программно в контроллере. Обычно используются стандартные реализации интерфейсов источников, однако при необходимости можно создать собственный класс, унаследовав его от стандартного.

[[datasource_decl_creation]]
====== Декларативное создание

Как правило, источники данных объявляются декларативно в элементе `dsContext` дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:

* если элемент расположен непосредственно в `dsContext`, создается обычный `Datasource` или `CollectionDatasource`, который содержит независимо загруженную сущность или коллекцию;

* если элемент расположен внутри элемента другого источника, создается `NestedDatasource`, при этом внешний источник становится его хозяином. 

Пример объявления источников данных:

[source, xml]
----
include::{sourcesdir}/gui/datasources_2.xml[]
----

Здесь источник `carDs` содержит один экземпляр сущности `Car`, а вложенные в него `allocationsDs` и `repairsDs` содержат коллекции связанных сущностей из атрибутов `Car.driverAllocations` и `Car.repairs` соответственно. Экземпляр `Car` вместе со связанными сущностями проставляется в источник данных извне. Если данный экран является <<screen_edit,экраном редактирования>>, то это происходит автоматически при открытии экрана. Источник данных `colorsDs` содержит коллекцию экземпляров сущности `Color`, загружаемую самим источником по указанному JPQL-<<datasource_query,запросу>> с <<views,представлением>> `++_local++`.

Рассмотрим схему XML. 

`dsContext` - корневой элемент.

Элементы `dsContext`:

* `datasource` - определяет источник данных, содержащий единственный экземпляр сущности. 
+
Атрибуты:

** `id` - идентификатор источника, должен быть уникальным для данного `DsContext`.

** `class` - Java класс сущности, которая будет содержаться в данном источнике

** `view` - имя <<views,представления>> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.

** `allowCommit` - при установке значения `false` метод `isModified()` данного источника всегда возвращает `false`, а метод `commit()` ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию `true`, т.е. изменения отслеживаются и могут быть сохранены.

** `datasourceClass` - <<datasource_custom_class, собственный класс реализации>> источника данных, если необходим.

* `collectionDatasource` - определяет источник данных, содержащий коллекцию экземпляров.
+
Атрибуты `collectionDatasource`:

** `refreshMode` - режим обновления источника, по умолчанию `ALWAYS`. В режиме `NEVER` при вызове `refresh()` источник не производит загрузку данных, а только переходит в состояние `Datasource.State.VALID`, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим `NEVER` удобен, если необходимо программно заполнить `CollectionDatasource` предварительно загруженными или созданными сущностями. Например:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_3.java[]
----

** `softDeletion` - значение `false` отключает режим <<soft_deletion,мягкого удаления>> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию `true`.
+
Элементы `collectionDatasource`:

** `query` - <<datasource_query,запрос>> для загрузки сущностей

* `groupDatasource` - полностью аналогичен `collectionDatasource`, но создает реализацию источника данных, пригодную для использования совместно с компонентом `<<gui_GroupTable,GroupTable>>`.

* `hierarchicalDatasource` - аналогичен `collectionDatasource`, и создает реализацию источника данных, пригодную для использования совместно с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Специфическим атрибутом является `hierarchyProperty`, задающий имя атрибута сущности, по которому строится иерархия.

Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте `datasourceClass`. 

[[datasource_prog_creation]]
====== Программное создание

При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом `DsBuilder`. 

Экземпляр `DsBuilder` параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры `master` и `property`, то в результате будет создан `NestedDatasource`, в противном случае - `Datasource` или `CollectionDatasource`.

Пример:

[source, java]
----
include::{sourcesdir}/gui/datasources_4.java[]
----

[[datasource_custom_class]]
====== Собственные классы реализации

Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от `CustomCollectionDatasource`, либо от `CustomGroupDatasource` или `CustomHierarchicalDatasource`, и определить метод `getEntities()`.

Пример:

[source, java]
----
include::{sourcesdir}/gui/datasources_5.java[]
----

Для создания экземпляра нестандартного источника данных декларативным способом необходимо указать класс в атрибуте `datasourceClass` элемента XML. При программном создании через `DsBuilder` класс источника указывается вызовом `setDsClass()` или в параметре одного из методов `build*()`.

[[datasource_query]]
===== Запросы в CollectionDatasourceImpl

Класс `CollectionDatasourceImpl` и его наследники `GroupDatasourceImpl`, `HierarchicalDatasourceImpl` являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через `DataManager`, отправляя на *Middleware* запрос на языке JPQL. Далее рассматриваются особенности формирования таких запросов.

[[datasource_query_results]]
====== Возвращаемые значения

Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте `class` элемента XML, при создании через `DsBuilder` - в методе `setJavaClass()` или `setMetaClass()`.

Например, запрос источника данных типа `Customer` может выглядеть следующим образом:

[source, sql]
----
select c from sales$Customer c
----

или

[source, sql]
----
select o.customer from sales$Order o
----

Запрос не может возвращать агрегированные значения или отдельные атрибуты, например:

[source, sql]
----
select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */
----

[[datasource_query_params]]
====== Параметры запроса

JPQL-запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака "$". Интерпретация имени после "$" рассматривается ниже.

[[datasource_query_params_ds]]
* Префикс `ds`.
+
Значением параметра являются данные другого источника данных, зарегистрированного в этом же `DsContext`. Например:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_6.xml[]
----
+
В данном случае параметром запроса источника данных `ordersDs` будет текущий экземпляр сущности, находящийся в источнике данных `customersDs`. 
+
При использовании параметров с префиксом `ds` между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. 
+
Обратите внимание, что в примере запроса с параметром левой частью оператора сравнения является значение идентификатора `o.customer.id`, а правой - экземпляр `Customer`, содержащийся в источнике `customersDs`. Такое сравнение допустимо, так как при выполнении запроса на *Middleware* реализация интерфейса <<query,Query>>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.
+
В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_7.xml[]
----
+
или
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_8.xml[]
----

[[datasource_query_params_custom]]
* Префикс `custom`.
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного в метод `refresh()` источника данных. Например:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_9.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/datasources_10.java[]
----
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается. 

[[datasource_query_params_param]]
* Префикс `param`.
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного при открытии экрана в метод `init()` <<screen_controller,контроллера>>. Например:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_15.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/datasources_18.java[]
----
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра.

[[datasource_query_params_component]]
* Префикс `component`.
+
Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_11.xml[]
----
+
Путь к компоненту должен включать все вложенные <<frame,фреймы>>.
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту.
+
[TIP]
====
При изменении значения компонента источник данных автоматически не обновляется.
====

[[datasource_query_params_session]]
* Префикс `session`.
+
Значением параметра будет значение атрибута <<userSession,пользовательской сессии>>, указанного в имени параметра.
+
Значение извлекается методом `UserSession.getAttribute()`, поэтому поддерживаются также предопределенные имена атрибутов сессии: 

** `userId` - ID текущего зарегистрированного или замещенного пользователя;

** `userLogin` - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.
+
Пример:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_12.xml[]
----
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается.

[WARNING]
====
Если значение параметра не найдено по правилам, задаваемым префиксом, для данного параметра устанавливается значение `null`. То есть если, например, в запросе указан параметр с именем `++param$some_name++`, а в мэп параметров экрана нет ключа `++some_name++`, то для параметра `++param$some_name++` устанавливается значение `null`.
====

[[datasource_query_filter]]
====== Фильтр запроса

Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.

Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <<gui_Filter,Filter>>.

Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.

В таком фильтре могут быть использованы следующие элементы:

* `filter` - корневой элемент фильтра. Может непосредственно содержать только одно условие.

** `and`, `or` - логические условия, могут содержать любое количество других условий и предложений. 

** `c` - предложение на JPQL, которое добавляется в секцию `where`. Содержит только текст и опционально атрибут `join`, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение `where`. 

Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны `null`. 

[WARNING]
====
В фильтрах запросов можно использовать только <<datasource_query_params_custom,custom>>, <<datasource_query_params_param,param>> и <<datasource_query_params_component,component>> параметры. Параметры <<datasource_query_params_ds,ds>> и <<datasource_query_params_session,session>> не будут работать.
====

Пример:

[source, xml]
----
include::{sourcesdir}/gui/datasources_13.xml[]
----

В данном случае если в метод `refresh()` источника данных переданы параметры `state` и `initiator`, а в визуальном компоненте `barCodeFilterField` установлено некоторое значение, то итоговый запрос примет вид:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

Если же, к примеру, компонент `barCodeFilterField` пуст, а в `refresh()` передан только параметр `initiator`, то запрос получится следующим:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

[[datasource_query_case_insensitive]]
====== Поиск подстроки без учета регистра

В источниках данных можно использовать особенность выполнения JPQL-запросов, описанную для интерфейса `<<query,Query>>` уровня *Middleware*: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)`. Однако, в связи с тем, что значение параметра обычно передается неявно, имеются следующие отличия:

* Префикс `(?i)` нужно указывать не в значении, а перед именем параметра.

* Значение параметра будет автоматически переведено в нижний регистр.

* Если в значении параметра отсутствуют символы `%`, то они будут добавлены в начало и конец.

Для примера рассмотрим обработку следующего запроса:

[source, jpql]
----
select c from sales$Customer c where c.name like :(?i)component$customerNameField
----

В данном случае значение параметра, взятое из компонента `customerNameField`, будет переведено в нижний регистр и обрамлено символами `%`, а затем в базе данных будет выполнен SQL запрос с условием вида `lower(C.NAME) like ?`

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется. 

[[value_datasources]]
===== Value Datasources

Value datasources позволяют выполнять запросы, возвращающие скалярные и агрегатные значения. Например, следующим запросом можно загрузить некоторую агрегатную статистику по покупателям:

[source, sql]
----
select o.customer, sum(o.amount) from demo$Order o group by o.customer
----

Value datasources работают с сущностями особого типа: `KeyValueEntity`. Такая сущность может содержать произвольный набор атрибутов, задаваемый во время работы приложения. Так, в примере выше, экземпляры `KeyValueEntity` будут содержать два атрибута: первый типа `Customer`, второй типа `BigDecimal`.

Реализации value datasources унаследованы от других широко используемых классов источников данных и дополнительно реализуют специфический интерфейс `ValueDatasource`. На диаграмме ниже изображены реализации value datasources и их базовые классы:

image::ValueDatasources.png[align="center"]

Интерфейс `ValueDatasource` содержит следующие методы:

* `addProperty()` - так как источник данных может содержать произвольный набор атрибутов, с помощью данного метода необходимо указать, какие атрибуты ожидаются. Он принимает имя атрибута и его тип в виде <<datatype,Datatype>> или Java-класса. В последнем случае класс должен быть либо сущностью, либо классом, поддерживаемым одним из типов данных (datatypes).

* `setIdName()` - опциональный метод, позволяющий назначить один из атрибутов идентификатором сущности. Это означает, что экземпляры `KeyValueEntity`, содержащиеся в данном источнике данных будут иметь идентификаторы, получаемые из данного атрибута. В противном случае, экземпляры `KeyValueEntity` получают случайно сгенерированные UUIDs.

* `getMetaClass()` возвращает динамическую реализацию интерфейса `MetaClass`, которая представляет текущую схему экземпляров `KeyValueEntity`, заданную вызовами метода `addProperty()`.

Value datasources могут быть заданы декларативно в XML-дескрипторе. Существует три XML-элемента, соответствующих классам реализации:

* `valueCollectionDatasource`
* `valueGroupDatasource`
* `valueHierarchicalDatasource`

XML описание value datasource должно содержать элемент `properties`, который задает атрибуты `KeyValueEntity`, содержащихся в источнике данных (см. метод `addProperty()` выше). Порядок элементов `property` должен соответствовать порядку колонок в результирующем наборе, возвращаемом запросом. Например, в следующем определении атрибут `customer` получит значение из колонки `o.customer`, а атрибут `sum` из колонки `sum(o.amount)`:

[source, xml]
----
include::{sourcesdir}/gui/value_datasources_1.xml[]
----

Value datasources предназначены только для чтения данных, так как сущность `KeyValueEntity` является неперсистентной и не может быть сохранена стандартным механизмом работы с БД.

Value datasource можно создать как вручную, так и с помощью Studio на вкладке *Datasources* дизайнера экранов.

image::ValueDatasources_Studio.png[align="center"]

Окно редактирования атрибутов *Properties* позволяет создать атрибуты источника данных с указанным типом данных и/или Java-класса.

image::ValueDatasources_Studio_properties.png[align="center"]

[[datasource_listeners]]
===== Слушатели источников данных

Слушатели <<datasources,источников данных>> (datasource listeners) позволяют получать оповещения об изменении состояния источников данных и экземпляров сущностей, в них находящихся.

Существует четыре типа слушателей. Три из них: `ItemPropertyChangeListener`, `ItemChangeListener` и `StateChangeListener` определены в интерфейсе `Datasource` и могут быть использованы в любых источниках данных. `CollectionChangeListener` определен в интерфейсе `CollectionDatasource` и может быть использован только в источниках данных, работающих с коллекциями сущностей.

Пример использования слушателей источников данных:

[source, java]
----
include::{sourcesdir}/gui/datasources_14.java[]
----

Интерфейсы слушателей описаны ниже.

* `ItemPropertyChangeListener` добавляется с помощью метода `Datasource.addItemPropertyChangeListener()`. Слушатель вызывается, если изменилось значение какого-либо атрибута сущности, находящейся в данный момент в источнике. Через объект события можно получить сам измененный экземпляр, имя измененного атрибута, старое и новое значение.
+
Слушатель `ItemPropertyChangeListener` можно использовать для действий в ответ на изменение пользователем сущности из UI, то есть редактирования полей ввода.

* `ItemChangeListener` добавляется с помощью метода `Datasource.addItemChangeListener()`. Он вызывается при смене выбранного экземпляра, возвращаемого методом `getItem()`.
+
Для `Datasource` это происходит при установке другого экземпляра (или `null`) методом `setItem()`.
+
Для `CollectionDatasource` данный слушатель вызывается, когда в связанном визуальном компоненте меняется выделенный элемент. Например, это может быть выделенная строка таблицы, элемент дерева, или выделенный элемент выпадающего списка.

* `StateChangeListener` добавляется с помощью метода `Datasource.addStateChangeListener()`. Он вызывается при изменении состояния источника данных. Источник данных может находиться в одном из трех состояний, соответствующих перечислению `Datasource.State`:
+
--
** `++NOT_INITIALIZED++` - источник только что создан.

** `INVALID` - создан весь `<<dsContext,DsContext>>`, к которому относится данный источник.

** `VALID` - источник данных в рабочем состоянии: `Datasource` содержит экземпляр сущности или `null`, `CollectionDatasource` - коллекцию экземпляров или пустую коллекцию.
+
Получение оповещения об изменении состояния источника может быть актуально для сложных <<screen_edit,редакторов>>, состоящих из нескольких <<frame,фреймов>>, где сложно отследить момент проставления редактируемой сущности в источник. В этом случае можно использовать слушатель `StateChangeListener` для отложенной инициализации некоторых элементов экрана:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_17.java[]
----
--

* `CollectionChangeListener` добавляется с помощью метода `CollectionDatasource.addCollectionChangeListener()`. Слушатель вызывается при изменении коллекции сущностей, хранящейся в источнике данных. Объект события имеет метод `getOperation()`, возвращающий значение типа `CollectionDatasource.Operation`: `REFRESH`, `CLEAR`, `ADD`, `REMOVE`, `UPDATE`. Этот тип указывает операцию, которая привела к изменению коллекции.

[[dsContext]]
===== DsContext

Все созданные декларативно источники данных регистрируются в объекте `DsContext` экрана. Ссылку на `DsContext` можно получить методом `getDsContext()` контроллера экрана, либо инжекцией в поле класса.

`DsContext` решает следующие задачи:

. Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении "текущего" экземпляра методом `setItem()`) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между визуальными компонентами.
+
Зависимости между источниками организуются с помощью <<datasource_query,параметров запросов>> с префиксом `ds$`.

. Позволяет собрать все измененные экземпляры сущностей и отправить их на Middleware в одном вызове `DataManager.commit()`, т.е. сохранить в базе данных в одной транзакции.
+
В качестве примера предположим, что некоторый экран позволяет редактировать экземпляр сущности `Order` и коллекцию принадлежащих ему экземпляров `OrderLine`. Экземпляр `Order` находится в `Datasource`, коллекция `OrderLine` - во вложенном `CollectionDatasource`, созданном по атрибуту `Order.lines`. Допустим, пользователь изменил какой-то атрибут `Order` и создал новый экземпляр `OrderLine`. Тогда при коммите экрана в <<dataManager,DataManager>> будут одновременно отправлены два экземпляра - измененный `Order` и новый `OrderLine`. Далее, они вместе попадут в один <<entityManager,персистентный контекст>> и при коммите транзакции сохранятся в БД. Это позволяет не использовать параметров каскадности на уровне ORM и избежать проблем, упомянутых в описании аннотации <<oneToMany_annotation, @OneToMany>>.
+
В результате коммита `DsContext` получает от Middleware набор сохраненных экземпляров (в случае оптимистической блокировки у них, как минимум, увеличено значение атрибута `version`), и устанавливает эти экземпляры в источниках данных взамен устаревших. Это позволяет сразу после коммита работать со свежими экземплярами без необходимости лишнего обновления источников данных, связанного с запросами к Middleware и базе данных.

. Объявляет два слушателя: `BeforeCommitListener` и `AfterCommitListener`, позволяющие получать оповещения перед коммитом измененных экземпляров и после него. Перед коммитом можно дополнить коллекцию отправляемых в <<dataManager,DataManager>> на Middleware экземпляров, тем самым обеспечив сохранение в той же транзакции произвольных сущностей. После коммита можно получить коллекцию вернувшихся из `DataManager` сохраненных экземпляров.
+
Данный механизм необходим, если некоторые сущности, с которыми работает экран, находятся не под управлением источников данных, а создаются и изменяются непосредственно в коде контроллера. Например, визуальный компонент `<<gui_FileUploadField,FileUploadField>>` после загрузки файла создает новый экземпляр сущности `FileDescriptor`, который можно сохранить вместе с другими сущностями экрана именно таким способом - добавив в `CommitContext` в слушателе `BeforeCommitListener`.
+
В следующем примере новый экземпляр `Customer` будет отправлен на Middleware и сохранен в БД вместе с остальными измененными сущностями экрана при его коммите:
+
[source, java]
----
include::{sourcesdir}/gui/dscontext_1.java[]
----

[[dataSupplier]]
===== DataSupplier

`DataSupplier` - интерфейс, через который источники данных обращаются к Middleware для загрузки и сохранения сущностей. Его стандартная реализация просто делегирует выполнение <<dataManager,DataManager>>. Экран может задать свою реализацию интерфейса `DataSupplier` в атрибуте `dataSupplier` элемента `window`.

Ссылку на `DataSupplier` можно получить либо <<screen_controller_injection,инжекцией>> в контроллер экрана, либо через экземпляры `DsContext` или `Datasource`. В обоих случаях возвращается или стандартная, или собственная реализация интерфейса (если таковая определена).

[[gui_Action]]
==== Действия. Интерфейс Action

++++
<div class="manual-live-demo-container">
    <a href="http://files.cuba-platform.com/javadoc/cuba/6.9/com/haulmont/cuba/gui/components/Action.html" class="api-docs-btn" target="_blank">API DOCS</a>
</div>
++++

`Action` − интерфейс, абстрагирующий действие (другими словами, некоторую функцию) от визуального компонента. Он особенно полезен в случаях, когда одно и то же действие может быть вызвано из разных визуальных компонентов. Кроме того, данный интерфейс позволяет снабдить действие дополнительными свойствами, такими как название, признаки доступности и видимости, и другими.

Рассмотрим методы интерфейса `Action`:

* `actionPerform()` - вызывается визуальным компонентом, связанным с данным действием. В метод передается экземпляр вызвавшего компонента.

* `getId()` - возвращает идентификатор данного действия. Идентификатор обычно устанавливается конструктором класса, реализующего `Action`, и не меняется на протяжении жизни созданного объекта действия.

* методы получения и установки свойств `caption`, `description`, `shortcut`, `icon`, `enabled`, `visible`. Все эти свойства обычно используется связанными визуальными компонентами для установки собственных одноименных свойств.

* `addPropertyChangeListener()`, `removePropertyChangeListener()` - подключение слушателей, реагирующих на изменение вышеупомянутых свойств. Слушатель получает уведомление типа `java.beans.PropertyChangeEvent`, в котором содержится имя измененного свойства, его старое и новое значение.

* `refreshState()` - метод, который может быть реализован в конкретном классе действия для инициализации вышеупомянутых свойств в соответствии с какими-либо внешними факторами, например правами пользователя. Вызывается обычно в конструкторах имплементирующих классов или из связанных визуальных компонентов.

* `addOwner()`, `removeOwner()`, `getOwner()`, `getOwners()` - методы для управления связью действия с визуальными компонентами.

Для реализации действий рекомендуется использовать <<declarative_actions,декларативное создание>> действий, либо наследоваться от класса <<baseAction,AbstractAction>>. Кроме того, существует набор <<standard_actions,стандартных действий>>, применимых для работы с таблицами и компонентами выбора. От стандартных действий также можно наследоваться для модификации их поведения или перехвата событий.

Визуальные компоненты, связанные с действием, могут быть двух типов:

* Визуальный компонент, содержащий одно действие, реализует интерфейс `Component.ActionOwner`. Это <<gui_Button,Button>> и <<gui_LinkButton,LinkButton>>.
+
Связь компонента с действием осуществляется путем вызова метода `ActionOwner.setAction()` компонента. В этот момент компонент заменяет свои свойства на соответствующие свойства действия (подробнее см. описание компонентов). 

* Визуальный компонент, содержащий несколько действий, реализует интерфейс `Component.ActionsHolder`. Это `Window`, `Frame`, <<gui_Table,Table>> и ее наследники, <<gui_Tree,Tree>>, <<gui_PopupButton,PopupButton>>, <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>.
+
Действия добавляются компоненту вызовом метода `ActionsHolder.addAction()`. Реализация этого метода в компоненте проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами и добавить компоненту.

[[declarative_actions]]
===== Декларативное создание действий

В XML-дескрипторе экрана для любого компонента, реализующего интерфейс `Component.ActionsHolder`, в том числе для всего экрана или фрейма, может быть задан набор <<gui_Action,действий>>. Делается это в элементе `actions`, который содержит вложенные элементы `action`.

Элемент `action` может иметь следующие атрибуты:

* `id` − идентификатор, должен быть уникален в рамках данного компонента `ActionsHolder`.

* `caption` - название действия.

* `description` - описание действия.

* `enable` - признак доступности действия (`true` / `false`).

* `icon` - значок действия.

* `invoke` - имя вызываемого метода контроллера. Метод должен быть `public`, не возвращать результата и либо не иметь аргументов, либо иметь один аргумент типа `Component`. Если метод имеет аргумент `Component`, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.

* `shortcut` - комбинация клавиш для вызова.
+
--
Комбинации можно жёстко задавать в XML-дескрипторе. Возможные модификаторы - `ALT`, `CTRL`, `SHIFT` - отделяются символом  "-". Например:

[source, xml]
----
<action id="create" shortcut="ALT-N"/>
----

Для большей гибкости можно использовать готовые псевдонимы комбинаций из списка ниже, к примеру:

[source, xml]
----
<action id="edit" shortcut="${TABLE_EDIT_SHORTCUT}"/>
----
** `TABLE_EDIT_SHORTCUT`

** `COMMIT_SHORTCUT`

** `CLOSE_SHORTCUT`

** `FILTER_APPLY_SHORTCUT`

** `FILTER_SELECT_SHORTCUT`

** `NEXT_TAB_SHORTCUT`

** `PREVIOUS_TAB_SHORTCUT`

** `PICKER_LOOKUP_SHORTCUT`

** `PICKER_OPEN_SHORTCUT`

** `PICKER_CLEAR_SHORTCUT`

Кроме того, есть возможность задавать комбинацию с помощью полного имени интерфейса `Config` и имени метода, возвращающего нужную комбинацию:

[source, xml]
----
<action id="remove" shortcut="${com.haulmont.cuba.client.ClientConfig#getTableRemoveShortcut}"/>
----
--

* `visible` - признак видимости действия (`true` / `false`).

Рассмотрим примеры декларативного объявления действий.

* Объявление действий на уровне экрана:
+
[source, xml]
----
<window ...>
  <dsContext/>

  <actions>
      <action id="sayHelloAction" caption="msg://sayHello" shortcut="ALT-T" invoke="sayHello"/>
  </actions>

  <layout>
      <button action="sayHelloAction"/>
  </layout>
</window>
----
+
[source, java]
----
// controller

public void sayHello(Component component) {
  showNotification("Hello!", NotificationType.TRAY);
}
----

Здесь объявляется действие с идентификатором `sayHelloAction` и названием из <<message_packs,пакета сообщений>>. С этим действием связывается кнопка, заголовок которой будет установлен в название действия. Действие вызовет метод `sayHello()` контроллера при нажатии на кнопку, а также при нажатии комбинации клавиш *ALT-T*, если в данный момент экран принимает фокус ввода.

* Объявление действий для <<gui_PopupButton,PopupButton>>:
+
[source, xml]
----
<popupButton caption="Say something">
 <actions>
    <action id="helloAction" caption="Say hello" invoke="sayHello"/>
    <action id="goodbyeAction" caption="Say goodbye" invoke="sayGoodbye"/>
 </actions>
</popupButton>
----

* Объявление действий для <<gui_Table,Table>>:
+
[source, xml]
----
<table id="usersTable" width="100%">
  <actions>
      <action id="create"/>
      <action id="edit"/>
      <action id="copy" caption="msg://copy" icon="COPY"
              invoke="copy" trackSelection="true"/>
      <action id="changePassw" caption="msg://changePassw" icon="EDIT"
              invoke="changePassword" trackSelection="true"/>
  </actions>
  <buttonsPanel>
      <button action="usersTable.create"/>
      <button action="usersTable.edit"/>
      <button action="usersTable.copy"/>
      <button action="usersTable.changePassw"/>
  </buttonsPanel>
  <rowsCount/>
  <columns>
      <column id="login"/>
      ...
  </columns>
  <rows datasource="usersDs"/>
</table>
----

Здесь помимо <<standard_actions,стандартных действий>> таблицы `create` и `edit` объявлены действия `copy` и `changePassw`, вызывающие соответствующие методы контроллера. Для этих действий указан также атрибут `trackSelection="true"`, в результате чего действие и связанная с ним кнопка становятся недоступными, если в таблице не выбрана ни одна строка. Это удобно, если действие предназначено для выполнения над текущей выбранной строкой таблицы. 

Для действий `create` и `edit` можно указать дополнительный атрибут `openType` для указания режима открытия экрана редактирования, как описано для метода `setOpenType()` класса <<createAction,CreateAction>>.

* Объявление действий для <<gui_PickerField,PickerField>>:
+
[source, xml]
----
<pickerField id="colourField" datasource="carDs" property="colour"/>
  <actions>
      <action id="lookup"/>
      <action id="show" icon="PICKERFIELD_LOOKUP"
              invoke="showColour" caption="" description="Show colour"/>
  </actions>
</pickerField>
----

В данном примере для компонента `PickerField` объявлено <<standard_actions,стандартное действие>> `lookup` и действие `show`, вызывающее метод `showColour()` контроллера. Так как в кнопках `PickerField`, отображающих действия, используются значки, а не надписи, атрибут `caption` явно установлен в пустую строку, иначе названием действия и заголовком кнопки стал бы идентификатор действия. Атрибут `description` позволяет отображать всплывающую подсказку при наведении мыши на кнопку действия.

Ссылки на любые декларативно объявленные действия можно получить в контроллере экрана либо непосредственно путем <<screen_controller_injection,инжекции>>, либо из компонентов, реализующих интерфейс `Component.ActionsHolder`. Это может понадобиться для программной установки свойств действия. Например:

[source, java]
----
@Named("carsTable.create")
private CreateAction createAction;

@Named("carsTable.copy")
private Action copyAction;

@Inject
private PickerField colourField;

@Override
public void init(Map<String, Object> params) {
  Map<String, Object> values = new HashMap<>();
  values.put("type", CarType.PASSENGER);
  createAction.setInitialValues(values);

  copyAction.setEnabled(false);

  Action showAction = colourField.getAction("show");
  showAction.setEnabled(false);
}
----

[[standard_actions]]
===== Стандартные действия

Стандартные <<gui_Action,действия>> - это классы, имплементирующие интерфейс `Action`, и предназначенные для решения типовых задач, таких как вызов экрана редактирования для сущности, выбранной в таблице. Стандартные действия имеют строго определенные идентификаторы, поэтому для декларативного объявления некоторого стандартного действия достаточно указать его идентификатор. 

Существует два вида стандартных действий:

* <<list_actions,Действия с коллекцией>> сущностей, отображаемой в таблице или дереве.

* <<picker_actions,Действия поля выбора>> экземпляра сущности.

[[list_actions]]
====== Стандартные действия с коллекцией

Для наследников `ListComponent` (это <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>> и <<gui_Tree,Tree>>) набор стандартных действий определен в перечислении `ListActionType`, классы их реализации находятся в пакете `com.haulmont.cuba.gui.components.actions`. 

Пример использования стандартных действий в таблице: 

[source, xml]
----
include::{sourcesdir}/gui/listActions_1.xml[]
----

Рассмотрим их подробнее.

[[createAction]]
*CreateAction*

`CreateAction` - действие с идентификатором *create*. Предназначено для создания нового экземпляра сущности и открытия экрана редактирования для этого экземпляра. Если экран редактирования успешно закоммитил новый экземпляр в базу данных, то `CreateAction` добавляет этот новый экземпляр в источник данных таблицы и делает его выбранным.

В классе `CreateAction` определены следующие специфические методы: 

* `setOpenType()` - позволяет задать режим открытия экрана редактирования новой сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `create` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/createAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`. Далее эти параметры можно использовать напрямую в <<datasource_query_params_param,запросе источника данных>> через префикс `param$` или <<screen_controller_injection,инжектировать>> в контроллер экрана с помощью аннотации `@WindowParam`.

* `setWindowParamsSupplier()` отличается от `setWindowParams()` тем, что позволяет получить значения параметров непосредственно перед вызовом действия. Полученные параметры объединяются с предоставленными через `setWindowParams()` и могут переопределять их. Например:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_5.java[]
----

* `setInitialValues()` - позволяет задать начальные значения атрибутов создаваемой сущности. Принимает объект `Map`, в котором ключами являются имена атрибутов, а значениями - значения атрибутов. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_2.java[]
---- 
+
Пример использования `setInitialValues()` приведен также в разделе <<init_values_in_CreateAction,рецептов разработки>>.

* `setInitialValuesSupplier()` отличается от `setInitialValues()` тем, что позволяет получить значения параметров непосредственно перед вызовом действия. Полученные параметры объединяются с предоставленными через `setInitialValues()` и могут переопределять их. Например:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_4.java[]
----

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/createAction_6.java[]
----

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_3.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

[[editAction]]
*EditAction*

`EditAction` - действие с идентификатором *edit*. Открывает экран редактирования для выбранного экземпляра сущности. Если экран редактирования успешно закоммитил экземпляр в базу данных, то `EditAction` обновляет этот экземпляр в источнике данных таблицы.

В классе `EditAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `edit` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/editAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`. Далее эти параметры можно использовать напрямую в <<datasource_query_params_param,запросе источника данных>> через префикс `param$` или <<screen_controller_injection,инжектировать>> в контроллер экрана с помощью аннотации `@WindowParam`.

* `setWindowParamsSupplier()` отличается от `setWindowParams()` тем, что позволяет получить значения параметров непосредственно перед вызовом действия. Полученные параметры объединяются с предоставленными через `setWindowParams()` и могут переопределять их. Например:
+
[source, java]
----
include::{sourcesdir}/gui/editAction_4.java[]
----

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/editAction_5.java[]
----

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/editAction_2.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена редактируемая сущность. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

* `getBulkEditorIntegration()` позволяет настроить массовое редактирование строк таблицы, для этого атрибут `multiselect` таблицы должен иметь значение `true`. Компонент <<gui_BulkEditor,BulkEditor>> будет открыт, если при вызове `EditAction` в таблице выделено более одной строки.
+
--
Возвращаемый экземпляр `BulkEditorIntegration` можно изменить с помощью следующих методов:

* `setOpenType()`,

* `setExcludePropertiesRegex()`,

* `setFieldValidators()`,

* `setModelValidators()`,

* `setAfterEditCloseHandler()`.
--
+
[source, java]
----
include::{sourcesdir}/gui/editAction_3.java[]
----

[[removeAction]]
*RemoveAction*

`RemoveAction` - действие с идентификатором *remove*. Предназначено для удаления выбранного экземпляра сущности.

В классе `RemoveAction` определены следующие специфические методы:

* `setAutocommit()` - позволяет управлять моментом удаления сущности из базы данных. По умолчанию после срабатывания действия и удаления сущности из источника данных у источника вызывается метод `commit()`, в результате чего сущность удаляется из базы данных. Cвойство `autocommit` можно установить в `false` либо методом `setAutocommit()`, либо соответствующим параметром конструктора. В результате после удаления сущности из источника данных для подтверждения удаления потребуется явно вызвать метод `commit()` источника данных.
+
Значение `autocommit` не влияет на работу источников данных в режиме `Datasource.CommitMode.PARENT`, то есть тех, которые обеспечивают редактирование <<composition_annotation,композиционных>> сущностей.

* `setConfirmationMessage()` - позволяет задать текст сообщения в диалоге подтверждения удаления. 

* `setConfirmationTitle()` - позволяет задать заголовок диалога подтверждения удаления.

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_2.java[]
----

*  `afterRemove()` - вызывается действием после успешного удаления сущности. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterRemoveHandler()` позволяет задать обработчик, который будет вызван после успешного удаления сущности. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_1.java[]
----  

[[refreshAction]]
*RefreshAction*

`RefreshAction` - действие с идентификатором *refresh*. Предназначено для обновления (перезагрузки) коллекции сущностей. При срабатывании вызывает метод `refresh()` <<datasources,источника данных>>, с которым связан компонент.

В классе `RefreshAction` определены следующие специфические методы:

* `setRefreshParams()` - позволяет задать параметры, передаваемые в метод `CollectionDatasource.refresh()`, для использования внутри <<datasource_query,запроса>>. По умолчанию никакие параметры не передаются. 

* `setRefreshParamsSupplier()` отличается от `setRefreshParams()` тем, что позволяет получить значения параметров непосредственно перед вызовом действия. Полученные параметры объединяются с предоставленными через `setRefreshParams()` и могут переопределять их. Например:
+
[source, java]
----
include::{sourcesdir}/gui/refreshAction_1.java[]
----

[[addAction]]
*AddAction*

`AddAction` - действие с идентификатором *add*. Предназначено для выбора существующего экземпляра сущности и добавления его в коллекцию. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `AddAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны выбора в другом режиме (как правило, `DIALOG`), при декларативном создании действия `add` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:
+
[source, xml]
----
<table id="usersTable">
<actions>
  <action id="add" openType="DIALOG"/>
----

* `setWindowId()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setWindowParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`. Далее эти параметры можно использовать напрямую в <<datasource_query_params_param,запросе источника данных>> через префикс `param$` или <<screen_controller_injection,инжектировать>> в контроллер экрана с помощью аннотации `@WindowParam`.

* `setWindowParamsSupplier()` отличается от `setWindowParams()` тем, что позволяет получить значения параметров непосредственно перед вызовом действия. Полученные параметры объединяются с предоставленными через `setWindowParams()` и могут переопределять их. Например:
+
[source, java]
----
include::{sourcesdir}/gui/addaction_2.java[]
----

* `setHandler()` - позволяет задать объект, реализующий интерфейс `Window.Lookup.Handler`, передаваемый в экран выбора. По умолчанию используется объект класса `AddAction.DefaultHandler`.

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/addaction_3.java[]
----

[[excludeAction]]
*ExcludeAction*

`ExcludeAction` - действие с идентификатором *exclude*. Позволяет исключать экземпляры сущности из коллекции, не удаляя их из базы данных. Класс данного действия является наследником `RemoveAction`, однако при срабатывании вызывает у `CollectionDatasource` не `removeItem()`, а `excludeItem()`. Кроме того, для вложенных источников данных `ExcludeAction` разрывает связь с родительской сущностью, поэтому с помощью данного действия можно организовать редактирование ассоциации one-to-many. 

В классе `ExcludeAction` в дополнение к `RemoveAction` определены следующие специфические методы:

* `setConfirm()` - показывать ли диалог подтверждения удаления. Это свойство можно также установить через конструктор действия. По умолчанию установлено в `false`.

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/excludeAction.java[]
----

[[excelAction]]
*ExcelAction*

`ExcelAction` - действие с идентификатором *excel*. Предназначено для экспорта данных таблицы в формат XLS и выгрузки соответствующего файла. Данное действие можно связать только с компонентами <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>> и <<gui_TreeTable,TreeTable>>.

При программном создании действия можно задать параметр конструктора `display`, передав реализацию интерфейса `ExportDisplay` для выгрузки файла. По умолчанию используется стандартная реализация.

В классе `ExcelAction` определены следующие специфические методы:

* `setFileName()`  - позволяет задать имя выгружаемого файла Excel без расширения.

* `getFileName()` - возвращает имя выгружаемого файла Excel без расширения.

* `setBeforeActionPerformedHandler()` позволяет задать обработчик, который будет вызван до выполнения действия. Если метод возвращает `true`, действие будет выполнено, если `false` - отменено. Например:
+
[source, java]
----
include::{sourcesdir}/gui/excelAction.java[]
----

[[picker_actions]]
====== Стандартные действия поля выбора

Для компонентов <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>> и <<gui_SearchPickerField,SearchPickerField>> набор стандартных действий определен в перечислении `PickerField.ActionType`. Реализации являются внутренними классами интерфейса `PickerField`.

Пример использования стандартных действий в компоненте выбора: 

[source, xml]
----
include::{sourcesdir}/gui/pickerActions_1.xml[]
---- 

[[lookupAction]]
*LookupAction*

`LookupAction` - действие с идентификатором *lookup*. Предназначено для выбора экземпляра сущности и установки его в качестве значения компонента. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `LookupAction` определены следующие специфические методы:

* `setLookupScreenOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setLookupScreen()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setLookupScreenParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`.

* `afterSelect()` - вызывается действием после того, как выбранный экземпляр установлен в качестве значения компонента. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `afterCloseLookup()` - вызывается действием в последнюю очередь после закрытия экрана выбора, независимо от того, был сделан выбор или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие.  

[[clearAction]]
*ClearAction*

`ClearAction` - действие с идентификатором *clear*. Предназначено для очистки (то есть установки в `null`) текущего значения компонента. 

[[openAction]]
*OpenAction*

`OpenAction` - действие с идентификатором *open*. Предназначено для открытия экрана редактирования экземпляра сущности, являющегося текущим значением компонента. 

В классе `OpenAction` определены следующие специфические методы:

* `setEditScreenOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setEditScreen()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setEditScreenParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `afterWindowClosed()` - вызывается действием после закрытия экрана редактирования. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

[[baseAction]]
===== BaseAction

`BaseAction` - базовый класс реализации <<gui_Action,действий>>. От него рекомендуется наследовать собственные нестандартные действия, если возможностей <<declarative_actions,декларативного создания действий>> не хватает. 

При создании конкретного класса действия необходимо определить метод `actionPerform()` и передать в конструктор `BaseAction` идентификатор действия. Можно также переопределить любые методы получения свойств действия: `getCaption()`, `getDescription()`, `getIcon()`, `getShortcut()`, `isEnabled()`, `isVisible()`. Стандартные реализации этих методов возвращают значения, установленные соответствующими set-методами. Исключение составляет метод `getCaption()`: если название действия явно не установлено методом `setCaption()`, то он обращается в <<message_packs,пакет локализованных сообщений>> с именем, соответствующим пакету класса действия, и возвращает сообщение с ключом, равным идентификатору действия. Если сообщения с таким ключом нет, то возвращается сам ключ, то есть идентификатор действия. 

В качестве альтернативы переопределению методов можно использовать fluent interface для установки свойств и lambda expression для предоставления кода обработки действия: см. методы  `withXYZ()`.

`BaseAction` может изменять свои свойства `enabled` и `visible` в соответствии с <<permissions,разрешениями>> пользователя и текущим контекстом.

`BaseAction` видим (visible), если: 

* метод `setVisible(false)` не вызывался;

* для действия не установлено UI разрешение `hide`.

Действие разрешено (enabled), если: 

* метод `setEnabled(false)` не вызывался;

* для действия не установлено UI разрешений `hide` или `read-only`;

* метод `isPermitted()` возвращает true;

* метод `isApplicable()` возвращает true. 

Примеры использования:

* Действие кнопки: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_1.java[]
----
+
В данном случае кнопка `helloBtn` получит в качестве заголовка строку, находящуюся в пакете сообщений с ключом `hello`. Для того, чтобы получить название кнопки каким-либо иным способом, можно переопределить метод `getCaption()` действия.

* Действие кнопки программно создаваемого <<gui_PickerField,PickerField>>:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_2.java[]
----
+
Здесь анонимный класс-наследник `BaseAction` используется для задания действия кнопки поля выбора. Заголовок кнопки не отображается, вместо него используется значок и описание, всплывающее при наведении курсора мыши.

* Действие таблицы:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_3.java[]
----
+
Здесь объявлен класс `HelloAction`, экземпляр которого добавляется в список действий таблицы. Действие разрешено пользователям, имеющим специфическое разрешение `*myapp.allow-greeting*`, и только когда выбрана одна строка таблицы. Последнее условие реализуется с помощью свойства `target` действия, которое автоматически устанавливается когда действие добавляется в `ListComponent` (`Table` или `Tree`).

* Если необходимо действие, которое доступно, когда выделены одна или более строк таблицы, удобно воспользоваться наследником `BaseAction` - классом `ItemTrackingAction`, который добавляет стандартную реализацию метода `isApplicable()`: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_4.java[]
----

[[dialogs_and_notifications]]
==== Диалоговые окна и уведомления

Для вывода сообщений пользователю можно использовать диалоговые окна и уведомления. 

Диалоговые окна имеют заголовок с кнопкой закрытия и отображаются всегда в центре главного окна приложения. Уведомления могут отображаться как в центре, так и в углу приложения, и автоматически исчезать.

[[dialogs]]
===== Диалоговые окна

Диалоги общего назначения::
+
--
Диалоговые окна общего назначения вызываются методами `showMessageDialog()` и `showOptionDialog()` интерфейса `Frame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данные методы можно вызывать напрямую в коде контроллера.

[[dialogs_showMessageDialog]]
* `showMessageDialog()` предназначен для отображения сообщения. Метод принимает следующие параметры:

** `title` - заголовок диалогового окна.

** `message` - сообщение. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки. 

** `messageType` - тип сообщения. Возможные типы:

*** `CONFIRMATION`, `++CONFIRMATION_HTML++` - диалог подтверждения. 

*** `WARNING`, `++WARNING_HTML++` - диалог преупреждения.
+
Различие типов сообщений отражается только в пользовательском интерфейсе десктоп-приложений.
+
Типы сообщений могут быть установлены с параметрами:
+
**** `width` - ширина диалога,
+
**** `modal` - модальность диалога,
+
**** `maximized` - должен ли диалог быть развёрнут во весь экран,
+
**** `closeOnClickOutside` - возможность закрыть диалог кликом по любой области за его пределами.
+
Пример вызова диалога:
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_1.java[]
----

[[dialogs_showOptionDialog]]
* `showOptionDialog()` предназначен для отображения сообщения и кнопок для выбора пользователем. Метод в дополнение к параметрам, описанным для `showMessageDialog()`, принимает массив или список <<gui_Action,действий>>. Для каждого действия в диалоге создается кнопка, при нажатии на которую пользователем диалог закрывается и вызывается метод `actionPerform()` данного действия.
+
В качестве кнопок со стандартными названиями и значками удобно использовать анонимные классы, унаследованные от `DialogAction`. Поддерживаются пять видов действий, определяемых перечислением `DialogAction.Type`: `OK`, `CANCEL`, `YES`, `NO`, `CLOSE`. Названия соответствующих кнопок извлекаются из <<main_message_pack,главного пакета>> локализованных сообщений.
+
Пример вызова диалога с кнопками *Да* и *Нет* и с заголовком и сообщением, взятыми из пакета локализованных сообщений текущего экрана:
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_2.java[]
----
+
Параметр `Status` конструктора `DialogAction` используется для определения визуального стиля кнопки, к которой привязано данное действие. Статус `Status.PRIMARY` подсвечивает кнопку и задаёт ей выделение по умолчанию. Параметр `Status` можно не использовать, в этом случае используется подсветка кнопок по умолчанию.  Если в `showOptionDialog` передано несколько действий с `Status.PRIMARY`, то фокус и стиль получает только кнопка первого такого действия в списке.
--

[[dialogs_fileUploadDialog]]
Диалог загрузки файлов::
+
--
Диалоговое окно `FileUploadDialog` предоставляет базовую функциональность загрузки файлов в <<file_upload,промежуточное хранилище>>. Оно содержит drop zone для перетаскивания файлов извне браузера и кнопку загрузки файла.

image::gui_fileUploadDialog.png[align="center"]

Открыть диалог можно с помощью метода `openWindow()`, в случае успешной загрузки окно будет закрыто с `COMMIT_ACTION_ID`. Закрытие диалога можно отслеживать с помощью слушателей `CloseListener` и `CloseWithCommitListener`. Чтобы получить UUID и имя загруженного файла, используйте методы `getFileId()` и `getFileName()`. Затем для файла можно, например, создать `FileDescriptor`, позволяющий ссылаться на него из объектов модели данных, или реализовать другую логику.

[source, java]
----
include::{sourcesdir}/gui/dialogs_3.java[]
----
--

[[notifications]]
===== Уведомления

Уведомления вызываются методом `showNotification()` интерфейса `Frame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данный метод можно вызывать напрямую в коде контроллера.

Метод `showNotification()` принимает следующие параметры:

* `caption` - текст уведомления. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки.

* `description` - опциональное описание, которое будет отображено ниже `caption`. Также можно использовать символы `\n` или HTML-форматирование.

* `type` - тип уведомления. Возможные типы:

** `TRAY`, `++TRAY_HTML++` - уведомление показывается в правом нижнем углу приложения и исчезает автоматически. 

** `HUMANIZED`, `++HUMANIZED_HTML++` - стандартное уведомление в центре экрана, исчезает автоматически.

** `WARNING`, `++WARNING_HTML++` - предупреждение. Исчезает при клике пользователя.

** `ERROR`, `++ERROR_HTML++` - уведомление об ошибке. Исчезает при клике пользователя.

Примеры вызова уведомлений:

[source, java]
----
showNotification(getMessage("selectBook.text"), NotificationType.HUMANIZED);

showNotification("Validation error", "<b>Date</b> is incorrect", NotificationType.TRAY_HTML);
----

[[background_tasks]]
==== Фоновые задачи

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=normal-progressbar" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Механизм фоновых задач предназначен для асинхронного выполнения длительных операций на клиентском уровне без заморозки пользовательского интерфейса.

Использование фоновых задач:

. Задача описывается как наследник абстрактного класса `BackgroundTask`. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.
+
Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.
+
Собственно действия, выполняемые задачей, реализуются в методе <<background_tasks_run,run()>>.

. Создается объект управления задачей − `BackgroundTaskHandler`. Для этого экземпляр задачи необходимо передать методу `handle()` бина `BackgroundWorker`. Ссылку на `BackgroundWorker` можно получить инжекцией в <<screen_controller,контроллер экрана>>, либо статическим методом класса `AppBeans`.

. Выполняется запуск задачи.

Пример:

[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Подробная информация о назначении методов приведена в JavaDocs классов `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler`. 

Ниже приведены моменты, на которые следует обратить внимание:

* `BackgroundTask<T, V>` − параметризованный класс:

** `T` − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод `progress()` задачи при вызове `TaskLifeCycle.publish()` в рабочем потоке.

** `V` − тип результата задачи, он передается в метод `done()`. Его также можно получить вызовом метода `BackgroundTaskHandler.getResult()`, что приведет к ожиданию завершения задачи.

* Метод `canceled()` вызывается только в случае управляемой отмены задачи, то есть при вызове `cancel()` у `TaskHandler`.

* Метод `handleTimeoutException()` вызывается при истечении таймаута задачи. Если окно, в котором выполняется задача, закрывается, то задача останавливается без оповещения.

[[background_tasks_run]]
* Метод `run()` задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг `TaskLifeCycle.isInterrupted()`, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение `InterruptedException` (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.
+
** Метод `isCancelled()` возвращает `true`, если задача была прервана вызовом метода `cancel()`.
+
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_2.java[]
----

* Объекты `BackgroundTask` не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.

* Объект `BackgroundHandler` можно запускать (т.е. вызывать его метод `execute()`) всего один раз. Если требуется частый перезапуск задачи, то используйте класс `BackgroundTaskWrapper`.

* Для показа пользователю модального окна с прогрессом и кнопкой *Отмена* используйте классы `BackgroundWorkWindow` или `BackgroundWorkProgressWindow` с набором статических методов.Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.

* Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в методе `getParams()`, который выполняется в потоке UI один раз при запуске задачи. В методе run() эти параметры будут доступны через метод `getParams()` объекта `TaskLifeCycle`.

* При возникновении исключительных ситуаций в потоке UI вызывается метод `BackgroundTask.handleException()`, в котором можно отобразить ошибку.

* На выполнение фоновых задач влияют свойства приложения <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> и <<cuba.backgroundWorker.timeoutCheckInterval,cuba.backgroundWorker.timeoutCheckInterval>>.

[WARNING]
====
В блоке Web Client фоновые задачи используют технологию HTTP push, предоставляемую фреймворком Vaadin. См. https://vaadin.com/wiki/-/wiki/Main/Working+around+push+issues для получения информации о настройке веб-серверов для использования данной технологии.
====

[TIP]
====
Если вы не используете фоновую задачу, но хотите изменять состояние UI-компонентов из не-UI потока, воспользуйтесь методами интерфейса `UIAccessor`. Получите ссылку на интерфейс `UIAccessor` методом `BackgroundWorker.getUIAccessor()` в UI-потоке, и после этого вы сможете вызывать его методы `access()` и `accessSynchronously()` из фонового потока для безопасного чтения и изменения состояния UI-компонентов.
====

[[gui_themes]]
==== Темы приложения

Тема служит для управления визуальным представлением приложения. 

[[web_theme]]
===== Тема в веб-приложениях

Тема веб-приложения состоит из файлов link:http://sass-lang.com[SCSS] и других ресурсов, в том числе файлов изображений.

[[web_theme_usage]]
====== Использование существующих тем

Платформа включает в себя две готовые темы: Halo и Havana. Приложение будет по умолчанию использовать ту из них, которая указана в свойстве приложения <<cuba.web.theme,cuba.web.theme>>. Пользователь может выбрать другую доступную тему в стандартном экране *Help* → *Settings*. Если вы не хотите, чтобы пользователи имели возможность сами выбирать тему, зарегистрируйте экран `settings` в файле <<screens.xml,web-screens.xml>> проекта с параметром `changeThemeEnabled = false`:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_1.xml[]
----

[[web_theme_extension]]
====== Расширение существующей темы

Существующая в платформе тема может быть изменена в проекте приложения. В измененной теме можно сделать следующее:

* Изменить изображения для фирменного стиля.

* Добавить изображения для использования в визуальных компонентах.

* Создать новые стили и использовать их в атрибутах <<gui_attr_stylename,stylename>> визуальных компонентов. Для этого требуется знание CSS.

* Изменить существующие в платформе стили компонентов.

* Изменить общие параметры, такие как цвет фона, отступы, промежутки и т.д.

Тема описывается в файлах link:$$http://sass-lang.com$$[SCSS]. Для изменения (расширения) темы в проекте необходимо создать специальную файловую структуру в модуле *web*. Это удобно сделать с помощью *CUBA Studio*: откройте секцию *Project properties* и нажмите ссылку *Create theme extension*. В диалоговом окне выберите тему, которую вы хотите расширить. В результате в проекте будет создана следующая структура каталогов (для расширения темы Halo):

[source, plain]
----
include::{sourcesdir}/gui/themes/themes_42.scss[]
----

Кроме того, скрипт сборки <<build.gradle,build.gradle>> будет дополнен задачей `buildScssThemes`, автоматически запускаемой при сборке модуля *web*. Опциональная задача <<build.gradle_deployThemes,deployThemes>> может быть использована для быстрого применения изменений в темах на работающем приложении.

[TIP]
====
Если ваше приложение включает в себя <<app_components,компонент>> с расширением темы и вы хотите применить это расширение ко всему приложению, в этом случае необходимо создать расширение темы и для базового проекта. Подробнее о наследовании тем смотрите в разделе <<web_theme_inheritance,Наследование тем из компонентов приложения>>.
====

[[web_theme_extension_branding]]
Изменение фирменного стиля::
+
--
Можно настроить некоторые параметры фирменного стиля (branding): значки и заголовки окна логина и главного окна, значок вебсайта `favicon.ico`.

Для использования собственных изображений, замените соответствующие файлы в каталоге `modules/web/themes/halo/branding`.

Чтобы задать заголовки главного окна, окна логина и текст приглашения окна логина, в CUBA Studio откройте *Project properties* → *Edit* и нажмите кнопку *Branding* внизу страницы. Используйте соответствующие ссылки для задания заголовков окон и текста приглашения окна логина.

Данные параметры сохраняются в <<main_message_pack,главном пакете сообщений>> модуля *web* (то есть в файле `modules/web/<root_package>/web/messages.properties` и его вариантах для разных локалей). Использование пакетов сообщений дает возможность использовать разные файлы изображений для разных локалей пользователей. Пример содержимого файла `messages.properties`:

[source, properties]
----
include::{sourcesdir}/gui/themes/themes_43.scss[]
----

Путь к `favicon.ico` указывать не нужно, он должен обязательно находится в корне каталога с именем темы.
--

[[web_theme_extension_fonts]]
Добавление шрифтов::
+
--
В приложение можно добавить собственные шрифты. Для добавления семейства шрифтов импортируйте его в первой строке файла `styles.scss`, например:

[source, properties]
----
@import url(http://fonts.googleapis.com/css?family=Roboto);
----
--

[[web_theme_extension_styles]]
Создание новых стилей::
+
--
Рассмотрим пример установки желтого цвета фона для поля, отображающего название заказчика.

В XML-дескрипторе экрана определен компонент <<gui_FieldGroup,FieldGroup>>:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_20.xml[]
----

Элементы `field` компонента `FieldGroup` не имеют атрибута <<gui_attr_stylename,stylename>>, поэтому необходимо задать имя стиля в контроллере:

[source, java]
----
include::{sourcesdir}/gui/themes/themes_21.java[]
----

В файле `halo-ext.scss` добавьте определение нового стиля в mixin `halo-ext`:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_22.scss[]
----

После пересборки проекта поля будут выглядеть следующим образом:

image::gui_themes_fieldgroup_1.png[align="center"]
--

Изменение существующих стилей компонентов::
+
--
Для изменения параметров стиля существующих компонентов необходимо добавить соответствующий код CSS в mixin `halo-ext` файла `halo-ext.scss`. Например, для того, чтобы пункты главного меню отображались жирным шрифтом, содержимое файла `halo-ext.scss` должно быть следующим:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_6.scss[]
----
--

[[web_theme_extension_common]]
Изменение общих параметров::
+
--
Темы содержат переменные SCSS, которые управляют цветом фона, размерами компонентов, отступами и пр.

Рассмотрим пример расширения темы Halo, так как она основана на теме link:https://vaadin.com/valo[Valo] фреймворка *Vaadin*, и предоставляет максимальные возможности адаптации.

Файл `themes/halo/halo-ext-defaults.scss` предназначен для размещения в нем переменных темы. Большинство переменных Halo соответствует описанным в link:https://vaadin.com/api/valo[документации по Valo], ниже приведены основные:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_4.scss[]
----

Пример содержимого файла `halo-ext-defaults.scss` для темы с темным фоном и немного уменьшенными отступами:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_5.scss[]
----
--

[[web_theme_migration]]
Переход с темы Havana на полнофункциональную Halo::
+
--
Тема Halo лучше поддаётся расширению, в ней поддерживаются новые визуальные компоненты, такие как <<gui_DataGrid,DataGrid>> и <<gui_SideMenu,SideMenu>>. Если вы хотите использовать эти компоненты, а также получать обновления библиотеки визуальных компонентов, рекомендуется использовать тему  Halo. В то же время, если вам важно сохранить внешний вид темы Havana, вы можете использовать следующие переменные в файле `halo-ext-defaults.scss`:

[source, css]
----
include::{sourcesdir}/gui/themes/themes_23.scss[]
----
--

Изменение заголовка приложения::
+
--
Тема Halo поддерживает свойство приложения <<cuba.web.useInverseHeader,cuba.web.useInverseHeader>>, управляющее цветом заголовка приложения. По умолчанию это свойство установлено в `true`, что задает темный (инверсный) заголовок. В проекте можно не изменяя темы сделать заголовок светлым, установив данное свойство в `false`.
--

[[web_theme_creation]]
====== Создание новой темы

В проекте можно создать одну или несколько новых тем и дать возможность пользователям выбирать среди них подходящую. Создание новой темы позволяет также переопределять переменные файла `*-theme.properties`, задающие некоторые параметры, требуемые на стороне сервера:

--
* Размеры диалоговых окон по умолчанию.

* Ширина полей ввода по умолчанию.

* Размеры некоторых компонентов (<<gui_Filter,Filter>>, <<gui_FileMultiUploadField,FileMultiUploadField>>).

* Соответствие между именами значков и именами констант перечисления `com.vaadin.server.FontAwesome` для использования элементов шрифта *Font Awesome* в стандартных действиях и экранах платформы при включенном свойстве <<cuba.web.useFontIcons,cuba.web.useFontIcons>>.
--

Создание новой темы::
+
--
Рассмотрим пример создания на основе Halo новой темы Facebook, напоминающей интерфейс сайта известной социальной сети.

. В *CUBA Studio* откройте секцию *Project Properties* и нажмите ссылку *Create custom theme*. В диалоговом окне введите имя новой темы - `facebook`, выберите `halo` базовой темой и нажмите *Create*. В проекте будет создана структура новой темы:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_25.scss[]
----
+
Файл `styles.scss` содержит список ваших тем:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_7.scss[]
----
+
Содержимое файла `facebook.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_8.scss[]
----
+
Содержимое файла `app-component.scss` из каталога `com.haulmont.cuba`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_24.scss[]
----

. Теперь отредактируйте переменные темы в файле `facebook-defaults.scss`. Это можно сделать в Studio, нажав *Manage theme > Edit Facebook theme variables*, или в IDE:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_9.scss[]
----

. При необходимости, в файле `facebook-theme.properties` в подкаталоге `src` модуля *web* можно переопределять server-side переменные темы, заданные в файле `halo-theme.properties` платформы.


. Новая тема была автоматически добавлена в файл `web-app.properties`:
+
[source, properties]
----
cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties /com/company/application/web/facebook-theme.properties
----
+
Свойство приложения <<cuba.themeConfig,cuba.themeConfig>> определяет, какие темы будут доступны в меню приложения *Settings*.

. Пересоберите приложение и запустите сервер. Теперь при первом входе пользователь увидит приложение в теме Facebook, и в окне *Help* → *Settings* сможет выбирать между темами *Facebook*, *Halo* и *Havana*.
--

Изменение server-side параметров темы::
+
--
В теме Halo по умолчанию (при включенном свойстве приложения <<cuba.web.useFontIcons,cuba.web.useFontIcons>>) значки стандартных действий и экранов платформы загружаются из шрифта *Font Awesome*. В этом случае можно заменить стандартный значок, задав в файле `<your_theme>-theme.properties` нужное соответствие между именем значка и именем элемента шрифта. Например, чтобы использовать значок "плюс" для действия `create` в новой теме Facebook, содержимое файла `web/src/facebook-theme.properties` должно быть следующим:

[source, properties]
----
@include=halo-theme.properties

cuba.web.icons.create.png = font-icon:PLUS
----

Фрагмент стандартного экрана списка пользователей в теме Facebook и с измененным значком действия `create`:

image::gui_theme_facebook_1.png[align="center"]
--

[[web_theme_inheritance]]
====== Наследование тем из компонентов приложения

Если ваш проект включает в себя <<app_components,компонент>> с новой темой, вы можете настроить использование этой темы во всём проекте.

Чтобы использовать тему из компонента без изменений, просто добавьте её в свойство приложения <<cuba.themeConfig,cuba.themeConfig>>:

[source, plain]
----
cuba.web.theme = {theme-name}
cuba.themeConfig = havana-theme.properties halo-theme.properties /com/company/{app-component-name}/{theme-name}-theme.properties
----

Однако, чтобы переопределить некоторые переменные из родительской темы, сначала необходимо создать расширение темы в основном проекте.

В этом примере мы вновь используем тему `facebook` из предыдущего примера.

. Создайте тему `facebook` для компонента приложения, следуя инструкции из раздела <<web_theme_creation>>.

. Установите компонент, используя меню Studio, как описано в разделе <<app_components_sample>>.

. Расширьте тему `halo` в проекте, в котором используется ваш компонент.

. В IDE переименуйте все вхождения `halo` в каталоге `themes`, включая имена файлов, в `facebook`. В итоге у вас должна получиться следующая структура:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_28.scss[]
----

. Файл `app-component.scss` группирует модификации темы в конкретном компоненте приложения. В процессе сборки SCSS плагин Gradle автоматически находит компоненты и включает их в генерируемый файл `modules/web/build/themes-tmp/VAADIN/themes/{theme-name}/app-components.scss`.
+
По умолчанию переменные темы из `{theme-name}-ext-defaults` не наследуются в проект. Чтобы изменить это поведение, вручную добавьте включение в файл `app-component.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_29.scss[]
----
+
На этом этапе тема `facebook` уже импортирована в проект из компонента приложения.

. Теперь вы можете использовать файлы `facebook-ext.scss` и `facebook-ext-defaults.scss` из пакета `com.company.application`, чтобы переопределить переменные темы компонента и модифицировать её для конкретного проекта.

. Добавьте свойства приложения в файл `web-app.properties`, чтобы сделать тему `facebook` доступной в меню приложения *Settings*. Используйте относительный путь для ссылки на файл `facebook-theme.properties`.
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_30.scss[]
----

[TIP]
====
Если при сборке тем возникли проблемы, проверьте каталог `modules/web/build/themes-tmp`. В нём находятся генерируемые файлы и включения `app-component.scss`, которые можно использовать для поиска проблем компиляции SCSS.
====

[[web_theme_reusable]]
====== Повторное использование тем

Любую тему можно создать и использовать отдельно от <<web_theme_inheritance,компонента приложения>>. Для создания темы, которую можно использовать повторно, необходимо создать с нуля отдельный Java-проект и собрать его в единый JAR-файл. Ниже приведена инструкция, как подготовить тему `facebook` из предыдущих примеров для многократного использования.

. Создайте в IDE новый Java-проект, содержащий файлы SCSS и свойства темы, со следующей структурой:
+
--
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_31.scss[]
----

Этот проект также доступен на https://github.com/cuba-labs/halo-facebook[GitHub].

* содержание скрипта `build.gradle`:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_32.groovy[]
----

* содержание файла `settings.gradle`:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_33.groovy[]
----

* содержание файла `app-component.scss`:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_34.scss[]
----

* содержание файла `halo-facebook.scss`:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_35.scss[]
----

* содержание файла `halo-facebook-defaults.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes/themes_36.css[]
----

* содержание файла `halo-facebook-theme.properties`:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_37.scss[]
----
--

. Соберите и установите проект с помощью задачи Gradle:
+
[source, plain]
----
gradle assemble install
----

. Теперь добавьте эту тему в свой CUBA-проект в качестве зависимости Maven в двух конфигурациях: themes и compile, добавив в `build.gradle` следующие строки:
+
[source, groovy]
----
include::{sourcesdir}/gui/themes/themes_38.groovy[]
----
+
Если вы установили тему локально, не забудьте добавить локальный репозиторий Maven к списку используемых в проекте репозиториев. Для этого перейдите на вкладку *Advanced* в окне Studio *Project Properties* и установите флажок *Use local Maven repository*.

. Чтобы унаследовать тему и добавить модификации для конкретного проекта, необходимо сначала расширить эту тему. Расширьте тему `halo` и переименуйте каталог `themes/halo` в `themes/halo-facebook`:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_39.scss[]
----

. Внесите следующие изменения в файл `styles.scss`:
+
[source, scss]
----
include::{sourcesdir}/gui/themes/themes_40.scss[]
----

. Последним шагом будет добавление ссылки на `halo-facebook-theme.properties` в файле `web-app.properties`:
+
[source, plain]
----
include::{sourcesdir}/gui/themes/themes_41.scss[]
----

Теперь тема `halo-facebook` будет доступна в меню приложения *Help* > *Settings*. Вы также можете установить тему по умолчанию, используя свойство приложения `cuba.web.theme`.

[[desktop_theme]]
===== Темы в десктоп-приложениях

В десктоп-приложениях базовой темой является тема `Nimbus`.

Для внесения изменения в стандартную тему нужно создать пакет `res.nimbus` в пакете `com.sample.sales.desktop` модуля *desktop*. В пакете `res.nimbus` будут храниться файлы темы.

image::gui_themes_desktop_structure.png[align="center"]

В папке `icons` хранятся файлы значков, в файле `nimbus.xml` − описание стиля темы.

В <<app_properties,файле свойств>> для десктоп-приложения нужно установить свойство `cuba.desktop.resourceLocations` (задает набор директорий, в которых расположены файлы стилей):

[source, properties]
----
cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res
----

Ниже приведены примеры решения типовых задач.

Добавление значков::
+
--
Если в десктоп-приложении требуется добавить новый значок, например, для кнопки, нужно создать пакет `res.nimbus.icons` в пакете `com.sample.sales.desktop` модуля *desktop* и поместить в него требуемое изображение.

image::gui_themes_example4.png[align="center"]

Описываем <<gui_Button,кнопку>> в <<screen_xml_glossentry,дескрипторе>>, указывая в атрибуте <<gui_attr_icon,icon>> путь до значка:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_10.xml[]
----

Ниже представлена кнопка со значком `attention.png`

image::gui_themes_example5.png[align="center"]
--

Переопределение значений свойств темы, установленных по умолчанию::
+
--
Рассмотрим на примере изменения цвета фона текстовых полей, обязательных для ввода.

В пакете `res.nimbus` нужно создать файл `nimbus.xml` следующего содержания:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_11.xml[]
----

Элемент `ui-defaults` служит для переопределения значений свойств темы платформы, установленных по умолчанию.

В элементе `ui-defaults` присутствуют как свойства, содержащиеся в стандартной теме `Nimbus` (link:$$http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html$$[http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html]), так и свойства, созданные в платформе.

В данном примере переопределено значение свойства платформы `cubaRequiredBackground`, хранящего цвет фона поля, обязательного для заполнения. Данное изменение коснется всех полей, обязательных для ввода.Переопределение значений свойств темы, установленных по умолчанию.
--

Создание стиля для элемента с помощью стандартных средств::
+
--
Рассмотрим пример выделения надписи жирным цветом.

Для того чтобы создать такой стиль, необходимо определить элемент `style` в файле темы `nimbus.xml` следующим образом:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_12.xml[]
----

Элемент `style` может содержать другие элементы, в которых можно определять те или иные свойства: `background`, `foreground`, `icon`.

В описании компонента надписи в <<screen_xml_glossentry,xml-дескрипторе>>, к которой нужно применить созданный стиль, нужно указать атрибут <<gui_attr_stylename,stylename>> с именем стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_13.xml[]
----

Таким образом, данный стиль будет применен только к тем надписям, для которых определен атрибут <<gui_attr_stylename,stylename>> со значением `boldlabel`.
--

Создание пользовательского стиля::
+
--
Если не хватает стандартных средств изменения стиля компонента, есть возможность создать пользовательский стиль. 

Создадим пользовательский стиль, который будет применяться для компонента <<gui_Button,Button>>. С помощью стиля надпись на кнопке будет отображаться подчеркнутой.

В первую очередь создадим класс-декоратор `UnderlinedLabelDecorator`:

[source, java]
----
include::{sourcesdir}/gui/themes/themes_14.java[]
----

Определим пользовательский стиль в файле `nimbus.xml`:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_15.xml[]
----

В атрибуте `component` элемента `style` содержится название компонента, к которому может быть применен стиль с названием `button-underlined`.

В элементе `custom` указывается путь до класса-декоратора, определенного ранее.

При создании XML-элемента кнопки, к которой нужно применить пользовательский стиль, нужно в атрибуте `stylename` указать название стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes/themes_16.xml[]
----

Кнопка с пользовательским стилем:

image::gui_themes_example6.png[align="center"]
--

[[gui_icons]]
==== Значки

В расширенную тему можно также добавить файлы значков для использования в свойствах <<gui_attr_icon,icon>> <<gui_Action,действий>> и визуальных компонентов, например <<gui_Button,Button>>.

Например, чтобы добавить в расширение темы Halo значок, достаточно в описанный в разделе <<web_theme_extension>> каталог `modules/web/themes/halo` добавить файл значка (желательно в некоторый подкаталог):

[source, plain]
----
themes/
  halo/
    icons/
      cool-icon.png
----

В следующих разделах рассматривается использование значков в визуальных компонентах и добавление значков из произвольных библиотек шрифтов.

[[icon_set]]
===== Наборы значков

Наборы значков (icon sets) позволяют отвязать использование значков в визуальных компонентах от конкретных путей к изображениям в теме или констант элементов шрифтов. Кроме того, они упрощают переопределение значков, используемых в UI, унаследованном от компонентов приложения.

Наборы значков - это перечисления (enumerations), каждый элемент которых соответствует некоторому значку. Класс перечисления должен реализовывать интерфейс `Icons.Icon` с единственным параметром - строкой, задающей источник получения значка, например, `font-icon:CHECK` или `icons/myawesomeicon.png`. Для получения источника значка следует использовать бин платформы `Icons`.

Чтобы наборы значков были доступны из модулей *desktop* и *web*, их следует создавать в модуле *gui* приложения. В случае, если вы планируете использовать только модуль *web*, наборы значков можно создавать в веб-модуле. Имена элементов перечисления в наборе должны соответствовать регулярному выражению `[A-Z]_`, то есть содержать только заглавные буквы и нижнее подчёркивание.

Пример набора значков:

[source, java]
----
public enum MyIcon implements Icons.Icon {

    // adding new icon
    COOL_ICON("icons/cool-icon.png"),

    // overriding a CUBA default icon
    OK("icons/my-ok.png");

    protected String source;

    MyIcon(String source) {
        this.source = source;
    }

    @Override
    public String source() {
        return source;
    }
}
----

Наборы значков необходимо зарегистрировать в свойстве приложения <<cuba.iconsConfig,cuba.iconsConfig>>, например:

.web-app.properties
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.MyIcon
----

[TIP]
====
Чтобы наборы значков из компонента приложения были доступны в проекте, необходимо добавить данное свойство приложения в <<app-component.xml,дескриптор компонента>>.
====

Теперь вы можете использовать значки из созданного набора, декларативно указывая имя соответствующего элемента enum в XML-дескрипторе:

[source, xml]
----
<button icon="COOL_ICON"/>
----

или программно в контроллере экрана:

[source, java]
----
button.setIconFromSet(MyIcon.COOL_ICON);
----

Используя специальные префиксы, вы можете декларативно использовать значки из разных источников:

* `theme` - значок из <<web_theme,темы>> приложения, например, `web/themes/halo/awesomeFolder/superIcon.png`:
+
[source, xml]
----
<button icon="theme:awesomeFolder/superIcon.png"/>
----

* `file` - файл с изображением:
+
[source, xml]
----
<button icon="file:D:/superIcon.png"/>
----

* `classpath` - значок, расположенный в classpath, например, `com/company/demo/web/superIcon.png`
+
[source, xml]
----
<button icon="classpath:/com/company/demo/web/superIcon.png"/>
----

В платформе доступен уже готовый набор значков - `CubaIcon`. Он включает в себя практически все значки из библиотеки `FontAwesome`, а также собственные значки CUBA. Значки из этого набора по умолчанию можно выбрать в редакторе Studio:

image::icon_set.png[align="center"]

[[icon_provider]]
===== Добавление значков из других библиотек шрифтов

Для более тонкой настройки расширенной темы можно создать значки, встроенные в шрифты, либо использовать готовые внешние библиотеки значков.

. Создайте в модуле *web* класс `enum`, реализующий интерфейс `com.vaadin.server.FontIcon`, в который поместите новые значки:
+
[source, java]
----
include::{sourcesdir}/gui/add_icons_enum.java[]
----

. Добавьте новые стили и файлы шрифта в расширение темы. Рекомендуется создать отдельную папку `fonts` в главном каталоге расширения темы, например, `modules/web/themes/halo/com.company.demo/fonts`. Поместите в неё стили и файлы шрифтов в своих собственных подпапках, например, `fonts/icomoon`.
+
Файлы шрифта включают в себя набор следующих расширений:
+
** `.eot`,
+
** `.svg`,
+
** `.ttf`,
+
** `.woff`.
+
Использованный в этом примере набор шрифтов `icomoon` из открытой библиотеки представлен в виде 4 файлов: `icomoon.eot`, `icomoon.svg`, `icomoon.ttf`, `icomoon.woff`, которые используются совместно.

. Создайте файл стилей, в который включите `@font-face` и CSS класс со стилем для значка. Ниже представлен пример файла `icomoon.scss`, где имя класса `IcoMoon` соответствует значению, возвращаемому методом `FontIcon#getFontFamily`:
+
[source, css]
----
include::{sourcesdir}/gui/add_icons_icomoon.scss[]
----

. Подключите файл стилей шрифта в `halo-ext.scss` или другой файл расширения данной темы:
+
[source, css]
----
include::{sourcesdir}/gui/add_icons_halo-ext.scss[]
----

. Затем создайте новый <<icon_set,набор значков>>, то есть enum, реализующий интерфейс `Icons.Icon`:
+
[source, java]
----
include::{sourcesdir}/gui/IcoMoonIcon.java[]
----

. Создайте новый `IconProvider`.
+
--
Для работы с наборами значков в платформе есть механизм, основанный на использовании `IconProvider` и `IconResolver`.

`IconProvider` - это интерфейс-маркер, доступный только в веб-модуле, который предоставляет доступ к ресурсу (`com.vaadin.server.Resource`) по переданному пути.

Бин `IconResolver` проходится по всем бинам, реализующим `IconProvider`, в поисках того, кто может предоставить ресурс к данному значку.

На самом деле, в платформе есть два интерфейса `IconResolver` и их реализации для модулей *desktop* и *web*. Оба они являются бинами-фасадами, которые принимают путь к значку и возвращают ресурс для своего модуля:

* `com.vaadin.server.Resource` для модуля *web*,
* `javax.swing.Icon` для модуля *desktop*.

Чтобы использовать этот механизм, необходимо создать собственную реализацию `IconProvider`, например, так:

[source, java]
----
include::{sourcesdir}/gui/IcoMoonIconProvider.java[]
----

Здесь мы явно назначаем порядок для этого бина аннотацией `@Order`.
--

. Далее нужно зарегистрировать набор значков в файле свойств приложения:
+
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.IcoMoonIcon
----

Теперь вы можете использовать значки по прямой ссылке на класс и элемент `enum` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui/add_icons_usage.xml[]
----

или в контроллере Java:

[source, java]
----
include::{sourcesdir}/gui/add_icons_usage.java[]
----

В результате, новые значки добавились к кнопкам:

image::add_icons.png[align="center"]

Переопределение значков с помощью наборов::
+
--
Механизм наборов значков позволяет переопределять некоторые значки из других наборов. Для этого необходимо создать и зарегистрировать новый набор значков (enumeration) с теми же именами значков (options), но с другими путями (`source`). В примере ниже создан новый набор `MyIcon`, в котором переопределены стандартные значки из набора `CubaIcon`.

. Стандартный набор:
+
[source, java]
----
include::{sourcesdir}/gui/CubaIcon.java[]
----

. Новый набор:
+
[source, java]
----
include::{sourcesdir}/gui/MyIcon.java[]
----

. Регистрация нового набора в `web-app.properties`:
+
[source, plain]
----
cuba.iconsConfig = +com.company.demo.gui.icons.MyIcon
----

Теперь вместо стандартного значка *OK* будет использовано новое изображение:

[source, java]
----
include::{sourcesdir}/gui/overridden_icon.java[]
----

При необходимости игнорировать переопределение и использовать стандартные значки, просто используйте путь к значку вместо имени элемента перечисления:

[source, xml]
----
<button caption="Created" icon="icons/create.png"/>
----

или

[source, java]
----
button.setIcon(CubaIcon.CREATE_ACTION.source());
----
--

[[gui_web]]
==== Специфика Web Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Web Client* основана на фреймворке *Vaadin*. Рассмотрим основные классы, входящие в состав инфраструктуры веб клиента.

.Классы инфраструктуры Web Client
image::WebClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры приложения. Позволяет получить ссылки на `Connection` и другие объекты инфраструктуры. Экземпляр `App` существует в единственном экземпляре для данной HTTP-сессии пользователя. Ссылку на `App` можно получить вызовом статического метода `App.getInstance()`. Если необходимо кастомизировать функциональность `App` в проекте, создайте класс, расширяющий `DefaultApp` в корневом пакете модуля *web* и зарегистрируйте его в <<spring.xml, web-spring.xml>> в качестве бина `cuba_App`, например:
+
[source, xml]
----
<bean name="cuba_App" class="com.company.sample.web.MyApp" scope="vaadin"/>
----

* `Connection` - интерфейс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. Стандартной реализацией этого интерфейса является класс `ConnectionImpl`.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

* `AppUI` - класс платформы, унаследованный от класса `com.vaadin.ui.UI`. Экземпляр данного класса соответствует одной открытой вкладке веб браузера. Содержит ссылку на реализацию интерфейса `TopLevelWindow` - это может быть либо окно логина, либо главное окно приложения, в зависимости от состояния подключения. Ссылку на `AppUI` можно получить вызовом статического метода `AppUI.getCurrent()`.

* `AppLoginWindow` - окно, отображаемое до логина пользователя. В конкретном приложении окно можно кастомизировать или создать новое с нуля, унаследовав класс от <<abstractWindow,AbstractWindow>> и реализовав маркерный интерфейс `TopLevelWindow`. В Studio это можно сделать, нажав *Create login window* в секции *Screens*. Если вы переопределяете метод `init()`, обязательно вызовите `super.init(params)`.

* `AppMainWindow` - главное окно приложения, отображаемое после логина пользователя. В конкретном приложении окно можно кастомизировать или создать новое с нуля, унаследовав класс от `AbstractMainWindow` и определив нужную компоновку в XML-дескрипторе. В Studio это можно сделать, нажав *Create main window* в секции *Screens*. Если вы переопределяете метод `init()`, обязательно вызовите `super.init(params)`.
+
Без переопределения главного окна можно управлять некоторыми параметрами с помощью следующих свойств приложения:
+
--
** <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> - включает формирование <<folders_pane,панели папок>>.

** <<cuba.web.appWindowMode,cuba.web.appWindowMode>> - задает начальный режим главного окна: с вкладками или одноэкранный (`TABBED` или `SINGLE`). Пользователь впоследствии может задать желаемый режим через экран *Help* → *Settings*.

** <<cuba.web.maxTabCount,cuba.web.maxTabCount>> - в режиме представления главного окна с вкладками задает максимальное количество вкладок, которое может открыть пользователь. По умолчанию 7.
--

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `Frame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *web* имеется конкретный класс `WebWindowManager`, реализующий специфику веб клиента. Ссылку на `WindowManager` можно получить в любой реализации интерфейса `Window` (например в контроллере экрана), или с помощью бина `WindowManagerProvider`.

Для того, чтобы обрабатывать нажатия на кнопку *Back* браузера, реализуйте интерфейс `CubaHistoryControl.HistoryBackHandler` в ваших `TopLevelWindow` (окно логина и главное окно). Метод `onHistoryBackPerformed()` этого интерфейса вызывается вместо стандартного поведения браузера, если свойство приложения <<cuba.web.allowHandleBrowserHistoryBack,cuba.web.allowHandleBrowserHistoryBack>> установлено в true.

[[webComponentsHelper]]
===== Работа с компонентами Vaadin

Для работы непосредственно с компонентами Vaadin, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в блоке Web Client, воспользуйтесь следующими методами интерфейса `Component`:

* `unwrap()` - получить Vaadin-компонент для данного CUBA-компонента.

* `unwrapComposition()` - получить Vaadin-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `com.vaadin.ui.Button`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответствующий объект `com.vaadin.ui.Table`, а `unwrapComposition()` - объект `com.vaadin.ui.VerticalLayout`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Методы принимают класс компонента, который нужно вернуть, например:

[source, java]
----
com.vaadin.ui.TextField vTextField = textField.unwrap(com.vaadin.ui.TextField.class);
----

Можно также использовать статические методы `unwrap()` и `getComposition()` класса `WebComponentsHelper`, передавая в них CUBA-компонент.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `unwrap()`, нужно либо расположить весь экран в модуле *web*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[main_window_layout]]
===== Компоновка главного окна приложения

Механизм предоставляет возможность задавать компоновку главного экрана веб-приложения с использованием технологии универсального пользовательского интерфейса CUBA - XML-дескриптора и Java-контроллера с применением <<gui_vcl,визуальных компонентов>> и <<datasources,источников данных>>. 

Главное окно - особый экран системы, имеющий идентификатор `mainWindow`. Контроллер главного экрана должен быть наследником класса `AbstractMainWindow`.

Помимо стандартных компонентов GUI в главном экране приложения можно использовать дополнительные компоненты:

* `AppMenu` - главное меню.

* `FoldersPane` - панель <<folders_pane,папок поиска и папок приложения>>.

* `AppWorkArea` - рабочая область, обязательный компонент для работы с экранами в режимах `++THIS_TAB++`, `++NEW_TAB++` и `++NEW_WINDOW++`.

* `UserIndicator` - поле, отображающее имя текущего пользователя, а при наличии замещаемых пользователей позволяет переключаться между ними.
+
--
Метод `setUserNameFormatter()` используется для отображения имени пользователя в виде, отличном от стандартного имени экземпляра сущности `User`:

[source, java]
----
include::{sourcesdir}/gui/main_window.java[]
----

image::userIndicator.png[align="center"]
--

* `NewWindowButton` - кнопка открытия нового окна приложения.

* `LogoutButton` - кнопка выхода из приложения.

* `TimeZoneIndicator` - надпись, которая отображает <<timeZone,часовой пояс>> пользователя.

* `FtsField` - поле полнотекстового поиска.

Для работы с дополнительными компонентами в XML-дескриптор экрана нужно добавить элемент `xmlns:main`:

[source, xml]
----
include::{sourcesdir}/gui/main_window_1.xml[]
----

Специальный компонент `AppWorkArea` представляет собой рабочую область, в которой открываются экраны приложения. Если свойство приложения <<cuba.web.appWindowMode,cuba.web.appWindowMode>> имеет значение `TABBED` (по умолчанию), то на месте рабочей области будет расположен компонент `TabSheet` с экранами приложения. В противном случае рабочая область будет содержать единственный открытый экран. Свойства приложения <<cuba.web.mainTabSheetMode,cuba.web.mainTabSheetMode>>  и <<cuba.web.managedMainTabSheetMode,cuba.web.managedMainTabSheetMode>> определяют, как будет обрабатываться содержимое вкладок при их переключении. Когда не открыт ни один экран, рабочая область содержит компоненты, определенные во вложенном элементе `initialLayout`:

[source, xml]
----
include::{sourcesdir}/gui/main_window_2.xml[]
---- 

При открытии экранов компоновка начального экрана (`initialLayout`) удаляется из `AppWorkArea`, при закрытии всех экранов - добавляется обратно. Для реакции на события смены рабочей области на стартовый экран и на отображение экранов приложения можно добавить обработчик `AppWorkArea.StateChangeListener`. Например, в таком слушателе можно разместить код обновления данных стартового экрана. 

В платформе существуют 2 стандартные реализации главного окна приложения. XML-дескриптор классического окна с верхним горизонтальным меню - `/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml`, соответствующий контроллер - `AppMainWindow`. Также доступна компоновка с <<gui_SideMenu, вертикальным боковым меню>>.

Стандартная реализация главного окна может быть расширена в проекте, так же как обычный экран системы. Пример расширяющего экрана:

[source, xml]
----
include::{sourcesdir}/gui/main_window_3.xml[]
----
--
Этот экран должен быть зарегистрирован в <<screens.xml,web-screens.xml>> с идентификатором `mainWindow`.

Самый простой способ расширить главное окно - использовать визуальный дизайнер *Generic UI templates* в CUBA Studio: нажмите *New* на вкладке GENERIC UI на панели навигации и выберите шаблон нового главного окна. Новый файл `ext-mainwindow.xml` будет создан в модуле Web и автоматически зарегистрирован `web-screens.xml`.

Реализация главного окна может быть полностью заменена. Например:

[source, xml]
----
include::{sourcesdir}/gui/main_window_4.xml[]
---- 
--
В результате главное окно приложения выглядит следующим образом: 

image::main_window_1.png[align="center"]


Оно же с открытым экраном: 

image::main_window_2.png[align="center"]


Свойство приложения <<cuba.web.showBreadCrumbs,cuba.web.showBreadCrumbs>> позволяет скрыть панель навигации (breadcrumbs) над открытым экраном.

[[web_login]]
===== Процесс входа в Web Client

В данном разделе описывается, как работает аутентификация на веб-клиент и как расширить ее в проекте. Для информации об аутентификации на среднем слое см. <<login>>.

Реализация логина в Web Client включает следующие механизмы:

- `Connection` реализованный классом `ConnectionImpl`.
- Реализации интерфейса `LoginProvider`.
- Реализации интерфейса `HttpRequestFilter`.

.Механизмы логина в Web Client
image::WebLoginStructure.png[align="center"]

Основной интерфейс подсистемы входа в Web Client - `Connection`, включающий следующие основные методы:

- *login()* - аутентифицирует пользователя, создаёт пользовательскую сессию и изменяет состояние соединения.
- *logout()* - выполняет выход из системы.
- *substituteUser()* - замещает пользователя в текущей сессии. Этот метод создаёт новый объект *UserSession*, но с тем же ID.
- *getSession()* - возвращает текущую сессию.

После успешного входа *Connection* устанавливает объект *UserSession* в атрибут `VaadinSession` и устанавливает `SecurityContext`. Объект *Connection* связан с `VaadinSession`, поэтому вы не можете использовать его из фоновых потоков, при попытке вызова `login/logout` из фонового потока выбрасывается исключение *IllegalConcurrentAccessException*.

Обычно, логин выполняется из экрана `AppLoginWindow`, который поддерживает вход при помощи логина/пароля и токена "запомнить меня".

Реализация `Connection` по умолчанию - `ConnectionImpl`, который делегирует логин цепочке объектов `LoginProvider`. Интерфейс `LoginProvider` предназначен для реализации модулей входа, которые могут обрабатывать специфичные реализации интерфейса `Credentials`, также этот интерфейс включает метод `supports()`, позволяющий проверить поддерживает ли модули определённый тип `Credentials`.

.Стандартный процесс входа в Web Client
image::WebLoginProcedure.png[align="center"]

Стандартный процесс входа:

* Пользователь вводит свой логин и пароль.

* Web Client создаёт объект `LoginPasswordCredentials`, передав логи и пароль в его конструктор, и вызывает метод `Connection.login()` с этими данными для входа.

* `Connection` использует цепочку объектов `LoginProvider`. Существует стандартный модуль входа `LoginPasswordLoginProvider`, который работает с аутентификационными данными типа `LoginPasswordCredentials`. Этот модуль хэширует пароль при помощи метода `getPlainHash()` бина `PasswordEncryption` и вызывает `AuthenticationService.login(Credentials)`.

* Если вход выполнен успешно, то объект `AuthenticationDetails` с активной сессией <<userSession,UserSession>> возвращается в `Connection`.

* `Connection` создаёт специальный класс-обёртку `ClientUserSession` и устанавливает его в атрибут `VaadinSession`.

* `Connection` создаёт экземпляр `SecurityContext` и устанавливает его в `AppContext`.

* `Connection` публикует событие `StateChangeEvent`, стандартный обработчик которого обновляет UI и инициализирует `AppMainWindow`.

Все реализации `LoginProvider` должны:

* Аутентифицировать пользователя при помощи переданного объекта `Credentials`.
* Создать и запустить новую пользовательскую сессию при помощи `AuthenticationService` или вернуть существующий объект активной сессии (например, для пользователя anonymous).
* Вернуть данные аутентификации или null если объект `Credentials` не может быть обработан, например, если модуль входа отключен или не сконфигурирован.
* Выбросить исключение `LoginException` в случае некорректных данных `Credentials` или пробросить вызывающему коду исключение `LoginException`, полученное от среднего слоя,.

[[web_http_filter]]
`HttpRequestFilter` - маркерный интерфейс для бинов, которые будут автоматически добавлены в цепочку фильтров приложения в качестве HTTP фильтра: https://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html. Вы можете использовать такой фильтр для реализации дополнительной аутентификации, пре- и пост-обработки запроса и ответа.

Вы можете реализовать такой `Filter` если создадите компонент Spring Framework и реализуете интерфейс `HttpRequestFilter`:
[source, java]
----
include::{sourcesdir}/gui/web_customHttpFilter.java[]
----

Обратите внимание, что минимальная реализация должна делегировать исполнение объекту `FilterChain`, в противном случае ваше приложение будет неработоспособно. По умолчанию фильтры добавленные как бины `HttpRequestFilter` не будут получать запросы к каталогу `VAADIN` и другим путям, указанным в свойстве приложения `cuba.web.cubaHttpFilterBypassUrls`.

[[built_in_login_providers]]
Встроенные провайдеры входа::
+
--
Платформа включает следующие реализации интерфейса `LoginProvider`:

- `AnonymousLoginProvider` - предоставляет анонимный вход для пользователей, не выполнивших вход в систему.
- `LoginPasswordLoginProvider` - делегирует логин сервису `AuthenticationService` для переданного объекта `LoginPasswordCredentials`.
- `RememberMeLoginProvider`- делегирует логин сервису `AuthenticationService` для переданного объекта `RememberMeCredentials`.
- `LdapLoginProvider` - выполняет аутентификацию при помощи LDAP и выполняет вход, передавая `ExternalUserCredentials` сервису `AuthenticationService`.
- `ExternalUserLoginProvider` - может использоваться для выполнения входа из обработчиков событий приложения, позволяет выполнить вход от имени любого пользователя по его логину.

Все реализации создают активную сессию при помощи `AuthenticationService.login()`.

Вы можете переопределить любой из провайдеров входа при помощи механизмов Spring Framework.
--

[[web_login_events]]
События::
+
--
Стандартная реализация `Connection` - `ConnectionImpl` публикует следующие <<events, события>> во время процедуры входа:

- `BeforeLoginEvent` / `AfterLoginEvent`
- `LoginFailureEvent`
- `UserConnectedEvent` / `UserDisconnectedEvent`
- `UserSessionStartedEvent` / `UserSessionFinishedEvent`
- `UserSessionSubstitutedEvent`

Обработчики событий `BeforeLoginEvent` и `LoginFailureEvent` могут выбросить исключение `LoginException` чтобы прервать процесс входа или переопределить оригинальную причину ошибки входа.

Например, при помощи обработчика `BeforeLoginEvent` вы можете разрешить вход в Web Client только для пользователей, логин которых включает домен компании.

[source, java]
----
include::{sourcesdir}/gui/web_beforeLoginEventListener.java[]
----

Дополнительно, стандартный класс приложения - `DefaultApp` публикует следующие события:

- `AppInitializedEvent` - публикуется после инициализации объекта `App`, выполняется один раз для одной HTTP сессии.
- `AppStartedEvent` - публикуется во время обработки первого HTTP запроса к `App` перед инициализацией анонимного входа. Обработчики события могут выполнить вход при помощи `Connection`, связанного с `App`.
- `AppLoggedInEvent` - публикуется после инициализации UI `App` сразу после того, как выполнен вход в приложение.
- `AppLoggedOutEvent` - публикуется после инициализации UI `App` сразу после того, как выполнен выход из приложения.
- `SessionHeartbeatEvent` - публикуется во время запросов `heartbeat` от веб-браузера пользователя.

Событие `AppStartedEvent` может использоваться для реализации прозрачного входа и SSO со сторонними системами, такими как Jasig CAS. Обычно, используется вместе с дополнительной реализацией `HttpRequestFilter`, которая должна собрать и предоставить дополнительные аутентификационные данные из HTTP запроса.

Допустим, что система должна автоматически выполнять вход для пользователей, у которых есть специальный файл cookie - `PROMO_USER`.

[source, java]
----
include::{sourcesdir}/gui/web_appStartedEventListener.java[]
----

Так, если веб-браузер хранит файл cookie `PROMO_USER`, и пользователь откроет приложение, будет выполнен вход от имени пользователя, указанного в `promoUserLogin`.

Если вы хотите выполнить дополнительные действия после входа в приложение и инициализации UI вы можете реализовать обработчик события `AppLoggedInEvent`. Обратите внимание, что вы должны проверить, аутентифицирован ли пользователь или нет в обработчиках события, поскольку все события публикуются и для пользователя `anonymous`, даже если пользователь не аутентифицирован.

--

[[web_login_extension_points]]
Точки расширения::
+
--
Вы можете расширить механизм входа, используя следующие точки расширения::

- `Connection` - заменить существующий `ConnectionImpl`.
- `HttpRequestFilter` - реализовать дополнительный `HttpRequestFilter`.
- `LoginProvider` implementations - реализовать новый или заменить существующий бин `LoginProvider`.
- Events - реализовать обработчик одного из доступных <<web_login_events,событий>>.

Вы можете заменить существующие бины, используя механизмы Spring Framework, например, зарегистрировав новый бин в конфигурационном файле Spring XML модуля *web*.

[source, xml]
----
<bean id="cuba_LoginPasswordLoginProvider"
      class="com.company.demo.web.CustomLoginProvider"/>
----

--

[[web_login_obsolete]]
Устаревшие механизмы::
+
--

При необходимости можно создать собственный класс имплементации `CubaAuthProvider` и использовать его, установив следующие свойства приложения:

[source, properties]
----
cuba.web.externalAuthentication = true
cuba.web.externalAuthenticationProviderClass = com.company.sample.web.MyAuthProvider
----

Следующие компоненты считаются устаревшими:

- Интерфейс `CubaAuthProvider` и его реализации доступны в режиме совместимости. Используйте вместо него события, интерфейсы `LoginProvider` и `HttpRequestFilter`.
- `LdapAuthProvider` заменён на `LdapLoginProvider`, который может быть включен как описано здесь: <<ldap_basic,LDAP integration>>
- `IdpAuthProvider` заменён на `IdpLoginProvider`, который может быть включен как описано здесь: <<sso,IDP SSO>>

Не используйте эти компоненты. Они будут удалены в следующей major версии платформы.
--

[[gui_desktop]]
==== Специфика Desktop Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Desktop Client* основана на *Java Swing*. Рассмотрим основные классы, входящие в состав инфраструктуры десктоп клиента.

.Классы инфраструктуры Desktop Client
image::DesktopClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры десктоп приложения. Содержит ссылки на `Connection` и главный `TopLevelFrame`, а также методы инициализации и получения параметров приложения (см. ниже).
+
В конкретном приложении необходимо создать собственный класс-наследник `App` и переопределить в нем следующие методы:

** `getDefaultAppPropertiesConfig` - должен возвращать строку, в которой через пробел перечислены <<app_properties_files,файлы свойств приложения>>, например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_1.java[]
----

** `getDefaultHomeDir` - должен возвращать путь к каталогу, в котором приложение будет хранить временные и рабочие файлы, например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_2.java[]
----

** `getDefaultLogConfig` - должен возвращать имя файла настройки Logback, если таковой определен в проекте. Например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_3.java[]
----
+
Кроме того, в собственном классе-наследнике `App` необходимо определить метод `main()` следующим образом:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_4.java[]
----

* `Connection` - класс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. 

* `LoginDialog` - диалог логина пользователя. В конкретном приложении можно создать наследника `LoginDialog` и переопределить метод `createLoginDialog()` класса `App` для его использования.

* `TopLevelFrame` - наследник `JFrame`, являющийся окном самого верхнего уровня. В приложении существует как минимум один экземпляр данного класса, создаваемый при старте приложения и содержащий главное меню. Этот экземпляр возвращается методом `getMainFrame()` класса `App`.
+
При отделении пользователем вкладок главного окна или компонента <<gui_TabSheet,TabSheet>> (см. атрибут `detachable`) создаются дополнительные экземпляры `TopLevelFrame`, не содержащие главного меню.

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `Frame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *desktop* имеется конкретный класс `DesktopWindowManager`, реализующий специфику десктоп клиента.
+
Как правило, `WindowManager` не используется в прикладном коде напрямую.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

[[desktopComponentsHelper]]
===== Работа с компонентами Swing

Для работы непосредственно с компонентами Swing, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в блоке Desktop Client, воспользуйтесь следующими методами интерфейса `Component`:

* `unwrap()` - получить Swing-компонент для данного CUBA-компонента.

* `unwrapComposition()` - получить Swing-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `javax.swing.JButton`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответствующий объект `org.jdesktop.swingx.JXTable`, а `unwrapComposition()` - объект `javax.swing.JPanel`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Методы принимают класс компонента, который нужно вернуть, например:

[source, java]
----
javax.swing.JButton jButton = button.unwrap(javax.swing.JButton.class);
----

Можно также использовать статические методы `unwrap()` и `getComposition()` класса `DesktopComponentsHelper`, передавая в них CUBA-компонент.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `unwrap()`, нужно либо расположить весь экран в модуле *desktop*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[own_components]]
==== Собственные визуальные компоненты

В данном разделе содержится обзор различных способов создания собственных визуальных компонентов в CUBA-приложениях. Практическое руководство по использованию этих подходов содержится в разделе <<own_component_samples>>.

Новый визуальный компонент может быть создан с помощью следующих технологий:

. На основе Vaadin add-on.
+
--
Это простейший способ, требующий следующих шагов:

** Добавить в <<build.gradle,build.gradle>> зависимость от артефакта аддона.

** Создать в проекте модуль *web-toolkit*. Данный модуль содержит файл виджетсета GWT и позволяет создавать клиентские части визуальных компонентов.

** Подключить виджетсет аддона в виджетсет проекта.

** Если требуется адаптировать внешний вид компонента к теме приложения, создать расширение темы и задать для компонента нужный CSS.

См. пример в разделе <<vaadin_addon_sample>>.
--

. Как обертка библиотеки на JavaScript.
+
--
Данный метод рекомендуется, если у вас уже есть подходящий компонент, написанный на JavaScript. Чтобы использовать его в приложении, требуется следующее:

** Создать в модуле *web* серверный компонент Vaadin. Серверный компонент определяет API для серверного кода, методы доступа, слушатели событий и т.д. Серверный компонент должен быть унаследован от класса `AbstractJavaScriptComponent`. Модуль *web-toolkit* для интеграции JavaScript-компонента не требуется.

** Создать JavaScript-коннектор. Коннектор - это функция, которая инициализирует JavaScript-компонент и ответственна за взаимодействие между JavaScript и server-side кодом.

** Создать класс состояния. Публичные поля данного класса определяют, какие данные посылаются сервером клиенту. Класс состояния должен быть унаследован от `JavaScriptComponentState`.

См. пример в разделе <<js_library_sample>>.
--

. Как ресурс link:https://www.webjars.org/[WebJar]. См. раздел <<using_webjars, ниже>>.

. В виде нового компонента link:http://www.gwtproject.org[GWT].
+
--
Данный метод рекомендуется для создания полностью новых визуальных компонентов. Он требует следующих шагов:

** Создать в проекте модуль *web-toolkit*.

** Создать класс клиентского виджета GWT.

** Создать серверный компонент Vaadin.

** Создать класс состояния, определяющий данные, посылаемые сервером клиенту.

** Создать класс коннектора, который соединяет клиентский код с серверным компонентом.

** Создать интерфейс RPC, который определяет серверный API, вызываемый клиентом.

См. пример в разделе <<gwt_component_sample>>.
--

Степень интегрированности визуального компонента в платформу можно разделить на три уровня:

* На первом уровне новый компонент становится доступным как нативный компонент Vaadin. Прикладной разработчик может использовать его в контроллерах экранов приложения напрямую: создать экземпляр и добавить его в <<webComponentsHelper,нативный>> контейнер. Методы создания компонентов, описанные выше, предоставляют именно этот уровень интеграции.

* На втором уровне новый компонент интегрируется в <<gui_framework,универсальный пользовательский интерфейс>> платформы. В этом случае, с точки зрения прикладного разработчика, компонент выглядит так же как и стандартный компонент из <<gui_vcl,библиотеки визуальных компонентов>>. Разработчик может определить компонент в XML-дескрипторе экрана или создать его с помощью `ComponentsFactory` в контроллере. См. пример в разделе <<vaadin_addon_sample_gui>>.

* На третьем уровне новый компонент доступен в палитре компонентов WYSIWYG-дизайнера экранов Studio. См. пример в разделе <<own_component_in_studio>>.

[[using_webjars]]
===== Использование ресурсов WebJar

Данный метод позволяет использовать различные JavaScript-библиотеки, упакованные в JAR-файлы и развёрнутые в link:http://search.maven.org/[Maven Central]. Для подключения библиотеки к приложению требуется следующее:

** Добавить зависимость в метод `compile` модуля *web*:
+
[source, groovy]
----
compile 'org.webjars.bower:jrcarousel:1.0.0'
----

** Создать в проекте модуль *web-toolkit*.

** Создать класс клиентского виджета GWT и реализовать в нём `native` JSNI метод для создания компонента.

** Создать класс серверного компонента с аннотацией `@WebJarResource`.
+
--
Аннотация может использоваться только с наследниками `ClientConnector` (которые обычно являются классами компонентов UI в модуле *web-toolkit*).

Значение аннотации `@WebJarResource`, или определение ресурса, можно указать в одном из двух форматов:

. `<webjar_name>:<sub_path>`, например:
+
[source, java]
----
@WebJarResource("pivottable:plugins/c3/c3.min.css")
----

. `<webjar_name>/<resource_version>/<webjar_resource>`, например:
+
[source, java]
----
@WebJarResource("jquery-ui/1.12.1/jquery-ui.min.js")
----

Оно может содержать одно или более строковых определений ресурсов WebJar:

[source, java]
----
@WebJarResource({
        "jquery-ui:jquery-ui.min.js",
        "jquery-fileupload:jquery-fileupload.min.js",
        "jquery-fileupload:jquery-fileupload.min.js"
})
public class CubaFileUpload extends CubaAbstractUploadComponent {
    ...
}
----

Указывать версию WebJar не нужно, так как согласно стратегии управления версиями Maven будет автоматически использован WebJar с самым большим номером версии.

[[using_webjars_overridePath]]
Дополнительно можно указать путь к каталогу внутри `VAADIN/webjars/`, из которого должны подгружаться статические ресурсы. В такой каталог вы можете сами помещать новые версии ресурсов, и они будут автоматически переопределять используемые WebJar. Для указания каталога используйте свойство `overridePath` аннотации `@WebJarResource`, к примеру:

[source, java]
----
@WebJarResource(value = "pivottable:plugins/c3/c3.min.css", overridePath = "pivottable")
----
--
** Добавить новый компонент к экрану.

[[pluggable_component_factories]]
==== Подключаемые фабрики компонентов

Механизм подключаемых фабрик компонентов расширяет процедуру генерации компонентов и позволяет создавать различные поля редактирования в <<gui_FieldGroup, FieldGroup>>, <<gui_Table, Table>> и <<gui_DataGrid, DataGrid>>. Это означает, что компоненты приложения или сам ваш проект могут предоставлять собственные стратегии, которые будут создавать нестандартные компоненты и/или поддерживать кастомные типы данных.

Для того, чтобы воспользоваться данным механизмом, следует использовать метод `ComponentsFactory.createComponent(ComponentGenerationContext)`. Он работает следующим образом:

* Пытается найти все реализации интерфейса `ComponentGenerationStrategy`. Если как минимум одна реализация существует:
** Обходит все реализации в соответствии с интерфейсом `org.springframework.core.Ordered`.
** Возвращается первый созданный не нулевой компонент.

Реализации интерфейса `ComponentGenerationStrategy` используются при создании UI компонентов. Проект может содержать любое количество таких стратегий.

`ComponentGenerationContext` - класс, содержащий следующую информацию, которая может быть использована при создании компонента:

* `metaClass` - задает сущность, для которой создается компонент.
* `property` - задает атрибут сущности, для которой создается компонент.
* `datasource` - источник данных, который может быть связан с компонентом.
* `optionsDatasource` - источник данных, который может быть связан с компонентом для показа опций.
* `xmlDescriptor` - XML дескриптор с дополнительной информацией, в случае, если компонент описан в XML дескрипторе.
* `componentClass` - класс компонента для которого должен быть создан компонент (например, `Table`, `FieldGroup`, `DataGrid`).

В платформе существуют две стандартных реализации `ComponentGenerationStrategy`:

* `DefaultComponentGenerationStrategy` - используется для создания компонентов в соответствии с переданным `ComponentGenerationContext`. Имеет значение _order_ равное `ComponentGenerationStrategy.LOWEST_PLATFORM_PRECEDENCE` (1000).
* `DataGridEditorComponentGenerationStrategy` - используется для создания компонентов для DataGrid Editor в соответствии с переданным `ComponentGenerationContext`. Имеет значение _order_ равное `ComponentGenerationStrategy.HIGHEST_PLATFORM_PRECEDENCE + 30` (130).

Пример ниже показывает, как заменить стандартную генерацию компонента в `FieldGroup` для определенного атрибута некоторой сущности.

[source, java]
----
include::{sourcesdir}/gui/pluggable_field_factories1.java[]
----

[WARNING]
====
Обратите внимание, что переопределение существующих стратегий генерации компонентов может приводить к ошибкам в случае изменения типа возвращаемого компонента, поскольку некоторые контроллеры экрана могут иметь код, ожидающий определенный тип компонента.

Например, в случае использования вышеприведенной стратегии, следующая инжекция приведет к исключению:

[source, java]
----
@Named("fieldGroup.date")
private DateField dateField;
----

Если вы попытаетесь открыть такой экран, то получите следующее исключение:

----
IllegalArgumentException: Can not set com.haulmont.cuba.gui.components.DateField field com.company.sales.web.order.OrderEdit.dateField to com.haulmont.cuba.web.gui.components.WebDatePicker
----

====

Пример ниже показывает, как определить `ComponentGenerationStrategy` для специализированного <<datatype,datatype>>.

[source, java]
----
include::{sourcesdir}/gui/pluggable_field_factories2.java[]
----

[[shortcuts]]
==== Горячие клавиши

В данном разделе приведена информация обо всех горячих клавишах (shortcuts), которые используются по умолчанию в универсальном пользовательском интерфейсе приложения. Все перечисленные ниже <<app_properties,свойства приложения>> принадлежат интерфейсу `ClientConfig` и используются в блоках *Web Client* и *Desktop Client*. 

* Главное окно приложения.

** *CTRL-SHIFT-PAGE_DOWN* - переход на следующую вкладку. Настраивается свойством приложения `cuba.gui.nextTabShortcut`.

** *CTRL-SHIFT-PAGE_UP* - переход на предыдущую вкладку. Настраивается свойством приложения `cuba.gui.previousTabShortcut`.

* Панель папок.

** *ENTER* – открыть выделенную <<folders_pane,папку>>.

** *SPACE* - выделить/снять выделение с папки, находящейся в фокусе.

** *ARROW UP*, *ARROW DOWN* - выбрать папку.

** *ARROW LEFT*, *ARROW RIGHT* - свернуть/развернуть папку, содержащую вложенные папки, или переместить фокус на уровень выше.

* Экраны.

** *ESCAPE* - закрыть текущий <<abstractWindow,экран>>. Настраивается свойством приложения `cuba.gui.closeShortcut`.

** *CTRL-ENTER* - закрыть текущий <<abstractEditor,экран редактирования>> с сохранением изменений. Настраивается свойством приложения `cuba.gui.commitShortcut`.

* Стандартные действия компонента-списка (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.

** *CTRL-\* - вызов действия <<createAction,CreateAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.insert`.

** *CTRL-ALT-\* - вызов действия <<addAction,AddAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.add`.

** *ENTER* - вызов действия <<editAction,EditAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.edit`.

** *CTRL-DELETE* - вызов действий <<removeAction,RemoveAction>> и <<excludeAction,ExcludeAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.remove`.

* Выпадающие списки (<<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>).

** *SHIFT-DELETE* – очистить значение.

* Стандартные действия поля выбора (<<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.
** *CTRL-ALT-L* - вызов действия <<lookupAction,LookupAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.lookup`.

** *CTRL-ALT-O* - вызов действия <<openAction,OpenAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.open`.

** *CTRL-ALT-C* - вызов действия <<clearAction,ClearAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.clear`.
+
В полях выбора кроме вышеперечисленных горячих клавиш поддерживается вызов действий сочетанием *CTRL-ALT-1*, *CTRL-ALT-2* и так далее по количеству действий. То есть при нажатии сочетания клавиш *CTRL-ALT-1* произойдет вызов действия, которое описано первым в списке действий, при нажатии сочетания клавиш *CTRL-ALT-2* − вызов второго действия и так далее. Сочетание *CTRL-ALT* можно заменить другим, указав его в свойстве приложения `cuba.gui.pickerShortcut.modifiers`.

* Компонент <<gui_Filter,Filter>>.

** *SHIFT-BACKSPACE* – открыть список выбора фильтров. Настраивается свойством приложения `cuba.gui.filterSelectShortcut`.

** *SHIFT-ENTER* - применить выбранный фильтр. Настраивается свойством приложения `cuba.gui.filterApplyShortcut`.


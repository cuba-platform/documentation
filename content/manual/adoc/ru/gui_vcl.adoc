[[gui_vcl]]
==== Библиотека визуальных компонентов

<<gui_components,Компоненты>>

<<gui_layouts,Контейнеры>>

<<gui_misc,Разное>>

[[gui_components]]
===== Компоненты

[cols="<.^1,<.^4", frame="none", width="60%", grid="none"]
|===

| *Меню*|

| <<gui_AppMenu,AppMenu>>| image:gui_AppMenu.png[]

| <<gui_SideMenu,SideMenu>>| image:gui_sidemenu.png[]

| |

| *Кнопки*|

| <<gui_Button,Button>>| image:Button.png[]

| <<gui_PopupButton,PopupButton>>| image:PopupButton.png[]

| <<gui_LinkButton,LinkButton>>| image:LinkButton.png[]

| |

| *Текст*|

| <<gui_Label,Label>>| image:gui_label.png[]

| |

| *Ввод текста*|

| <<gui_TextField,TextField>>| image:gui_textField_data.png[]

| <<gui_PasswordField,PasswordField>>| image:gui_PasswordField.png[]

| <<gui_MaskedField,MaskedField>>| image:gui_MaskedField.png[]

| <<gui_TextArea,TextArea>>| image:gui_TextArea.png[]

| <<gui_RichTextArea,RichTextArea>>| image:gui_RichTextArea.png[]

| <<gui_SourceCodeEditor, SourceCodeEditor>>| image:gui_SourceCodeEditor_1.png[]

| |

| *Ввод даты*|

| <<gui_DateField,DateField>>| image:gui_dateField.png[]

| <<gui_DatePicker,DatePicker>>| image:gui_datepicker_mini.png[]

| <<gui_TimeField,TimeField>>| image:gui_timeField.png[]

| |

| *Поля выбора*|

| <<gui_CheckBox,CheckBox>>| image:CheckBox.png[]

| <<gui_OptionsGroup,OptionsGroup>>| image:gui_optionsGroup.png[]

| <<gui_OptionsGroup,OptionsList>>| image:gui_optionsList.png[]

| <<gui_PickerField,PickerField>>| image:PickerField.png[]

| <<gui_LookupField,LookupField>>| image:LookupField.png[]

| <<gui_LookupPickerField,LookupPickerField>>| image:LookupPickerField.png[]

| <<gui_SearchPickerField,SearchPickerField>>| image:gui_searchPickerField.png[]

| <<gui_SuggestionPickerField,SuggestionPickerField>>| image:gui_suggestionPickerField_1.png[]

| <<gui_TwinColumn,TwinColumn>>| image:TwinColumn.png[]

| |

| *Загрузка*|

| <<gui_FileUploadField,FileUploadField>>| image:Upload.png[]

| <<gui_FileMultiUploadField,FileMultiUploadField>>

|

| *Таблицы и деревья*|

| <<gui_DataGrid,DataGrid>>| image:gui_dataGrid.png[]

| <<gui_Table,Table>>| image:gui_table.png[]

| <<gui_GroupTable,GroupTable>>| image:gui_groupTable.png[]

| <<gui_TreeTable,TreeTable>>| image:gui_treeTable.png[]

| <<gui_Tree,Tree>>| image:gui_Tree.png[]

| |

| *Другое*|

| <<gui_BrowserFrame,BrowserFrame>>| image:gui_browserFrame.png[]

| <<gui_Calendar,Calendar>>| image:gui_calendar_1.png[]

| <<gui_ColorPicker,ColorPicker>>| image:gui_color_picker.png[]

| <<gui_FieldGroup,FieldGroup>>| image:gui_fieldGroup.png[]

| <<gui_Filter,Filter>>| image:gui_filter_mini.png[]

| <<gui_Image,Image>>| image:gui_Image_1.png[]

| <<gui_PopupView,PopupView>>| image:gui_popup_view_mini_open.png[]

| <<gui_TokenList,TokenList>>| image:gui_tokenList.png[]

|===

[[gui_AppMenu]]
====== AppMenu

Компонент `AppMenu` позволяет динамически управлять элементами главного меню в <<main_window_layout,главном окне приложения>>.

image::gui_AppMenu.png[align="center"]

CUBA Studio предоставляет готовый шаблон главного экрана на основе стандартного экрана `mainWindow` платформы. Шаблон расширяет класс `AppMainWindow` и обеспечивает прямой доступ к экземпляру компонента `AppMenu`:

[source, java]
----
include::{sourcesdir}/gui_vcl/appmenu.java[]
----

Методы интерфейса `AppMenu`:

[[gui_AppMenu_addMenuItem]]
* `addMenuItem()` - добавляет элемент меню в конец списка элементов или на позицию с указанным индексом.

[[gui_AppMenu_createMenuItem]]
* `createMenuItem()` - фабричный метод для создания нового элемента меню. Не добавляет элемент к меню. `id` должен быть уникальным внутри всего меню.

[[gui_AppMenu_createSeparator]]
* `createSeparator()` - создаёт разделитель элементов меню.

* `getMenuItem()/getMenuItemNN()` - возвращает объект элемента меню по его идентификатору.

* `getMenuItems()` - возвращает список элементов меню.

* `hasMenuItems()` - возвращает `true`, если меню содержит элементы.

Методы интерфейса `MenuItem`:

* `addChildItem() / removeChildItem()` - добавляет/удаляет элемент меню в конец или на указанную позицию в списке дочерних элементов.

* `getCaption()` - возвращает строковый заголовок элемента меню.

* `getChildren()` - возвращает список дочерних элементов.

[[gui_AppMenu_setCommand]]
* `setCommand()` - используется для описания действия, которое должно быть выполнено при выборе этого элемента меню кликом мыши.

* `setDescription()` - устанавливает строковое описание элемента меню, отображаемое в виде всплывающей подсказки.

* `setIcon()` - устанавливает пиктограмму элемента меню.

* `getId()` - возвращает идентификатор элемента меню.

* `getMenu()` - возвращает родительский экземпляр `AppMenu`.

* `setStylename()` - устанавливает один или более пользовательских стилей для компонента, заменяя все ранее заданные стили. Имена стилей при перечислении отделаются пробелами. Имя стиля должно быть названием существующего CSS-класса.

* `hasChildren()` - возвращает `true`, если у элемента меню есть дочерние элементы.

* `isSeparator()` - возвращает `true`, если элемент является разделителем.

* `setVisible()` - управляет видимостью элемента меню.

'''

API::
<<gui_AppMenu_addMenuItem,addMenuItem>> -
<<gui_AppMenu_createMenuItem,createMenuItem>> -
<<gui_AppMenu_createSeparator,createSeparator>> -
<<gui_AppMenu_setCommand,setCommand>>

'''

[[gui_BrowserFrame]]
====== BrowserFrame

Компонент `BrowserFrame` предназначен для включения веб-страницы на страницу приложения. Это аналог HTML-элемента `iframe`.

image::gui_browserFrame.png[align="center"]

XML-имя компонента: `browserFrame`

Компонент реализован для блока *Web Client*.

Пример использования компонента `browserFrame` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame.xml[]
----

Подобно компоненту <<gui_Image,Image>>, `BrowserFrame` также можно использовать для отображения графического содержимого из различных источников. Тип ресурса можно указать декларативно с помощью элементов `browserFrame`, перечисленных ниже:

[[gui_BrowserFrame_classpath]]
* `classpath` - ресурс, расположенный в classpath.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_1.xml[]
----

[[gui_BrowserFrame_file]]
* `file` - файл с изображением.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_2.xml[]
----

[[gui_BrowserFrame_relativePath]]
* `relativePath` - относительный путь к файлу в каталоге приложения.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_3.xml[]
----

[[gui_BrowserFrame_theme]]
* `theme` - ресурс из <<web_theme,темы>> приложения, например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_4.xml[]
----

[[gui_BrowserFrame_url]]
* `url` - ресурс, загружаемый по URL.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_5.xml[]
----

Атрибуты `browserFrame`:

[[gui_BrowserFrame_alternateText]]
* `alternateText` - устанавливает альтернативный текст на случай, если ресурс недоступен или не задан.

Параметры ресурсов `browserFrame`:

[[gui_BrowserFrame_bufferSize]]
* `bufferSize` - размер буфера, используемого для загрузки этого ресурса, в байтах.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_6.xml[]
----

[[gui_BrowserFrame_cacheTime]]
* `cacheTime` - время хранения объекта в кэше в миллисекундах.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_7.xml[]
----

[[gui_BrowserFrame_mimeType]]
* `mimeType` - MIME-тип ресурса.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_8.xml[]
----

Методы интерфейса `BrowserFrame`:

[[gui_BrowserFrame_SourceChangeListener]]
* `addSourceChangeListener()` - добавляет слушатель для отслеживания изменений источника содержимого.
+
[source,java]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_11.java[]
----

[[gui_BrowserFrame_setSource]]
* `setSource()` - устанавливает источник содержимого фрейма. Метод принимает тип ресурса и возвращает объект ресурса, который может быть сконфигурирован далее. Для каждого типа ресурсов есть свои методы, например, `setPath()` для `ThemeResource` или `setStreamSupplier()` для `StreamResource`:
+
[source,java]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_9.java[]
----
+
Вы можете использовать те же <<gui_Image_setSource,типы ресурсов>>, что и для компонента `Image`.

[[gui_BrowserFrame_createResource]]
* `createResource()` - создаёт ресурс фрейма указанного типа. Созданный объект может быть позже передан в метод `setSource()`:
+
[source,java]
----
include::{sourcesdir}/gui_vcl/gui_browserFrame_10.java[]
----

'''

Атрибуты browserFrame::
<<gui_attr_align,align>> -
<<gui_BrowserFrame_alternateText,alternateText>> -
<<gui_attr_caption,caption>> -
<<gui_attr_colspan,colspan>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_responsive,responsive>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты ресурсов browserFrame::
<<gui_BrowserFrame_bufferSize,bufferSize>> -
<<gui_BrowserFrame_cacheTime,cacheTime>> -
<<gui_BrowserFrame_mimeType,mimeType>>

Элементы browserFrame::
<<gui_BrowserFrame_classpath,classpath>> -
<<gui_BrowserFrame_file,file>> -
<<gui_BrowserFrame_relativePath,relativePath>> -
<<gui_BrowserFrame_theme,theme>> -
<<gui_BrowserFrame_url,url>>

API::
<<gui_BrowserFrame_SourceChangeListener,addSourceChangeListener>> -
<<gui_BrowserFrame_createResource,createResource>> -
<<gui_BrowserFrame_setSource,setSource>>

'''

[[gui_Button]]
====== Button

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-button" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Кнопка (`Button`) − компонент, обеспечивающий выполнение действия при нажатии.

image::Button.png[align="center"]

XML-имя компонента: `button`

Компонент кнопки реализован для блоков *Web Client* и *Desktop Client*.

Кнопка может содержать текст или пиктограмму (или и то и другое). На рисунке ниже отображены разные виды кнопок.

image::gui_buttonTypes.png[align="center"]

Пример кнопки с названием, взятым из <<message_packs,пакета локализованных сообщений>>, и с всплывающей подсказкой:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_1.xml[]
----

Название кнопки задается с помощью атрибута <<gui_attr_caption,caption>>, всплывающая подсказка − с помощью атрибута <<gui_attr_description,description>>.

[[gui_Button_disableOnClick]]
Если атрибут `disableOnClick` имеет значение `true`, кнопка будет автоматически отключена после клика по ней. Обычно это делается для того, чтобы предотвратить случайные повторные клики по кнопке. Впоследствии, вы можете снова включить кнопку с помощью вызова метода `setEnabled(true)`.

Атрибут <<gui_attr_icon,icon>> указывает на местоположение пиктограммы в каталоге темы. Подробную информацию о том, где следует располагать файлы пиктограмм, можно прочитать в <<gui_themes,Создание темы приложения>>.

Пример создания кнопки с пиктограммой:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_2.xml[]
----

[[gui_Button_invoke]]
Основная функция кнопки − выполнить некоторое действие при нажатии на нее. Определить метод контроллера, который будет вызываться при нажатии на кнопку, можно с помощью атрибута `invoke`. Значением атрибута должно быть имя метода контроллера, удовлетворяющего следующим условиям:

* Метод должен быть `public`.

* Метод должен возвращать `void`.

* Метод должен либо не иметь аргументов, либо иметь один аргумент типа `Component`. Если метод имеет аргумент `Component`, то при вызове в него будет передан экземпляр вызвавшей кнопки.

В качестве примера показано описание кнопки, вызывающей метод `someMethod:`

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_3.xml[]
----

В контроллере экрана необходимо определить метод `someMethod`:

[source, java]
----
include::{sourcesdir}/gui_vcl/button_4.java[]
----

[[gui_Button_action]]
Атрибут `invoke` игнорируется, если для кнопки задан атрибут `action`. Атрибут `action` содержит имя <<gui_Action,действия>>, соответствующего данной кнопке.

Пример кнопки с атрибутом `action`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_5.xml[]
----

Кнопке можно назначить любое действие, имеющееся в каком-либо компоненте, реализующем интерфейс `Component.ActionsHolder` (это актуально для <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). Причем неважно, каким образом эти действия добавлены - декларативно в XML-дескрипторе или программно в контроллере. В любом случае для использования такого действия достаточно в атрибуте `action` указать через точку имя компонента и идентификатор нужного действия. Например, в следующем примере кнопке назначается действие `create` таблицы `coloursTable`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_6.xml[]
----

Действие для кнопки можно также создавать программно, в контроллере экрана, используя наследование от класса <<baseAction,BaseAction>>.

Если для `Button` установлен экземпляр `Action`, то кнопка возьмет из него следующие свои свойства: <<gui_attr_caption,caption>>, <<gui_attr_description,description>>, <<gui_attr_icon,icon>>, <<gui_attr_enable,enable>>, <<gui_attr_visible,visible>>. Свойства `caption` и `description` будут проставлены из действия только в том случае, если они не установлены в самом `Button`. Остальные перечисленные свойства действия имеют безусловный приоритет над свойствами кнопки. Если свойства действия меняются уже после установки этого `Action` для `Button`, то соответственно меняться будут и свойства `Button`, то есть кнопка слушает изменение свойств действия. В этом случае меняется и свойства `caption` и `description`, причем даже если они изначально были назначены на саму кнопку.

[[gui_Button_stylenames]]
Стили компонента Button::
+
--
В веб-клиенте с темой, основанной на Halo, к компоненту `Button` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
[source, xml]
----
include::{sourcesdir}/gui_vcl/button_7.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `BUTTON_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/button.java[]
----

[[gui_button_borderless]]
* `borderless` - кнопка без полей.

[[gui_button_borderless-colored]]
* `borderless-colored` - кнопка без полей с цветной надписью.

[[gui_button_danger]]
* `danger` - выделенная кнопка, обозначающая действие, потенциально небезопасное для пользователя (которое может вызвать потерю данных и прочие необратимые изменения).

[[gui_button_friendly]]
* `friendly` - выделенная кнопка, обозначающая предпочтительное действие, безопасное для пользователя (не вызывающее потери данных и прочих необратимых изменений).

[[gui_button_icon-align-right]]
* `icon-align-right` - выравнивание пиктограммы по правому краю надписи.

[[gui_button_icon-align-top]]
* `icon-align-top` - расположение пиктограммы над надписью.

[[gui_button_icon-only]]
* `icon-only` - отображается только пиктограмма, кнопка квадратной формы.

[[gui_button_primary]]
* `primary` - кнопка основного действия (т.е.кнопка, которая получает фокус при нажатии кнопки Enter в форме ввода). Используйте внимательно, не более одной основной кнопки на представление.

[[gui_button_quiet]]
* `quiet` - "незаметная" кнопка, поля которой не видны до наведения указателя мыши.
--

'''

Атрибуты button::
<<gui_Button_action,action>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_Button_disableOnClick,disableOnClick>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_Button_invoke,invoke>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Предопределенные стили button::
<<gui_button_borderless,borderless>> -
<<gui_button_borderless-colored,borderless-colored>> -
<<gui_button_danger,danger>> -
<<gui_button_friendly,friendly>> -
<<gui_attr_stylename_huge,huge>> -
<<gui_button_icon-align-right,icon-align-right>> -
<<gui_button_icon-align-top,icon-align-top>> -
<<gui_button_icon-only,icon-only>> -
<<gui_attr_stylename_large,large>> -
<<gui_button_primary,primary>> -
<<gui_button_quiet,quiet>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>

'''

[[gui_BulkEditor]]
====== BulkEditor

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=bulk-editor" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`BulkEditor` - компонент, позволяющий менять значения атрибутов сразу нескольких выбранных экземпляров сущностей. Компонент представляет собой кнопку, добавляющуюся к <<gui_Table,таблице>> или <<gui_Tree,дереву>> и при нажатии открывающую редактор сущностей.

image::gui_bulkEdit.png[align="center"]

XML-имя компонента: `bulkEditor`

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Для использования `BulkEditor` у таблицы или дерева должен быть задан атрибут `multiselect="true"`.

Экран редактирования сущностей генерируется автоматически на основе заданного представления (содержащего только поля данной сущности, в том числе ссылки) и разрешений пользователя. Системные атрибуты в редакторе также не отображаются. 

Атрибуты сущности в редакторе сортируются по алфавиту. По умолчанию они пусты. При коммите экрана заданные на экране непустые значения атрибутов проставляются всем выбранным экземплярам сущности. 

Редактор позволяет удалить значение определенного поля в БД у всех выбранных сущностей, установив его в `null`. Для этого необходимо нажать на кнопку image:gui_bulkEditorSetNullButton.png[] рядом с соответствующим полем. После этого поле становится нередактируемым. Разблокировать поле можно, нажав на кнопку эту же кнопку снова.

image::gui_invoiceBulkEdit.png[align="center"]

Пример описания компонента `bulkEditor` для таблицы:

[source, xml]
----
include::{sourcesdir}/gui_vcl/bulkEditor_1.xml[]
----
[[gui_BulkEditor_for]]
Атрибут `for` является обязательным. В нем указывается идентификатор таблицы или дерева, в данном случае - `invoiceTable`.

[[gui_BulkEditor_exclude]]
Атрибут `exclude` может содержать регулярное выражения для явного исключения определенных полей из списка редактируемых. Например: `date|customer`

image::gui_TableBulkEdit.png[align="center"]

'''

Атрибуты bulkEditor::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_BulkEditor_exclude,exclude>> -
<<gui_BulkEditor_for,for>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_openType,openType>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_Calendar]]
====== Calendar

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=month-calendar" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Calendar` предназначен для организации и отображения событий календаря.

image::gui_calendar_1.png[align="center"]

XML-имя компонента: `calendar`.

Компонент реализован для блока *Web Client*.

Пример описания компонента в XML-дескрипторе экрана:
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_calendar_1.xml[]
----

Режим отображения определяется временным диапазоном календаря, который задаётся его начальной и конечной датой. По умолчанию используется режим отображения недели, работающий с диапазонами до семи дней. Для отображения календаря на один день используйте диапазон в пределах одной календарной даты. Режим отображения месяца применяется, если заданный диапазон превышает одну неделю (семь дней).

Кнопки навигации для перелистывания календаря на одну неделю вперёд/назад по умолчанию отключены. Чтобы кнопки были видны в режиме отображения недели, используйте атрибут `navigationButtonsVisible`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_calendar_9.xml[]
----

image::gui_calendar_2.png[align="center"]

Атрибуты `calendar`:

[[gui_Calendar_endDate]]
* `endDate` -  конечная дата диапазона календаря.

[[gui_Calendar_endDateProperty]]
* `endDateProperty` - имя атрибута сущности, содержащего конечную дату события.

[[gui_Calendar_descriptionProperty]]
* `descriptionProperty` - имя атрибута сущности, содержащего описание события.

[[gui_Calendar_isAllDayProperty]]
* `isAllDayProperty` - имя атрибута сущности, отвечающего за отображение события в течение всего дня.

[[gui_Calendar_startDate]]
* `startDate` - начальная дата диапазона календаря.

[[gui_Calendar_startDateProperty]]
* `startDateProperty` - имя атрибута сущности, содержащего начальную дату события.

[[gui_Calendar_stylenameProperty]]
* `stylenameProperty` - имя атрибута сущности, содержащего имя стиля события.

[[gui_Calendar_timeFormat]]
* `timeFormat` - формат времени: 12H or 24H.

[[gui_Calendar_addEvent]]
Для отображения событий в ячейках календаря их можно прямо добавлять в объект `Calendar` при помощи метода `addEvent()` или использовать интерфейс `CalendarEventProvider`.
Пример добавления события напрямую:

[source, java]
----
include::{sourcesdir}/gui_vcl/gui_calendar_1.java[]
----

[[gui_Calendar_setEventProvider]]
Интерфейс `CalendarEventProvider` имеет две готовые реализации: `ListCalendarEventProvider` (создаваемый по умолчанию) и `EntityCalendarEventProvider`.

`ListCalendarEventProvider` заполняется данными с помощью метода `addEvent()`, принимающего объект `CalendarEvent` в качестве параметра:

[source, java]
----
include::{sourcesdir}/gui_vcl/gui_calendar_2.java[]
----

`EntityCalendarEventProvider` получает данные напрямую из атрибутов сущности. Чтобы `EntityCalendarEventProvider` мог использовать сущность, она должна иметь *как минимум* следующие атрибуты: дата начала события (тип DateTime), дата окончания события (тип DateTime) и заголовок события (тип String).

В следующем примере мы предположим, что сущность в источнике данных имеет все необходимые атрибуты: `eventCaption`, `eventDescription`, `eventStartDate`, `eventEndDate`, `eventStylename`, и укажем их имена в качестве значений атрибутов `calendar`:
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_calendar_2.xml[]
----

Для пользовательского взаимодействия с элементами `Calendar`, такими как подписи даты и номера недель, выбор диапазона даты/времени, перетаскивание событий и изменение их размера, могут быть заданы различные слушатели. Слушатели также используются для кнопок навигации, листающих диапазон календаря вперёд и назад. Ниже приведён список слушателей по умолчанию:

[[gui_Calendar_CalendarDateClickListener]]
* `addDateClickListener(CalendarDateClickListener listener);` - добавляет слушатель кликов по дате.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/gui_calendar_3.java[]
----

[[gui_Calendar_CalendarWeekClickListener]]
* `addWeekClickListener()` - добавляет слушатель кликов по номеру недели.

[[gui_Calendar_CalendarEventClickListener]]
* `addEventClickListener()` - добавляет слушатель кликов по событию календаря.

[[gui_Calendar_CalendarEventResizeListener]]
* `addEventResizeListener()` - добавляет слушатель изменения размеров события календаря.

[[gui_Calendar_CalendarEventMoveListener]]
* `addEventMoveListener()` - добавляет слушатель перетаскивания события.

[[gui_Calendar_CalendarForwardClickListener]]
* `addForwardClickListener()` - добавляет слушатель перелистывания календаря вперёд во времени.

[[gui_Calendar_CalendarBackwardClickListener]]
* `addBackwardClickListener()` - добавляет слушатель перелистывания календаря назад во времени.

[[gui_Calendar_CalendarRangeSelectListener]]
* `addRangeSelectListener()` - добавляет слушатель выбора диапазона календаря.

Событиям календаря можно задавать стили с помощью CSS. Для настройки стиля задайте имя стиля и его параметры в файле `.scss`. Пример настройки цвета фона события:
[source, scss]
----
include::{sourcesdir}/gui_vcl/gui_calendar_1.scss[]
----
Затем вызовите метод `setStyleName` для нужного события:
[source, java]
----
include::{sourcesdir}/gui_vcl/gui_calendar_8.java[]
----
В результате, цвет фона события стал зелёным:

image::gui_calendar_3.png[align="center"]

[[gui_Calendar_setDayNames]]
Для компонента `Calendar` можно изменить названия дней недели и месяцев по умолчанию, используя методы `setDayNames()` и `setMonthNames()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/gui_calendar_10.java[]
----

'''

Атрибуты calendar::
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_colspan,colspan>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_Calendar_descriptionProperty,descriptionProperty>> -
<<gui_Calendar_endDateProperty,endDateProperty>> -
<<gui_Calendar_endDate,endDate>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_Calendar_isAllDayProperty,isAllDayProperty>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_Calendar_startDate,startDate>> -
<<gui_Calendar_startDateProperty,startDateProperty>> -
<<gui_attr_stylename,stylename>> -
<<gui_Calendar_stylenameProperty,stylenameProperty>> -
<<gui_Calendar_timeFormat,timeFormat>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_Calendar_addEvent,addEvent>> -
<<gui_Calendar_setEventProvider,setEventProvider>> -
<<gui_Calendar_setDayNames,setDayNames>>

Слушатели calendar::
<<gui_Calendar_CalendarBackwardClickListener,CalendarBackwardClickListener>> -
<<gui_Calendar_CalendarDateClickListener,CalendarDateClickListener>> -
<<gui_Calendar_CalendarEventClickListener,CalendarEventClickListener>> -
<<gui_Calendar_CalendarEventMoveListener,CalendarEventMoveListener>> -
<<gui_Calendar_CalendarEventResizeListener,CalendarEventResizeListener>> -
<<gui_Calendar_CalendarForwardClickListener,CalendarForwardClickListener>> -
<<gui_Calendar_CalendarRangeSelectListener,CalendarRangeSelectListener>> -
<<gui_Calendar_CalendarWeekClickListener,CalendarWeekClickListener>>

'''

[[gui_CheckBox]]
====== CheckBox

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-checkbox" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Флажок (`CheckBox`) − компонент, имеющий два состояния: выбран, не выбран.

image::CheckBox.png[align="center"]

XML-имя компонента: `checkBox`.

Компонент `CheckBox` реализован для блоков *Web Client* и *Desktop Client*.

Пример флажка с надписью, взятой из <<message_packs,пакета локализованных сообщений>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/checkbox_1.xml[]
----

Сброс или установка флажка изменяет его значение: `Boolean.TRUE` или `Boolean.FALSE`. Значение может быть получено с помощью метода `getValue()` и установлено с помощью метода `setValue()`. Если в `setValue()` передать `null`, то устанавливается значение `Boolean.FALSE` и флажок снимается.

[[gui_checkBox_ValueChangeListener]]
Изменение значения флажка, так же как и любого другого компонента, реализующего интерфейс `Field`, можно отслеживать с помощью слушателя `ValueChangeListener`. Например:

[source, java]
----
include::{sourcesdir}/gui_vcl/checkbox_2.java[]
----

Для создания флажка, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.

[source, xml]
----
include::{sourcesdir}/gui_vcl/checkbox_3.xml[]
----

Как видно из примера, в экране описывается <<datasources,источник данных>> `customerDs` для некоторой сущности Покупатель (`Customer`), имеющей атрибут `active`. В компоненте `checkBox` в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено флажком. Атрибут должен быть типа `Boolean`. Значением атрибута может быть `null`, при этом флажок снимается.

'''

Атрибуты checkBox::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

'''

[[gui_ColorPicker]]
====== ColorPicker

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-colorpicker" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`ColorPicker` представляет собой поле для предпросмотра и выбора цвета. Компонент возвращает шестнадцатеричный (HEX) код цвета в виде строки.

image::gui_color_picker.png[align="center"]

Пример использования `ColorPicker` с надписью, взятой из пакета локализованных сообщений:
[source, xml]
----
include::{sourcesdir}/gui_vcl/colorpicker_1.xml[]
----

Пример `ColorPicker` с закрытым окном палитры.

image::gui_color_picker_mini.png[align="center"]

Для создания `ColorPicker`, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.
[source, xml]
----
include::{sourcesdir}/gui_vcl/colorpicker_2.xml[]
----

Атрибуты `colorPicker`:

[[gui_ColorPicker_buttonCaption]]
* `buttonCaption` - надпись кнопки компонента.

[[gui_ColorPicker_defaultCaptionEnabled]]
* `defaultCaptionEnabled` - если установлено `true` и не задан атрибут `buttonCaption`, в качестве надписи кнопки используется HEX-код текущего цвета.

[[gui_ColorPicker_historyVisible]]
* `historyVisible` - определяет видимость истории последних выбранных цветов в окне палитры.

[[gui_ColorPicker_tabVisibility]]
Видимость вкладок окна палитры можно определить с помощью атрибутов:

* `swatchesVisible` - определяет видимость вкладки палитры.
* `rgbVisible` - определяет видимость вкладки селектора RGB.
* `hsvVisible` - определяет видимость вкладки селектора HSV.

По умолчанию включена только вкладка селектора RGB.

[[gui_ColorPicker_captions]]
Надписи окна палитры можно переопределить:

* `popupCaption` - надпись заголовка окна палитры.
* `confirmButtonCaption` - надпись кнопки подтверждения.
* `cancelButtonCaption` - надпись кнопки отмены.
* `swatchesTabCaption` - заголовок вкладки палитры.
* `lookupAllCaption` - надпись элемента выпадающего списка, отвечающего за все цвета.
* `lookupRedCaption` - надпись элемента выпадающего списка, отвечающего за оттенки красного.
* `lookupGreenCaption` - надпись элемента выпадающего списка, отвечающего за оттенки зеленого.
* `lookupBlueCaption` - надпись элемента выпадающего списка, отвечающего за оттенки синего.

Метод компонента `getValue()` возвращает строку, содержащую HEX-код цвета.

'''

Атрибуты colorPicker::
<<gui_attr_align,align>> -
<<gui_ColorPicker_buttonCaption,buttonCaption>> -
<<gui_ColorPicker_captions,cancelButtonCaption>> -
<<gui_attr_caption,caption>> -
<<gui_ColorPicker_captions,confirmButtonCaption>> -
<<gui_attr_datasource,datasource>> -
<<gui_ColorPicker_defaultCaptionEnabled,defaultCaptionEnabled>> -
<<gui_attr_editable,editable>> -
<<gui_attr_height,height>> -
<<gui_ColorPicker_historyVisible,historyVisible>> -
<<gui_ColorPicker_tabVisibility,hsvVisible>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_ColorPicker_captions,lookupAllCaption>> -
<<gui_ColorPicker_captions,lookupBlueCaption>> -
<<gui_ColorPicker_captions,lookupGreenCaption>> -
<<gui_ColorPicker_captions,lookupRedCaption>> -
<<gui_ColorPicker_captions,popupCaption>> -
<<gui_ColorPicker_tabVisibility,rgbVisible>> -
<<gui_attr_required,required>> -
<<gui_attr_stylename,stylename>> -
<<gui_ColorPicker_captions,swatchesTabCaption>> -
<<gui_ColorPicker_tabVisibility,swatchesVisible>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,ValueChangeListener>>

'''

[[gui_CurrencyField]]
====== CurrencyField

`CurrencyField` - это разновидность текстового поля, предназначенная для ввода денежных единиц. Поле содержит ярлык с обозначением валюты и по умолчанию имеет выравнивание по правому краю.

image::gui_currencyField.png[align="center"]

XML-имя компонента: `currencyField`.

Компонент `CurrencyField` реализован только для блока *Web Client*.

`CurrencyField` в основном повторяет функциональность <<gui_TextField,TextField>>: вы так же можете указать <<datatype,тип данных>> для поля, за исключением того, что `CurrencyField` поддерживает только числовые типы данных, унаследованные от `NumericDatatype`. Если установлен иной тип данных, будет выброшено исключение.

`CurrencyField` можно привязать к <<datasources,источнику данных>> с помощью атрибутов `datasource` и `property`:

[source,xml]
----
<currencyField currency="$"
               datasource="orderDs"
               property="amount"/>
----

Компонент `currencyField` имеет следующие специфические атрибуты:

[[gui_CurrencyField_currency]]
* `currency` - текст, который будет отображаться в ярлыке валюты.
+
[source,xml]
----
<currencyField currency="USD"/>
----

[[gui_CurrencyField_currencyLabelPosition]]
* `currencyLabelPosition` - определяет положение ярлыка внутри текстового поля:
+
--
** `LEFT` - слева от поля ввода,
** `RIGHT` - справа от поля ввода (значение по умолчанию).
--

[[gui_CurrencyField_showCurrencyLabel]]
* `showCurrencyLabel` - управляет видимостью ярлыка со значком валюты.

'''

Атрибуты currencyField::

<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_colspan,colspan>> -
<<gui_CurrencyField_currency,currency>> -
<<gui_CurrencyField_currencyLabelPosition,currencyLabelPosition>> -
<<gui_attr_datasource,datasource>> -
<<gui_TextField_datatype,datatype>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_CurrencyField_showCurrencyLabel,showCurrencyLabel>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Предопределенные стили currencyField::
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>

API::
<<gui_validator,addValidator>> -
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>> -
<<gui_CurrencyField_currency,setCurrency>> -
<<gui_CurrencyField_currencyLabelPosition,setCurrencyLabelPosition>> -
<<gui_CurrencyField_showCurrencyLabel,setShowCurrencyLabel>>

'''

[[gui_DataGrid]]
====== DataGrid

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=datagrid-basic-settings" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`DataGrid`, подобно компоненту <<gui_Table,Table>>, позволяет выводить информацию в виде таблицы, сортировать её, вызывать действия для выбранных строк, а также более эффективно управлять строками и колонками таблицы за счёт отложенной загрузки данных при прокрутке.

image::gui_dataGrid_1.png[align="center"]

XML-имя компонента: `dataGrid`.

Компонент реализован для блока *Web Client*.

Пример описания компонента в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/datagrid.xml[]
----

В данном примере атрибут `id` - это идентификатор колонки, а атрибут `property` содержит имя атрибута сущности, содержащейся в источнике данных, который следует использовать в качестве данных для колонки.

*Элементы dataGrid:*

[[gui_DataGrid_columns]]
* `columns` - обязательный элемент, определяет набор колонок `DataGrid`. Каждая колонка описывается во вложенном элементе `column` со следующими атрибутами:
+
--
* `id` - необязательный атрибут, содержит строковый идентификатор колонки. Если не задан, в качестве идентификатора колонки будет использоваться строковое значение атрибута `property`. В этом случае проставление атрибута `property` является обязательным, в противном случае будет брошено исключение `GuiDevelopmentException`. Атрибут `id` по-прежнему является обязательным для колонки, создаваемой программно.

[[gui_DataGrid_property]]
* `property` - необязательный атрибут, содержит название атрибута сущности, выводимого в колонке. Может быть как непосредственным атрибутом сущности, находящейся в источнике данных, так и атрибутом связанной сущности; переход по графу объектов обозначается точкой. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datagrid_dot.xml[]
----

* `caption` - необязательный атрибут, содержит заголовок колонки. Если не задан, будет отображено <<entity_localization,локализованное название атрибута>> сущности.

[[gui_DataGrid_expandRatio]]
* `expandRatio` - необязательный атрибут, устанавливает соотношение, с которым столбец расширяется. По умолчанию все колонки расширяются равномерно (словно все колонки имеют `expandRatio = 1`). Если хотя бы одной колонке установлено иное значение, все неявные значения удаляются и учитываются только проставленные.

[[gui_DataGrid_collapsible]]
* `collapsible` - необязательный атрибут, определяющий, может ли пользователь управлять отображением колонок с помощью меню (sidebar menu) в правой верхней части `DataGrid`. По умолчанию имеет значение `true`.

[[gui_DataGrid_collapsed]]
* `collapsed` -  необязательный атрибут, при указании `true` колонка будет изначально скрыта. По умолчанию имеет значение `false`.

[[gui_DataGrid_collapsingToggleCaption]]
* `collapsingToggleCaption` - необязательный атрибут, задает имя колонки в меню в правой верхней части `DataGrid`. По умолчанию имеет значение `null`, и в этом случае берется значение из заголовка колонки, доступного из свойства `caption`.
+
image::gui_dataGrid_2.png[align="center"]

[[gui_DataGrid_resizable]]
* `resizable` - необязательный атрибут, определяет, может ли пользователь изменять размер колонки.

[[gui_DataGrid_sortable,sortable]]
* `sortable` - необязательный атрибут, позволяющий запретить сортировку колонки. Вступает в действие, если атрибут `sortable` всего `DataGrid` установлен в `true` (что имеет место по умолчанию).

* `width` - необязательный атрибут, отвечает за изначальную ширину колонки. Может принимать только числовые значения в пикселах.

[[gui_DataGrid_minimumWidth]]
* `minimumWidth` - необязательный атрибут, отвечает за минимальную ширину колонки. Может принимать только числовые значения в пикселах.

[[gui_DataGrid_maximumWidth]]
* `maximumWidth` - необязательный атрибут, отвечает за максимальную ширину колонки. Может принимать только числовые значения в пикселах.

Элемент `column` может содержать вложенный элемент <<gui_formatter,formatter>> для представления значения атрибута в виде, отличном от стандартного для данного <<datatype,DataType>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/datagrid_formatter.xml[]
----
--

[[gui_DataGrid_actions]]
* `actions` - необязательный элемент для описания <<gui_Action,действий>>, связанных с `DataGrid`.  Кроме описания произвольных действий, поддерживаются следующие <<standard_actions,стандартные действия>>, определяемые перечислением `ListActionType`: create, edit, remove, refresh, add, exclude.

[[gui_DataGrid_buttonsPanel]]
* `buttonsPanel` - необязательный элемент, создающий над `DataGrid` контейнер `ButtonsPanel` для отображения кнопок действий.

[[gui_DataGrid_rowsCount]]
* `rowsCount` -  необязательный элемент, создающий для `DataGrid` компонент `RowsCount`, который позволяет загружать в `DataGrid` данные постранично. Размер страницы задается путем ограничения количества записей в источнике данных методом `CollectionDatasource.setMaxResults()` в контроллере экрана. Также можно управлять количеством записей. используя универсальный компонент `Filter`, связанный с источником данных `DataGrid`.

Компонент `RowsCount` может также отобразить общее число записей, возвращаемых текущим запросом в источнике данных, без извлечения этих записей. Для этого при щелчке пользователя на знаке "*?*" он вызывает метод `AbstractCollectionDatasource.getCount()`, что приводит к выполнению в БД запроса с такими же, как у текущего запроса, условиями, но с агрегатной функцией `++COUNT(*)++` вместо результатов. Полученное число отображается вместо знака "*?*".

*Атрибуты dataGrid:*

[[gui_DataGrid_columnResizeMode]]
* `columnResizeMode` - устанавливает режим изменения размера колонок пользователем. Поддерживаются следующие режимы (по умолчанию ANIMATED):
+
--
* `AMINATED` - размер колонки меняется сразу вслед за курсором.

* `SIMPLE` - размер колонки меняется только после того как курсор будет отпущен.
--
+
[[gui_DataGrid_ColumnResizeListener]]
Изменение размера колонок можно отслеживать с помощью слушателя `ColumnResizeListener`.

[[gui_DataGrid_columnsCollapsingAllowed]]
* `columnsCollapsingAllowed` - разрешает или запрещает пользователю скрывать колонки с помощью меню (sidebar menu) в правой части шапки `DataGrid`. Флажками в меню отмечаются отображаемые в данный момент колонки. В момент установки перезаписывает значение `collapsed` каждой отдельной колонки. Установка значения в `false` не позволяет атрибуту `collapsed` отдельной колонки принять значение `true`.
+
[[gui_DataGrid_ColumnCollapsingChangeListener]]
Скрытие и отображение колонок можно отслеживать с помощью слушателя `ColumnCollapsingChangeListener`.

[[gui_DataGrid_contextMenuEnabled]]
* `contextMenuEnabled` - включает или выключает контекстное меню в `DataGrid`. По умолчанию имеет значение `true`.
+
[[gui_DataGrid_ContextClickListener]]
Щелчки правой кнопкой мыши по области компонента `DataGrid` можно отслеживать с помощью слушателя `ContextClickListener`.

[[gui_DataGrid_editorBuffered]]
* `editorBuffered` - включает буферизацию в режиме внутристрочного редатирования. По умолчанию буферизация разрешена (`true`).

[[gui_DataGrid_editorCancelCaption]]
* `editorCancelCaption` - устанавливает заголовок кнопки отмены в режиме редактирования `DataGrid`.

[[gui_DataGrid_editorEnabled]]
* `editorEnabled` - включает отображение UI для внутристрочного редактирования ячеек.

[[gui_DataGrid_editorSaveCaption]]
* `editorSaveCaption` - устанавливает заголовок кнопки сохранения изменений в режиме редактирования `DataGrid`.

[[gui_DataGrid_frozenColumnCount]]
* `frozenColumnCount` - устанавливает количество фиксированных колонок в `DataGrid`. Значение `0` означает, что фиксированных колонок не будет, кроме встроенной колонки с чекбоксами для множественного выбора, если она используется. Значение `-1` означает, что фиксированных колонок не будет вообще.

[[gui_DataGrid_headerVisible]]
* `headerVisible` - определяет видимость заголовка `DataGrid`. По умолчанию имеет значение `true`.

[[gui_DataGrid_reorderingAllowed]]
* `reorderingAllowed` - разрешает или запрещает пользователю менять местами колонки, перетаскивая их с помощью мыши. По умолчанию имеет значение `true`.
+
[[gui_DataGrid_ColumnReorderListener]]
Изменение расположения колонок можно отслеживать с помощью слушателя `ColumnReorderListener`.

[[gui_DataGrid_selectionMode]]
* `selectionMode` - определяет режим выделения строк. Поддерживаются следующие режимы:
+
--
* `SINGLE` - единичный выбор строки.
* `MULTI` - множественный выбор строк как в таблице.
* `MULTI_CHECK` - множественный выбор строк с использованием встроенной колонки с чекбоксами.
* `NONE` - выбор строк отключен.
+
[[gui_DataGrid_SelectionListener]]
Выделение строк можно отслеживать с помощью слушателя `SelectionListener`.
+
image::gui_dataGrid_3.png[align="center"]
--

[[gui_DataGrid_sortable]]
* `sortable` - разрешает или запрещает сортировку в `DataGrid`. По умолчанию имеет значение `true`. Если сортировка разрешена, то при нажатии на название колонки справа от названия появляется соответствующий значок.  Сортировку некоторой отдельной колонки можно запретить с помощью атрибута `sortable` этой колонки.
+
[[gui_DataGrid_SortListener]]
События сортировки `DataGrid` можно отслеживать с помощью слушателя `SortListener`.

[[gui_DataGrid_textSelectionEnabled]]
* `textSelectionEnabled` - разрешает или запрещает выделение текста в ячейках `DataGrid`. По умолчанию имеет значение `false`.

*Методы интерфейса DataGrid:*

* `getColumns()` - возвращет текущий набор колонок `DataGrid` в порядке их текущего отображения.

* `getSelected()`, `getSingleSelected()` - возвращают экземпляры сущностей, соответствующие выделенным в таблице строкам. Коллекцию можно получить вызовом метода `getSelected()`. Если ничего не выбрано, возвращается пустой набор. Если установлен `SelectionMode.SINGLE`, удобно пользоваться методом `getSingleSelected()`, возвращающим одну выбранную сущность или `null`, если ничего не выбрано.

* `getVisibleColumns()` - возвращет набор видимых колонок `DataGrid` в порядке их текущего отображения.

[[gui_DataGrid_scrollTo]]
* `scrollTo()` - позволяет программно прокрутить `DataGrid` до нужной записи. Метод принимает экземпляр сущности, определяющий нужную строку в `DataGrid`. Перегруженный метод, помимо сущности, принимает `ScrollDestination`, имеющий следующие возможные значения:
+
--
* `ANY` - прокрутить как можно меньше, чтобы показать нужную запись.
* `START` - прокрутить так, чтобы нужная запись оказалась в начале видимой области `DataGrid`.
* `MIDDLE` - прокрутить так, чтобы нужная запись оказалась в центре видимой области `DataGrid`.
* `END` - прокрутить так, чтобы нужная запись оказалась в конце видимой области `DataGrid`.
--

* `scrollToStart()` and `scrollToEnd()` - позволяют прокрутить `DataGrid` в начало и конец соотвественно.

[[gui_DataGrid_setCellStyleProvider]]
* `setCellStyleProvider()` - позволяет задать стиль отображения ячеек `DataGrid`.

[[gui_DataGrid_setRowStyleProvider]]
* `setRowStyleProvider()` - позволяет задать стиль отображения строк `DataGrid`.

[[gui_DataGrid_setEnterPressAction]]
* `setEnterPressAction()` - позволяет задать <<gui_Action,действие>>, выполняемое при нажатии клавиши *Enter*. Если такое действие не задано, таблица пытается найти среди своих действий подходящее в следующем порядке:
+
--
* действие, назначенное методом `setItemClickAction()`.

* действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

* действие с именем `edit`.

* действие с именем `view`.

Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.

--

[[gui_DataGrid_setItemClickAction]]

* `setItemClickAction()` -  позволяет задать <<gui_Action,действие>>, выполняемое при двойном клике на строке таблицы. Если такое действие не задано, при двойном клике таблица пытается найти среди своих действий подходящее в следующем порядке:
+
--
* действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

* действие с именем `edit`.

* действие с именем `view`.

Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.

[[gui_DataGrid_ItemClickListener]]
События клика по элементу `DataGrid` можно отслеживать с помощью слушателя `ItemClickListener`.
--

[[gui_DataGrid_sort]]
* `sort()` - сортирует данные в переданной колонке в направлении, заданном одним из двух доступных значений перечисления `SortDirection`:
+
--
* `ASCENDING` - сортировка по возрастанию (например, A-Z, 1..9).

* `DESCENDING` - сортировка по убыванию (например, Z-A, 9..1).
--

[[gui_DataGrid_setCellDescriptionProvider]]
* `setCellDescriptionProvider()` - принимает экземпляр `CellDescriptionProvider`, который будет использоваться для генерации всплывающих подсказок для отдельных ячеек DataGrid. Строка описания может содержать HTML-разметку.
+
--
[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_rowDescription.java[]
----

image::gui_dataGrid_10.png[align="center"]
--

[[gui_DataGrid_setRowDescriptionProvider]]
* `setRowDescriptionProvider()` - принимает экземпляр `RowDescriptionProvider`, который будет использоваться для генерации всплывающих подсказок для строк DataGrid. Если `CellDescriptionProvider` также установлен, подсказка, сгенерированная `RowDescriptionProvider`, будет использована только для тех ячеек, для которых не задана подсказка ячейки.
+
--
[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_cellDescription.java[]
----
image::gui_dataGrid_11.png[align="center"]
--
[[gui_DataGrid_inline_editor]]
*Использование режима внутристрочного редактирования:*

У компонента `DataGrid` есть API, позволяющий напрямую редактировать записи в ячейках. Во время редактирования ячейки будет отображён UI с кнопками для сохранения и отмены изменений.

Методы API встроенного редактора:

* `getEditedItemId()` - возвращает `id` редактируемой записи.

* `isEditorActive()` - возвращает `true`, если в момент вызова редактируется какая-либо запись.

[[gui_DataGrid_editItem]]
* `editItem()` - открывает интерфейс внутристрочного редактора для указанной записи. Пролистывает таблицу до нужной записи, если в момент вызова она не была видна на экране.

Вы также можете добавить к встроенному редактору или удалить слушатели, использовав следующие методы:

[[gui_DataGrid_EditorPreCommitListener]]
* `addEditorPreCommitListener()`, `removeEditorPreCommitListener()` - слушатель редактора `DataGrid`, срабатывающий в процессе коммита изменений.

[[gui_DataGrid_EditorPostCommitListener]]
* `addEditorPostCommitListener()`, `removeEditorPostCommitListener()` - слушатель, срабатывающий на финальной стадии коммита изменений.

[[gui_DataGrid_EditorCloseListener]]
* `addEditorCloseListener()`, `removeEditorCloseListener()` - слушатель закрытия встроенного редактора `DataGrid`.

Коммит изменений сохраняет их в источнике данных. Логику сохранения изменений в базу данных необходимо задать отдельно.

Само поле редактирования также может быть изменено с помощью интерфейса `ColumnEditorFieldGenerator`. Используйте метод `setEditorFieldGenerator()` для определённой колонки таблицы, чтобы указать компонент для отображения в режиме редактирования этой колонки:

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_editor.java[]
----

Результат:

image::gui_dataGrid_14.png[align="center"]

[[gui_DataGrid_addGeneratedColumn]]
*Использование интерфейса ColumnGenerator:*

`DataGrd` имеет возможность добавлять генерируемые, или высчитываемые, колонки. Для этого существует два метода:

* `addGeneratedColumn(String columnId, ColumnGenerator generator)`

* `addGeneratedColumn(String columnId, ColumnGenerator generator, int index)`

`ColumnGenerator` - это специальный интерфейс, который описывает генерируемую колонку:

* значение для каждой строки колонки,

* тип значения - общий для всей колонки.

Например, для добавления генерируемой колонки, которая будет отображать логин пользователя в верхнем регистре, можно использовать следующий код:

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_generatedColumns.java[]
----

Результат:

image::gui_dataGrid_7.png[align="center"]

`ColumnGeneratorEvent`, который передается в `getValue`, хранит информацио о сущности, которая отображется в текущей строке `DataGrid`, и `propertyId` колонки.

По умолчанию, генерируемая колонка добавляется в конец таблицы. Управлять расположением генерируемых колонок можно либо вставляя колонку по индексу, либо предварительно добавив колонку в XML с `id`, который потом передавать в метод `addGeneratedColumn`.

[[gui_DataGrid_setRenderer]]
*Использование рендереров:*

[[gui_DataGrid_createRenderer]]
Отображение данных в колонках может быть изменено с помощью рендереров. Предположим, что нам необходимо показывать изображение в строке. Тогда текстовое значение пути до изображения можно отобразить в виде изображения с помощью `ImageRenderer`:

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_renderer.java[]
----

Результат:

image::gui_dataGrid_8.png[align="center"]

Интерфейс `WebComponentRenderer` позволяет настроить отображение веб-компонентов различных типов в ячейках `DataGrid`. Интерфейс реализован только для блока *Web Module*. Ниже приведён пример создания колонки для отображения компонента `LookupField`:

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_webComponentRenderer.java[]
----

Результат:

image::gui_dataGrid_13.png[align="center"]

[[gui_DataGrid_setConverter]]
Когда тип поля не совпадает с типом данных, принимаемых рендерером, удобно пользоваться конвертерами, которые обеспечивают конвертацию между типами данных модели и представления. К примеру, чтобы отобразить булево значение в виде пиктограммы, можно использовать `HtmlRenderer`, который умеет отображать HTML-разметку, и конвертер, который будет превращать булево значение в подходящую разметку для отображения иконок.

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_converter.java[]
----

Результат:

image::gui_dataGrid_9.png[align="center"]

Создавать рендереры можно двумя способами:

* через метод-фабрику интерфейса `DataGrid`, передавая в него интерфейс рендерера, для которого нужно создать имплементацию. Подходит для *GUI* и *Web* модулей.

* непосредственно создавая имплементацию рендерера для соответствующего модуля:
+
`dataGrid.createRenderer(DataGrid.ImageRenderer.class) → new WebImageRenderer()`
+
На данный момент этот способ реализован только для модуля *Web*.

Список рендереров, реализованных в платформе:

* `TextRenderer` - рендерер для отображения простого текста.

* `HtmlRenderer` - рендерер для отображения HTML-разметки.

* `ProgressBarRenderer` - рендерер, который отображает `double`-значения от 0 до 1 в виде компонента `ProgressBar`.

* `DateRenderer` - рендерер для отображения дат в заданном формате.

* `NumberRenderer` - рендерер для отображения чисел в заданном формате.

* `ButtonRenderer` - рендерер, который использует строковое значение в качестве заголовка кнопки.

* `ImageRenderer` - рендерер, который использует строковое значение в качестве пути до изображения.

* `CheckBoxRenderer` - рендерер, который отображает булево значение в виде иконок чек-бокса.

*Header и Footer:*

Интерфейсы `HeaderRow` и `FooterRow` предназначены для отображения ячеек заголовков и строк с итогами таблицы соответственно. Эти ячейки могут быть объединёнными для нескольких колонок.

Для создания и настройки заголовков и итогов используются следующие методы:

* `appendHeaderRow()`, `appendFooterRow()` - добавляет новую строку внизу секции заголовков/итогов.

* `prependHeaderRow()`, `prependFooterRow()` - добавляет новую строку наверху секции заголовков/итогов.

* `addHeaderRowAt()`, `addFooterRowAt()` - вставляет новую строку на заданную позицию в секции. Текущая строка на этой позиции, а также все следующие ниже, сдвигаются вниз с увеличением их индекса на 1.

* `removeHeaderRow()`, `removeFooterRow()` - удаляет указанную строку в секции.

* `getHeaderRowCount()`, `getFooterRowCount()` - возвращает количество строк в секции.

* `setDefaultHeaderRow()` - устанавливает заголовок таблицы по умолчанию. Интерфейс стандартного заголовка по умолчанию включает в себя элементы для сортировки колонок таблицы.

Интерфейсы `HeaderCell` и `FooterCell` позволяют управлять статическими ячейками:

* `setStyleName()` - устанавливает пользовательский стиль для данной ячейки.

* `getCellType()` - возвращает тип содержимого данной ячейки. Перечисление `DataGridStaticCellType` содержит 3 стандартных типа статических ячеек:
+
--
* `TEXT`

* `HTML`

* `COMPONENT`
--
* `getComponent()`, `getHtml()`,  `getText()` - возвращает содержимое данной ячейки в зависимости от её типа.

Ниже приведён пример таблицы `DataGrid` с заголовком, содержащим объединённые ячейки, и строкой итогов, в которой отображаются вычисляемые значения:

[source, xml]
----
include::{sourcesdir}/gui_vcl/datagrid_example_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/datagrid_example_2.java[]
----

image::gui_dataGrid_12.png[align="center"]

'''

Атрибуты dataGrid::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_colspan,colspan>> -
<<gui_DataGrid_columnResizeMode,columnResizeMode>> -
<<gui_DataGrid_columnsCollapsingAllowed,columnsCollapsingAllowed>> -
<<gui_DataGrid_contextMenuEnabled,contextMenuEnabled>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_DataGrid_editorBuffered,editorBuffered>> -
<<gui_DataGrid_editorCancelCaption,editorCancelCaption>> -
<<gui_DataGrid_editorEnabled,editorEnabled>> -
<<gui_DataGrid_editorSaveCaption,editorSaveCaption>> -
<<gui_attr_enable,enable>> -
<<gui_DataGrid_frozenColumnCount,frozenColumnCount>> -
<<gui_DataGrid_headerVisible,headerVisible>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_DataGrid_reorderingAllowed,reorderingAllowed>> -
<<gui_attr_responsive,responsive>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_DataGrid_selectionMode,selectionMode>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_DataGrid_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_DataGrid_textSelectionEnabled,textSelectionEnabled>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы dataGrid::
<<gui_DataGrid_actions,actions>> -
<<gui_DataGrid_buttonsPanel,buttonsPanel>> -
<<gui_DataGrid_columns,columns>> -
<<gui_DataGrid_rowsCount,rowsCount>>

Атрибуты column::
<<gui_attr_caption,caption>> -
<<gui_DataGrid_collapsed,collapsed>> -
<<gui_DataGrid_collapsible,collapsible>> -
<<gui_DataGrid_collapsingToggleCaption,collapsingToggleCaption>> -
<<gui_attr_editable,editable>> -
<<gui_DataGrid_expandRatio,expandRatio>> -
<<gui_attr_id,id>> -
<<gui_DataGrid_maximumWidth,maximumWidth>> -
<<gui_DataGrid_minimumWidth,minimumWidth>> -
<<gui_DataGrid_property,property>> -
<<gui_DataGrid_resizable,resizable>> -
<<gui_DataGrid_sortable,sortable>> -
<<gui_attr_width,width>>

Элементы column::
<<gui_formatter,formatter>>

API::
<<gui_DataGrid_addGeneratedColumn,addGeneratedColumn>> -
<<gui_api_settings,applySettings>> -
<<gui_DataGrid_createRenderer,createRenderer>> -
<<gui_DataGrid_editItem,editItem>> -
<<gui_api_settings,saveSettings>> -
<<gui_DataGrid_scrollTo,getColumns>> -
<<gui_DataGrid_setCellDescriptionProvider,setCellDescriptionProvider>> -
<<gui_DataGrid_setCellStyleProvider,setCellStyleProvider>> -
<<gui_DataGrid_setConverter,setConverter>> -
<<gui_DataGrid_setEnterPressAction,setEnterPressAction>> -
<<gui_DataGrid_setItemClickAction,setItemClickAction>> -
<<gui_DataGrid_setRenderer,setRenderer>> -
<<gui_DataGrid_setRowDescriptionProvider,setRowDescriptionProvider>> -
<<gui_DataGrid_setRowStyleProvider,setRowStyleProvider>> -
<<gui_DataGrid_sort,sort>>

Слушатели dataGrid::
<<gui_DataGrid_ColumnCollapsingChangeListener,ColumnCollapsingChangeListener>> -
<<gui_DataGrid_ColumnReorderListener,ColumnReorderListener>> -
<<gui_DataGrid_ColumnResizeListener,ColumnResizeListener>> -
<<gui_DataGrid_ContextClickListener,ContextClickListener>> -
<<gui_DataGrid_EditorCloseListener,EditorCloseListener>> -
<<gui_DataGrid_EditorPostCommitListener,EditorPostCommitListener>> -
<<gui_DataGrid_EditorPreCommitListener,EditorPreCommitListener>> -
<<gui_DataGrid_ItemClickListener,ItemClickListener>> -
<<gui_DataGrid_SelectionListener,SelectionListener>> -
<<gui_DataGrid_SortListener,SortListener>>

'''

[[gui_DateField]]
====== DateField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-datefield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Поле для отображения и ввода даты и времени. Представляет собой поле даты, внутри которого имеется кнопка с выпадающим календарем, а правее находится поле для ввода времени.

image::gui_dateFieldSimple.png[align="center"]

XML-имя компонента: `dateField`.

Компонент `DateField` реализован для блоков *Web Client* и *Desktop Client*. 

* Для создания поля даты, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_1.xml[]
---- 
+
Как видно из примера, в экране описывается источник данных `orderDs` для некоторой сущности Заказ (`Order`), имеющей атрибут `date`. В компоненте ввода даты в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено в поле.

* Если поле связано с атрибутом сущности, то оно автоматически принимает соответствующий вид:

** Если атрибут типа `java.sql.Date` или указана аннотация `@Temporal(TemporalType.DATE)`, то поле времени не отображается. Формат даты определяется <<datatype,типом данных>> `date` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `dateFormat`.

** В противном случае отображается также поле времени с часами и минутами. Формат времени определяется <<datatype,типом данных>> `time` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `timeFormat`.

[[gui_DateField_dateFormat]]
* Изменить формат представления даты и времени можно с помощью атрибута `dateFormat`. Значением атрибута может быть либо сама строка формата, либо ключ в пакете сообщений (если значение начинается с `msg://`).
+
Формат задается по правилам класса `SimpleDateFormat` (http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html). Если в формате отсутствуют символы `H` или `h`, то поле времени не выводится.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_2.xml[]
----
+
image::gui_dateField_format.png[align="center"]
+
[WARNING]
====
`DateField` в основном предназначен для быстрого ввода с клавиатуры путем заполнения маски. Поэтому компонент поддерживает только форматы с цифрами и разделителями. Сложные форматы с текстовым представлением дня недели или месяца не будут работать.
====

[[gui_DateField_range]]
* Диапазон доступных дат можно указать с помощью атрибутов `rangeStart` и `rangeEnd`. Если данные атрибуты установлены, все даты, выходящие за пределы диапазона, будут отключены. Значения доступных даты можно установить в XML в формате "yyyy-MM-dd", или программно с помощью соответствующих сеттеров.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_4.xml[]
----
+
image::gui_datefield_month_range.png[align="center"]

[[gui_DateField_resolution]]
* Точность представления даты и времени можно определить с помощью атрибута `resolution`. Значение атрибута должно соответствовать перечислению `DateField.Resolution` − `SEC`, `MIN`, `HOUR`, `DAY`, `MONTH`, `YEAR`. По умолчанию - `MIN`, то есть до минут.
+
Если `resolution="DAY"` и не указан атрибут `dateFormat`, то в качестве формата будет взят формат, указанный в <<main_message_pack,главном пакете сообщений>> с ключом `dateFormat`.
+
Если `resolution="MIN"` и не указан атрибут `dateFormat`, то в качестве формата будет взят формат, указанный в <<main_message_pack,главном пакете сообщений>> с ключом `dateTimeFormat`.
+
Ниже показано определения поля для ввода даты с точностью до месяца.
+
[source, xml]
----
<dateField resolution="MONTH" caption="msg://monthOnlyDateField"/>
----
+
image::gui_dateField_resolution.png[align="center"]

* Изменение значения поля `DateField`, так же, как и любого другого компонента, реализующего интерфейс `Field`, можно отслеживать с помощью слушателя `ValueChangeListener`.

* Если для пользователя методом `setTimeZone()` задан <<timeZone,часовой пояс>>, то `DateField` может преобразовывать значения типа timestamp между часовыми поясами сервера и пользователя. Если компонент привязан к атрибуту типа timestamp, часовой пояс автоматически берется из текущей <<userSession,пользовательской сессии>>. Если нет, то можно вызвать метод `setTimeZone()` в контроллере экрана, чтобы `DateField` выполнил необходимые преобразования.

[[gui_datefield_borderless]]
* В веб-клиенте с темой, основанной на Halo, к компоненту `DateField` можно применить заданный стиль `borderless`, чтобы удалить рамку и фон поля. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_5.xml[]
----
+
Чтобы применить стиль программно, выберите константу класса `HaloTheme` с префиксом компонента `DATEFIELD_`:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/datefield_6.java[]
----

'''

Атрибуты dateField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_DateField_range,rangeEnd>> -
<<gui_DateField_range,rangeStart>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_DateField_resolution,resolution>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы dateField::
<<gui_validator,validator>>

Предопределенные стили dateField::
<<gui_datefield_borderless,borderless>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

'''

[[gui_DatePicker]]
====== DatePicker

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-datepicker" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`DatePicker` это компонент для выбора даты. Он выглядит так же, как выпадающий календарь в <<gui_DateField,DateField>>.

image::gui_datepicker_mini.png[align="center"]

XML-имя компонента: `datePicker`.

`DatePicker` реализован для блока *Web Client*.

* Для создания `DatePicker`, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datepicker_1.xml[]
----
+
Как видно из примера, в экране описывается источник данных `orderDs` для некоторой сущности Заказ (`Order`), имеющей атрибут `date`. В компоненте ввода даты в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено в компоненте.

[[gui_DatePicker_range]]
* Вы можете указать доступные для выбора даты с помощью атрибутов `rangeStart` и `rangeEnd`. Если вы их установите, даты, выходящие за пределы указанного промежутка, будут недоступны.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datepicker_4.xml[]
----
+
image::gui_datepicker_month_range.png[align="center"]

[[gui_DatePicker_resolution]]
* Точность выбора даты определяется атрибутом `resolution`. Значение атрибута должно соответстовать перечислению `DatePicker.Resolution` − `DAY`, `MONTH`, `YEAR`. Значение по-умолчанию: `DAY`.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datepicker_2.xml[]
----
+
image::gui_datepicker_month_resolution.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datepicker_3.xml[]
----
+
image::gui_datepicker_year_resolution.png[align="center"]

'''

Атрибуты datePicker::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_DatePicker_range,rangeEnd>> -
<<gui_DatePicker_range,rangeStart>> -
<<gui_DatePicker_resolution,resolution>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_Embedded]]
====== Embedded (@Deprecated)

[WARNING]
====
Начиная с версии 6.7 платформы, компонент `Embedded` объявлен устаревшим (Deprecated). Используйте компонент <<gui_Image,Image>> для отображения графического содержимого и компонент <<gui_BrowserFrame,BrowserFrame>> для встраивания веб-страниц.
====

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=image-embedded" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Embedded` предназначен для вывода изображений и встраивания в экран произвольных веб-страниц.

XML-имя компонента: `embedded`

Компонент реализован для блоков *Web Client* и *Desktop Client*. В десктоп-клиенте поддерживается только вывод изображений.

Рассмотрим пример использования компонента для вывода изображения из файла, сохраненного в <<file_storage,FileStorage>>. 

* Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/embedded_1.xml[]
----

* В контроллере экрана инжектируем компонент и интерфейс `FileStorageService`. Затем в методе `init()` получаем из параметров экрана переданный из вызывающего кода `FileDescriptor`, загружаем соответствующий файл в байтовый массив, создаем для него `ByteArrayInputStream` и передаем в метод `setSource()` компонента:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_2.java[]
----

[[gui_Embedded_type]]
Компонент `Embedded` может отображать содержимое различных типов, которые по-разному отрисовываются в HTML. Тип содержимого можно задать методом `setType()`. Поддерживаются следующие типы:

* `OBJECT`  - позволяет встраивать файлы некоторых типов в элементы HTML <object> и <embed>.

* `IMAGE`  - встраивает изображения в HTML-элемент <img>.

* `BROWSER`  - встраивает контейнер для отображения других независимых документов внутри элемента HTML <iframe>.

В веб-клиенте компонент позволяет отображать файлы, находящиеся внутри каталога `VAADIN`. Например:

[[gui_Embedded_relativeSrc]]
[source, xml]
----
include::{sourcesdir}/gui_vcl/embedded_6.xml[]
----

или

[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_5.java[]
----

Кроме того, можно определить каталог ресурсных файлов в свойстве приложения <<cuba.web.resourcesRoot,cuba.web.resourcesRoot>>, и указать для компонента `Embedded` имя файла внутри этого каталога с префиксом значения атрибута: `file://` , `url://` или `theme://`:

[[gui_Embedded_src]]
[source, xml]
----
include::{sourcesdir}/gui_vcl/embedded_7.xml[]
----

или

[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_3.java[]
----

Для встраивания в экран веб-клиента внешней веб-страницы необходимо передать компоненту URL:

[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_4.java[]
----

'''

Атрибуты embedded::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Embedded_relativeSrc,relativeSrc>> -
<<gui_Embedded_src,src>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_FieldGroup]]
====== FieldGroup

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-fieldgroup" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `FieldGroup` предназначен для совместного отображения и редактирования нескольких атрибутов сущностей. 

image::gui_fieldGroup.png[align="center"]

XML-имя компонента: `fieldGroup`

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример описания группы полей в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_1.xml[]
---- 

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `datasource`, который содержит один экземпляр сущности `Order`. Для компонента `fieldGroup` в атрибуте `datasource` указывается используемый источник данных, а в элементах `field` - какие атрибуты сущности, содержащейся в источнике данных, необходимо отобразить.

Элементы `fieldGroup`:

[[gui_FieldGroup_column]]
* `column` - необязательный элемент, позволяющий располагать поля в несколько колонок. Для этого элементы `field` должны находиться не непосредственно внутри `fieldGroup`, а внутри своего `column`. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_2.xml[]
---- 
+
В данном случае поля будут расположены в две колонки, причем в первой колонке все поля будут шириной `250px`, а во второй - `400px`.
+
Атрибуты `column`:
+
--
[[gui_FieldGroup_column_width]]
** `width` - задает ширину полей данной колонки. По умолчанию ширина полей - `200px`. В данном атрибуте ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали.

[[gui_FieldGroup_column_flex]]
** `flex` - число, задающее степень изменения общего размера данной колонки по горизонтали относительно других колонок при изменении ширины всего компонента `fieldGroup`. Например, можно задать одной колонке `flex=1` а другой `flex=3`.

[[gui_FieldGroup_column_id]]
** `id` - необязательный идентификатор колонки, позволяющий ссылаться на нее в случае <<screen_extension,расширении экрана>>.
--

[[gui_FieldGroup_field]]
* `field` - основной элемент компонента, описывает одно поле компонента.
+
Собственные настраиваемые поля можно определить внутри элемента `field`:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_6.xml[]
----
+
Атрибуты элемента `field`:
+
--
[[gui_FieldGroup_field_id]]
** `id` - обязательный атрибут в случае, если не определён атрибут `property`; в противном случае по умолчанию принимает то же значение, что и `property`. Атрибут `id` должен содержать произвольный уникальный идентификатор либо поля с заданным атрибутом `property`, либо программно определяемого поля. В последнем случае элемент `field` должен иметь также атрибут `custom="true"` (см. далее).

[[gui_FieldGroup_field_property]]
** `property` - обязательный атрибут в случае, если не определён атрибут `id`; должен содержать название атрибута сущности, выводимого в поле, для связывания поля и данных.

[[gui_FieldGroup_field_caption]]
** `caption` − позволяет задать заголовок поля. Если не задан, будет отображено <<entity_localization,локализованное название атрибута>> сущности.

[[gui_FieldGroup_field_visible]]
** `visible` − позволяет скрыть поле вместе с заголовком.

[[gui_FieldGroup_field_datasource]]
** `datasource` − позволяет задать для данного поля <<datasources,источник данных>>, отличный от заданного для всего компонента `fieldGroup`. Таким образом в группе полей могут отображаться атрибуты разных сущностей.

** `optionsDatasource` − задает имя <<datasources,источника данных>>, используемого для формирования списка опций. Данный атрибут можно задать для поля, связанного со ссылочным атрибутом сущности. По умолчанию выбор связанной сущности производится через экран выбора, а если `optionsDatasource` указан, то связанную сущность можно выбирать из выпадающего списка опций. Фактически указание `optionsDatasource` приводит к тому, что вместо компонента <<gui_PickerField,PickerField>> в поле используется <<gui_LookupPickerField,LookupPickerField>>. 

[[gui_FieldGroup_field_width]]
** `width` − позволяет задать ширину поля без учета заголовка. По умолчанию ширина поля - `200px`. Ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали. Для указания ширины всех полей одновременно можно использовать атрибут `width` элемента `column`, описанный выше.

[[gui_FieldGroup_field_custom]]
** `custom` - установка этого атрибута в `true` позволяет задать собственное представление поля, или говорит о том, что идентификатор поля не ссылается на атрибут сущности, и компонент, находящийся в поле, будет задан программно с помощью метода `setComponent()` компонента `FieldGroup` (см. ниже).

[[gui_FieldGroup_field_generator]]
** атрибут `generator` позволяет декларативно создавать собственные прелставления полей, указав имя метода, возвращающего компонент для данного поля:
+
[source, xml]
----
<fieldGroup datasource="productDs">
    <column width="250px">
        <field property="description" generator="generateDescriptionField"/>
    </column>
</fieldGroup>
----

+
[source, java]
----
public Component generateDescriptionField(Datasource datasource, String fieldId) {
    TextArea textArea = componentsFactory.createComponent(TextArea.class);
    textArea.setRows(5);
    textArea.setDatasource(datasource, fieldId);
    return textArea;
}
----

[[gui_FieldGroup_field_link]]
** `link` - установка атрибута в `true` позволяет отобразить вместо поля выбора сущности ссылку на экран просмотра экземпляра сущности (поддерживается только для *Web Client*). Такое поведение может быть необходимо, если требуется дать пользователю возможность просматривать связанную сущность, но саму связь он менять не должен.

[[gui_FieldGroup_field_linkScreen]]
** `linkScreen` - позволяет указать идентификатор экрана, который будет открыт по нажатию на ссылку, включенную свойством `link`.

[[gui_FieldGroup_field_linkScreenOpenType]]
** `linkScreenOpenType` - задает режим открытия экрана редактирования (`++THIS_TAB++`, `++NEW_TAB++` или `DIALOG`).

[[gui_FieldGroup_field_linkInvoke]]
** `linkInvoke` - позволяет заменить открытие окна на вызов метода контроллера.

Следующие атрибуты элемента `field` можно применять в зависимости от типа атрибута сущности, отображаемого полем:

[[gui_FieldGroup_field_mask]]
** Если для текстового атрибута сущности задать значение атрибута `mask`, то в поле вместо компонента <<gui_TextField,TextField>> будет использоваться компонент <<gui_MaskedField,MaskedField>> с соотвествующей маской. В этом случае можно также задать атрибут `valueMode`.

[[gui_FieldGroup_field_rows]]
** Если для текстового атрибута сущности задать значение атрибута `rows`, то в поле вместо компонента <<gui_TextField,TextField>> будет использоваться компонент <<gui_TextArea,TextArea>> с соответствующим количеством строк. В этом случае можно также задать атрибут `cols`.

** Для текстового атрибута сущности можно задать атрибут `maxLength` аналогично описанному для <<gui_TextField,TextField>>.

** Для атрибута сущности типа `date` или `dateTime` можно задать атрибуты `dateFormat` и `resolution` для параметризации находящегося в поле компонента <<gui_DateField,DateField>>.

** Для атрибута сущности типа `time` можно задать атрибут `showSeconds` для параметризации находящегося в поле компонента <<gui_TimeField,TimeField>>.
--

Атрибуты `fieldGroup`:

[[gui_FieldGroup_border]]
* Атрибут `border` может принимать значение `hidden` или `visible`. По умолчанию - `hidden`. При установке в значение `visible` компонент `fieldGroup` выделяется рамкой. В веб-реализации компонента отображение рамки осуществляется добавлением CSS-класса `cuba-fieldgroup-border`. 

[[gui_FieldGroup_captionAlignment]]
* `captionAlignment` определяет расположение заголовков относительно полей компонента `FieldGroup`. Принимает два значения: `LEFT` и `TOP`.

[[gui_FieldGroup_fieldFactoryBean]]
* `fieldFactoryBean`: декларативные поля, объявленные в XML-дескрипторе, создаются с помощью интерфейса `FieldGroupFieldFactory`. Чтобы переопределить эту фабрику, используйте атрибут `fieldFactoryBean` с именем вашей реализации `FieldGroupFieldFactory`.
+
[[gui_FieldGroup_setFieldFactory]]
Для элемента `FieldGroup`, полностью созданного программно, для этой цели используется метод `setFieldFactory()`.

Методы интерфейса `FieldGroup`:

[[gui_FieldGroup_addField]]
* `addField` позволяет добавлять поля в FieldGroup на лету. В качестве параметра принимает экземпляр `FieldConfig`, также можно указать положение нового поля в FieldGroup с помощью параметров `colIndex` и `rowIndex`.

[[gui_FieldGroup_bind]]
* метод `bind()` необходимо применить к полю после вызова метода `setDatasource()`, чтобы вызвать создание компонентов поля.

[[gui_FieldGroup_createField]]
* `createField()` используется для создания элементов FieldGroup, реализующих интерфейс `FieldConfig`:
+
[source, java]
----
fieldGroup.addField(fieldGroup.createField("newField"));
----

[[gui_FieldGroup_getComponent]]
* Метод `getComponent()` возвращает визуальный компонент, находящийся в поле с указанным идентификатором. Это может потребоваться для дополнительной параметризации компонента, недоступной через атрибуты XML-элемента `field`, описанные выше.
+
Вместо явного вызова `getFieldNN("id").getComponentNN()` для получения ссылки на компонент поля в контроллере экрана можно использовать <<screen_controller_injection,инжекцию>>. Для этого следует использовать аннотацию `@Named` с указанием идентификатора самого `fieldGroup`, и через точку - идентификатора поля.
+
Например, следующим образом в поле выбора связанной сущности можно добавить действие открытия экземпляра и убрать действие очистки поля:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_4.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui_vcl/fieldgroup_5.java[]
----
+
Для использования метода `getComponent()` или инжекции компонентов полей необходимо знать тип компонента, находящегося в поле. В следующей таблице приведено соответствие типов атрибутов сущностей и создаваемых для них компонентов:
+
[cols="3*.^", frame="all"]
|===
| Тип атрибута сущности | Дополнительные условия| Тип компонента поля

.2+| Связанная сущность
| Задан атрибут `optionsDatasource`
| <<gui_LookupPickerField,LookupPickerField>>

|
| <<gui_PickerField,PickerField>>

| Перечисление (`enum`)
|
| <<gui_LookupField,LookupField>>

.3+| `string`
| Задан атрибут `mask`
| <<gui_MaskedField,MaskedField>>

| Задан атрибут `rows`
| <<gui_TextArea,TextArea>>

|
| <<gui_TextField,TextField>>

| `boolean`
|
| <<gui_CheckBox,CheckBox>>

| `date`, `dateTime`
|
| <<gui_DateField,DateField>>

| `time`
|
| <<gui_TimeField,TimeField>>

.2+| `int`, `long`, `double`, `decimal`
| Задан атрибут `mask`
| <<gui_MaskedField,MaskedField>>

|
| <<gui_TextField,TextField>>

| `UUID`
|
| <<gui_MaskedField,MaskedField>> с hex-маской

|===

[[gui_FieldGroup_removeField]]
* `removeField()` позволяет удалять поля на лету по `id`.

[[gui_FieldGroup_setComponent]]
* Метод `setComponent()` задаёт собственное представление поля. Он может быть использован вместе с атрибутом `custom="true"` элемента `field` или с полем, созданным программно методом `createField()` (см. выше). При использовании с `custom="true"` необходимо вручную указать источник данных и свойство.
+
Экземпляр FieldConfig можно получить с помощью методов `getField()` или `getFieldNN()`, и затем вызвать метод `setComponent()`, как показано в следующем примере:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/fieldgroup_3.java[]
---- 

'''

Атрибуты fieldGroup::
<<gui_attr_align,align>> -
<<gui_FieldGroup_border,border>> -
<<gui_attr_caption,caption>> -
<<gui_FieldGroup_captionAlignment,captionAlignment>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_FieldGroup_fieldFactoryBean,fieldFactoryBean>> -
<<gui_attr_id,id>> -
<<gui_attr_height,height>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты column::
<<gui_FieldGroup_column_flex,flex>> -
<<gui_FieldGroup_column_id,id>> -
<<gui_FieldGroup_column_width,width>>

Атрибуты field::
<<gui_FieldGroup_field_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_FieldGroup_field_rows,cols>> -
<<gui_FieldGroup_field_custom,custom>> -
<<gui_FieldGroup_field_datasource,datasource>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_FieldGroup_field_generator,generator>> -
<<gui_FieldGroup_field_id,id>> -
<<gui_FieldGroup_field_link,link>> -
<<gui_FieldGroup_field_linkInvoke,linkInvoke>> -
<<gui_FieldGroup_field_linkScreen,linkScreen>> -
<<gui_FieldGroup_field_linkScreenOpenType,linkScreenOpenType>> -
<<gui_FieldGroup_field_mask,mask>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_FieldGroup_field_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_DateField_resolution,resolution>> -
<<gui_FieldGroup_field_rows,rows>> -
<<gui_TimeField_showSeconds,showSeconds>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_FieldGroup_field_visible,visible>> -
<<gui_attr_width,width>>

Элементы field::
<<gui_FieldGroup_column,column>> -
<<gui_FieldGroup_field,field>> -
<<gui_validator,validator>>

API::
<<gui_FieldGroup_addField,addField>> -
<<gui_FieldGroup_bind,bind>> -
<<gui_FieldGroup_createField,createField>> -
<<gui_FieldGroup_getComponent,getComponent>> -
<<gui_FieldGroup_removeField,removeField>> -
<<gui_FieldGroup_setComponent,setComponent>> -
<<gui_FieldGroup_setFieldFactory,setFieldFactory>>

'''

[[gui_FileMultiUploadField]]
====== FileMultiUploadField

Компонент `FileMultiUploadField` позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается стандартное для операционной системы окно выбора файлов, в котором можно выбрать сразу несколько файлов для загрузки.

image::gui_multipleUpload.png[align="center"]

XML-имя компонента: `multiUpload`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Рассмотрим пример использования компонента.

* Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/multiupload_1.xml[]
----

[[gui_FileMultiUploadField_QueueUploadCompleteListener]]
* В контроллере экрана инжектируем сам компонент, а также интерфейсы <<file_upload,FileUploadingAPI>> и <<dataSupplier,DataSupplier>>. Затем в методе `init()` добавляем слушателей, которые будут реагировать на события успешной загрузки или ошибки:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/multiupload_2.java[]
----
+
Компонент загружает выбранные файлы во временное хранилище клиентского <<app_tiers,уровня>> и вызывает слушатель, добавленный методом `addQueueUploadCompleteListener()`. В данном слушателе вызовом метода `getUploadsMap()` у компонента можно получить мэп идентификаторов файлов во временном хранилище на имена файлов. Далее для каждого элемента мэп создается соответствующий объект `FileDescriptor` путем вызова `FileUploadingAPI.getFileDescriptor()`. Объект `com.haulmont.cuba.core.entity.FileDescriptor` (не путать с `java.io.FileDescriptor`) является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.
+
--
Ниже приведён список доступных слушателей для отслеживания процесса загрузки:

[[gui_FileMultiUploadField_FileUploadErrorListener]]
* `FileUploadStartListener`,

[[gui_FileMultiUploadField_FileUploadStartListener]]
* `FileUploadStartListener`,

[[gui_FileMultiUploadField_FileUploadFinishListener]]
* `FileUploadFinishListener`,

* `QueueUploadCompleteListener`.

Метод `FileUploadingAPI.putFileIntoStorage()` используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <<file_storage,FileStorage>>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект `FileDescriptor`. 

После загрузки файла в `FileStorage` выполняется сохранение экземпляра `FileDescriptor` в базе данных посредством вызова `DataSupplier.commit()`. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае `FileDescriptor` просто сохраняется в базе данных. Соответствующий файл будет доступен через экран *Administration* → *External Files*.

После обработки файлов необходимо очистить список файлов вызовом `clearUploads()` на случай повторной загрузки.
--

* Максимальный размер загружаемого файла определяется свойством приложения <<cuba.maxUploadSizeMb,cuba.maxUploadSizeMb>> и по умолчанию равен 20MB. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.

[[gui_FileMultiUploadField_accept]]
* XML-атрибут `accept` (и соответствующий метод `setAccept()`) может быть использован для установки маски расширений файлов в диалоге выбора файла. Пользователи будут иметь возможность выбрать "All files" и загрузить произвольные файлы.
+
Значением атрибута должен быть список масок, разделенных запятыми. Например: `++*.jpg,*.png++`.

[[gui_FileMultiUploadField_fileSizeLimit]]
* XML-атрибут `fileSizeLimit` (и соответствующий метод `setFileSizeLimit()`) может быть использован для установки максимально допустимого размера файла. Значением атрибута должно быть целое число для указания количества байт. Данный лимит устанавливает ограничение для каждого файла.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/multiupload_3.xml[]
----

[[gui_FileMultiUploadField_permittedExtensions]]
* XML-атрибут `permittedExtensions` (и соответствующий метод `setPermittedExtensions()`) может быть использован для установки "белого списка" допустимых расширений загружаемых файлов.
+
Значением атрибута должен быть набор строк, в котором каждая строка - это допустимое расширение с лидирующей точкой. Например:
+
[source,java]
----
uploadField.setPermittedExtensions(Sets.newHashSet(".png", ".jpg"));
----

[[gui_FileMultiUploadField_dropZone]]
* XML-атрибут `dropZone` используется для указания <<gui_BoxLayout,BoxLayout>>, который будет использован в качестве целевой площадки для перетаскивания файлов извне браузера. Если стиль контейнера <<gui_FileUploadField_dropZone,не переопределён>>, выбранный контейнер будет подсвечиваться, когда пользователь переносит над ним файлы, без наведения файла контейнер не отображается.

В разделе <<images_recipe>> приведен более сложный пример работы с загруженными файлами.

'''

Атрибуты multiUpload::
<<gui_FileMultiUploadField_accept,accept>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_FileMultiUploadField_dropZone,dropZone>> -
<<gui_FileMultiUploadField_fileSizeLimit,fileSizeLimit>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_FileMultiUploadField_permittedExtensions,permittedExtensions>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Слушатели multiUpload::
<<gui_FileMultiUploadField_FileUploadErrorListener,FileUploadErrorListener>> -
<<gui_FileMultiUploadField_FileUploadFinishListener,FileUploadFinishListener>> -
<<gui_FileMultiUploadField_FileUploadStartListener,FileUploadStartListener>> -
<<gui_FileMultiUploadField_QueueUploadCompleteListener,QueueUploadCompleteListener>>

'''

[[gui_FileUploadField]]
====== FileUploadField

Компонент `FileUploadField` позволяет пользователю загружать файлы на сервер. Компонент может содержать заголовок, ссылку на загруженный файл и две кнопки: для загрузки файла и для очистки. При нажатии на кнопку загрузки на экране отображается стандартное для операционной системы окно, в котором можно выбрать один файл. Чтобы дать пользователю возможность загружать сразу несколько файлов, используйте компонент <<gui_FileMultiUploadField,FileMultiUploadField>>.

image::gui_upload.png[align="center"]

XML-имя компонента: `upload`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

* `FileUploadField` автоматически используется внутри <<gui_FieldGroup,FieldGroup>> для атрибутов типа `FileDescriptor`. В этом случае компонент выглядит как на приведенном выше скриншоте и не требует никакого конфигурирования. Загруженный файл сразу же сохраняется в <<file_storage,file storage>>, а соответствующий `FileDescriptor` - в базу данных.

* Компонент можно использовать вне `FieldGroup` и подключить к источнику данных. В примере ниже предполагается, что источник данных `personDs` содержит сущность с атрибутом `photo`, который является ссылкой на `FileDescriptor`:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/upload_0.xml[]
----

* Сохранением файла и `FileDescriptor` можно также управлять программно.

** Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/upload_1.xml[]
----

[[gui_FileUploadField_FileUploadSucceedListener]]
** В контроллере экрана инжектируем сам компонент, а также интерфейсы <<file_upload,FileUploadingAPI>> и <<dataSupplier,DataSupplier>>. Затем в методе `init()` добавляем  слушатели, которые будут реагировать на события успешной загрузки или ошибки:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/upload_2.java[]
----
+
--
Компонент загружает файл во временное хранилище клиентского <<app_tiers,уровня>> и вызывает слушатель, добавленный методом `addFileUploadSucceedListener()`. В этом слушателе у компонента запрашивается объект `FileDescriptor`, соответствующий загруженному файлу. Объект `com.haulmont.cuba.core.entity.FileDescriptor` является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.

Метод `FileUploadingAPI.putFileIntoStorage()` используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <<file_storage,FileStorage>>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект `FileDescriptor`. Оба эти параметра предоставляет `FileUploadField`.

После загрузки файла в `FileStorage` выполняется сохранение экземпляра `FileDescriptor` в базе данных посредством вызова `DataSupplier.commit()`. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае `FileDescriptor` просто сохраняется в базе данных. Соответствующий файл будет доступен через экран *Administration* → *External Files*.

Слушатель, добавленный методом `addFileUploadErrorListener()`, вызывается в случае ошибки загрузки файла во временное хранилище клиентского уровня.

Ниже приведён полный список доступных слушателей для отслеживания процесса загрузки:

[[gui_FileUploadField_AfterValueClearListener]]
* `AfterValueClearListener`,

[[gui_FileUploadField_BeforeValueClearListener]]
* `BeforeValueClearListener`,

[[gui_FileUploadField_FileUploadErrorListener]]
* `FileUploadErrorListener`,

[[gui_FileUploadField_FileUploadFinishListener]]
* `FileUploadFinishListener`

[[gui_FileUploadField_FileUploadStartListener]]
* `FileUploadStartListener`,

[[gui_FileUploadField_FileUploadSucceedListener]]
* `FileUploadSucceedListener`,

* `ValueChangeListener`.
--

[[gui_FileUploadField_fileStoragePutMode]]
* XML-атрибут `fileStoragePutMode` задает режим сохранения файла и соответствующего `FileDescriptor`. В режиме `IMMEDIATE` это делается автоматически сразу после загрузки файла во временное хранилище клиентского уровня. В режиме `MANUAL` необходимо сделать это в листенере `FileUploadSucceedListener`. Режим `IMMEDIATE` выбирается по умолчанию, когда `FileUploadField` используется внутри `FieldGroup`. В противном случае, по умолчанию выбирается `MANUAL`.

[[gui_FileUploadField_uploadButtonCaption]]
* XML-атрибуты `uploadButtonCaption`, `uploadButtonIcon` и `uploadButtonDescription` позволяют задать параметры кнопки загрузки.

[[gui_FileUploadField_showFileName]]
* XML-атрибут `showFileName` управляет отображением имени загруженного файла рядом с кнопкой загрузки. По умолчанию `false`.

[[gui_FileUploadField_showClearButton]]
* XML-атрибут `showClearButton` управляет видимостью кнопки очистки. По умолчанию `false`.

[[gui_FileUploadField_clearButtonCaption]]
* XML-атрибуты `clearButtonCaption`, `clearButtonIcon` и `clearButtonDescription` позволяют задать параметры кнопки очистки, если она видима.

[[gui_FileUploadField_accept]]
* XML-атрибут `accept` (и соответствующий метод `setAccept()`) может быть использован для установки маски расширений файлов в диалоге выбора файла. Пользователи будут иметь возможность выбрать "All files" и загрузить произвольные файлы.
+
Значением атрибута должен быть список масок, разделенных запятыми. Например: `++*.jpg,*.png++`.

* Максимальный размер загружаемого файла определяется свойством приложения <<cuba.maxUploadSizeMb,cuba.maxUploadSizeMb>> и по умолчанию равен 20MB. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.

[[gui_FileUploadField_fileSizeLimit]]
* XML-атрибут `fileSizeLimit` (и соответствующий метод `setFileSizeLimit()`) может быть использован для установки максимально допустимого размера файла. Значением атрибута должно быть целое число для указания количества байт.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/upload_3.xml[]
----

[[gui_FileUploadField_permittedExtensions]]
* XML-атрибут `permittedExtensions` (и соответствующий метод `setPermittedExtensions()`) может быть использован для установки "белого списка" допустимых расширений загружаемых файлов.
+
Значением атрибута должен быть набор расширений с лидирующими точками, разделенных запятыми. Например:
+
[source,java]
----
uploadField.setPermittedExtensions(Sets.newHashSet(".png", ".jpg"));
----

[[gui_FileUploadField_dropZone]]
* XML-атрибут `dropZone` используется для указания <<gui_BoxLayout,BoxLayout>>, который будет использован в качестве целевой площадки для перетаскивания файлов извне браузера. Зона перетаскивания может занимать всю площадь диалогового окна. Выбранный контейнер будет подсвечиваться, когда пользователь переносит над ним файлы, без наведения файла контейнер не отображается.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/dropZone.xml[]
----
+
image::gui_dropZone.png[align="center"]

+
Чтобы сделать область dropZone статической и отображать её постоянно, необходимо назначить её контейнеру готовый стиль `dropzone-container`. В этом случае контейнер необходимо оставить пустым, поместив в него только текстовый компонент `label`:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/dropzone_static.xml[]
----
+
image::gui_dropZone_static.png[align="center"]

В разделе <<images_recipe>> приведен более сложный пример работы с загруженными файлами.

'''

Атрибуты upload::
<<gui_FileUploadField_accept,accept>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_FileUploadField_clearButtonCaption,clearButtonCaption>> -
<<gui_FileUploadField_clearButtonCaption,clearButtonDescription>> -
<<gui_FileUploadField_clearButtonCaption,clearButtonIcon>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_FileUploadField_dropZone,dropZone>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_FileUploadField_fileSizeLimit,fileSizeLimit>> -
<<gui_FileUploadField_fileStoragePutMode,fileStoragePutMode>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_FileUploadField_permittedExtensions,permittedExtensions>> -
<<gui_attr_property,property>> -
<<gui_FileUploadField_showClearButton,showClearButton>> -
<<gui_FileUploadField_showFileName,showFileName>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_FileUploadField_uploadButtonCaption,uploadButtonCaption>> -
<<gui_FileUploadField_uploadButtonCaption,uploadButtonDescription>> -
<<gui_FileUploadField_uploadButtonCaption,uploadButtonIcon>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

Слушатели upload::
<<gui_FileUploadField_AfterValueClearListener,AfterValueClearListener>> -
<<gui_FileUploadField_BeforeValueClearListener,BeforeValueClearListener>> -
<<gui_FileUploadField_FileUploadErrorListener,FileUploadErrorListener>> -
<<gui_FileUploadField_FileUploadFinishListener,FileUploadFinishListener>> -
<<gui_FileUploadField_FileUploadStartListener,FileUploadStartListener>> -
<<gui_FileUploadField_FileUploadSucceedListener,FileUploadSucceedListener>>

'''

[[gui_Filter]]
====== Filter

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=multiple-filter" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Filter` − универсальное средство фильтрации списков сущностей, извлекаемых из базы данных для отображения в табличном виде. Компонент позволяет производить быструю фильтрацию данных по произвольному набору условий, а также создавать фильтры для многократного использования.

`Filter` должен быть связан с <<datasources,источником данных>> `collectionDatasource` содержащим <<datasource_query,запрос>> на JPQL. Принцип действия фильтра основан на модификации этого запроса в соответствии с критериями, заданными пользователем. Таким образом фильтрация осуществляется на уровне БД при выполнении транслированного из JPQL в SQL запроса, и на Middleware и клиентский <<app_tiers,уровень>> загружаются только отобранные данные.

[[gui_Filter_use]]
*Использование фильтра*

Типичный фильтр выглядит следующим образом:

image::gui_filter_descr.png[align="center"]

По умолчанию, компонент находится в режиме быстрой фильтрации. Это означает, что пользователь может добавить набор условий для однократного поиска данных. После закрытия экрана просмотра экземпляров сущности условия будут удалены.

Для того чтобы создать быстрый фильтр, нажмите на ссылку *Add search condition (Добавить условие поиска)*. Отобразится экран выбора условий:

image::gui_filter_conditions.png[align="center"]

Рассмотрим возможные типы условий:

* *Properties (Атрибуты)* – атрибуты данной сущности и связанных с ней сущностей. Отображаются персистентные атрибуты, явно заданные в элементе `property` XML-описателя фильтра, либо соответствующие правилам, указанным в элементе <<gui_Filter_properties,properties>>.

* *Custom conditions (Специальные условия)* – условия, заданные разработчиком в элементах `custom` XML-описателя фильтра.

* *Create new (Создать новое)* – позволяет создать новое произвольное условие на JPQL. Данный пункт доступен пользователю, если у него есть специфическое <<permissions,разрешение>> `cuba.gui.filter.customConditions`.

Выбранные условия отображаются в верхней части панель фильтра. Рядом с каждым условием находится кнопка image:gui_filter_remove_condition.png[], позволяющая удалить их из набора.

Быстрый фильтр можно сохранить для повторного использования в дальнейшем. Для этого нажмите на кнопку настроек фильтра и выберите *Save/Save as (Сохранить/Сохранить как)*. Во всплывающем окне задайте имя нового фильтра:

image::gui_filter_name.png[align="center"]

Фильтр будет сохранен в выпадающем меню кнопки *Search (Поиск)*.

Пункт меню *Reset filter (Сбросить фильтр)* позволяет сбросить все текущие условия поиска.

image::gui_filter_reset.png[align="center"]

Кнопка настроек фильтра содержит выпадающий список опций для управления фильтром:

* *Save (Сохранить)* – сохранить изменения в текущем фильтре.

* *Save as (Сохранить как)* – сохранить фильтр под новым именем.

* *Edit (Редактировать)* – открыть редактор фильтра (см. ниже).

* *Make default (Установить по умолчанию)* – установить фильтр по умолчанию для данного экрана. Фильтр будет автоматически выводиться на панель при каждом открытии экрана.

* *Remove (Удалить)* – удалить текущий фильтр. 

* *Pin applied (Закрепить)* – использовать результаты последнего поиска для последовательной фильтрации данных (см. <<gui_Filter_sequential_apply,Последовательное наложение фильтров>>).

* *Save as search folder (Сохранить как папку поиска)* – создать <<search_folder,папку поиска>> на основе текущего фильтра.

* *Save as application folder (Сохранить как папку приложения)* – создать <<search_folder,папку приложения>> на основе текущего фильтра. Эта опция доступна только пользователям со специфическим разрешением `cuba.gui.appFolder.global`.

Опция *Edit* открывает редактор фильтра, который дает возможность расширенной настройки текущего фильтра:

image::gui_filter_editor.png[align="center"]

Название фильтра указывается в поле *Filter name (Имя фильтра)*. Это имя будет отображаться в списке доступных фильтров для текущего экрана.

Фильтр можно сделать _global_ (то есть доступным для всех пользователей) с помощью установки флажка *Available for all users (Общий)* для всех пользователей, или установить текущий фильтр в качестве фильтра по умолчанию с помощью установки флажка *Default (По умолчанию)*. Для этой операции пользователю требуется специфическое <<permissions, разрешение>> CUBA > Фильтр > Создание/изменение глобальных фильтров.

В дереве содержатся условия фильтра. Условия можно добавлять с помощью кнопки *Add (Добавить)* менять местами при помощи кнопок image:gui_filter_cond_down.png[]/image:gui_filter_cond_up.png[] или удалять с помощью кнопки *Remove (Удалить)*.

Группировку условий по И или ИЛИ можно добавить с помощью соответствующих кнопок. Все добавленные на верхний уровень (то есть без явной группировки) условия объединяются по И.

При выборе условия в дереве в правой части редактора открывается список его свойств.

С помощью соответствующих флажков можно сделать выбранное в таблице условие скрытым или обязательным для заполнения. Параметр скрытого условия не отображается пользователю, поэтому он должны быть введен во время редактирования фильтра.

Свойство *Width* позволяет задать ширину поля ввода параметра для текущего условия. По умолчанию, условия на панели фильтров отображаются в три колонки. Ширина поля равняется количеству колонок, которое оно может занять (1, 2 или 3).

Значение параметра текущего условия по умолчанию можно задать в поле *Default value (Значение по умолчанию)*.

Специальный заголовок условия фильтрации можно задать в поле *Caption (Заголовок)*.

Поле *Operation* позволяет выбрать оператор поиска. Список доступных операторов зависит от типа атрибута.

[[gui_Filter_component]]
*Описание компонента Filter*

XML-имя компонента: `filter`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример объявления компонента в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_1.xml[]
---- 

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `collectionDatasource`, который выбирает экземпляры сущности `Car` с помощью JPQL запроса. Для компонента `filter` в его атрибуте `datasource` указан фильтруемый источник данных. Данные отображаются компонентом <<gui_Table,Table>>, связанным с этим же источником. 

Элемент `filter` может содержать вложенные элементы. Все они описывают условия, доступные пользователю для выбора в диалоге добавления условий:

[[gui_Filter_properties]]
* `properties` - позволяет сделать доступными сразу несколько атрибутов сущности. Данный элемент может иметь следующие атрибуты:
+
--
[[gui_Filter_properties_include]]
** `include` - обязательный атрибут, содержит регулярное выражение, которому должно соответствовать имя атрибута сущности.

[[gui_Filter_properties_exclude]]
** `exclude` - содержит регулярное выражение, при соответствии которому атрибут сущности исключается из ранее включенных с помощью `include`.
+
Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_2.xml[]
---- 
+
При использовании элемента `properties` автоматически игнорируются следующие атрибуты сущности:

** Недоступные в связи с <<permissions,разрешениями>> подсистемы безопасности.

** Коллекции (`@OneToMany`, `@ManyToMany`).

** Неперсистентные атрибуты.

** Атрибуты, не имеющие <<entity_localization,локализованного названия>>.

** Атрибуты, аннотированные `@SystemLevel`.

** Атрибуты типа `byte[]`.

** Атрибут `version`.
--

[[gui_Filter_property]]
* `property` - явно включает атрибут сущности по имени. Данный элемент может иметь следующие атрибуты:
+
--
[[gui_Filter_property_name]]
** `name` - обязательный атрибут, содержит имя включаемого атрибута сущности. Может быть путем (через ".") по графу сущностей. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_3.xml[]
---- 

[[gui_Filter_property_caption]]
** `caption` - локализованное название атрибута сущности для отображения условия фильтра. Как правило, представляет из себя строку с префиксом `msg://` по правилам <<messageTools.loadString,MessageTools.loadString>>().
+
Если в атрибуте `name` указан путь (через ".") по графу сущностей, то атрибут `caption` является обязательным.

[[gui_Filter_property_paramWhere]]
** `paramWhere` − задает выражение на JPQL для отбора списка значений параметра условия, если параметр является связанной сущностью. Вместо алиаса сущности параметра в выражении нужно использовать метку (placeholder) `{E}`.
+
Например, предположим, что сущность `Car` имеет ссылку на сущность `Model`. Тогда список возможных значений параметра может быть ограничен только моделями `*Audi*`: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_4.xml[]
---- 
+
В выражении JPQL можно использовать параметры экрана, атрибуты сессии, а также компоненты экрана, в том числе отображающие другие параметры. Правила задания параметров запроса описаны в <<datasource_query,>>. 
+
Пример использования параметра сессии и параметра экрана: 
+
[source, jpql]
----
{E}.createdBy = :session$userLogin and {E}.name like :param$groupName
---- 
+
Используя `paramWhere` можно вводить зависимости между параметрами. Например, предположим, что `Manufacturer` является отдельной сущностью. То есть `Car` ссылается на `Model`, которая в свою очередь ссылается на `Manufacturer`. Тогда для фильтра по `Car` можно создать два условия: первое для выбора `Manufacturer` и второе для выбора `Model`. Чтобы ограничить список моделей выбранным перед этим производителем, добавьте в выражение `paramWhere` параметр: 
+
[source, jpql]
----
{E}.manufacturer.id = :component$filter.model_manufacturer90062
---- 
+
Здесь параметр ссылается на компонент, отображающий параметр Manufacturer. Имя компонента, отображающего параметр условия, можно узнать, вызвав контекстное меню на строке таблицы условий в редакторе фильтра:
+
[[gui_Filter_parameter_component_name]]
image::gui_filter_component_name.png[align="center"]

[[gui_Filter_property_paramView]]
** `paramView` − задает <<views,представление>>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. Например, `++_local++`. Если не указано, используется `++_minimal++`.
--

[[gui_Filter_custom]]
* `custom` - элемент, определяющий произвольное условие. Содержимым элемента должно быть выражение на JPQL (возможно использование <<jpql_macro,JPQL Macros>>), которое будет добавлено в условие `where` запроса источника данных. Вместо алиаса отбираемой сущности в выражении нужно использовать метку (placeholder) `{E}`. Параметр условия может быть только один, и если он есть, обозначается символом `?`.
+
--
Значение условия может содержать спецсимволы, например "%" или "_" для оператора "like". Если вам нужно экранировать эти символы, добавьте в условие `escape '<char>'`, например:

[source, sql]
----
{E}.name like ? escape '\'
----

Тогда если в значении параметра условия будет передано `foo\%`, поиск будет интерпретировать "%" как символ в имени а не как спецсимвол.

Пример фильтра с произвольными условиями:

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_5.xml[]
---- 

Созданные `custom` условия отображаются в секции *Специальные условия* диалога добавления условий:

image::gui_filter_custom.png[align="center"]

Атрибуты элемента `custom`:

[[gui_Filter_custom_name]]
** `name` − обязательный атрибут - имя условия.

[[gui_Filter_custom_caption]]
** `caption` − обязательный атрибут - локализованное название условия. Как правило, представляет из себя строку с префиксом `msg://` по правилам <<messageTools.loadString,MessageTools.loadString>>().

[[gui_Filter_custom_paramClass]]
** `paramClass` − Java-класс параметра условия. Если параметр отсутствует, то данный атрибут не обязателен.

[[gui_Filter_custom_inExpr]]
** `inExpr` − должен быть установлен в `true`, если выражение JPQL содержит условие `in (?)`. При этом пользователь будет иметь возможность ввести несколько значений параметра данного условия.

[[gui_Filter_custom_join]]
** `join` − необязательный атрибут для задания строки, которая будет добавлена в секцию `from` запроса источника данных. Это может потребоваться для создания условия по атрибуту связанной коллекции. Значение данного атрибута должно включать в себя предложения `join` или `left join`. 
+
Например, предположим что сущность `Car` имеет атрибут `repairs`, который представляет собой коллекцию экземпляров связанной сущности `Repair`. Тогда для фильтрации `Car` по атрибуту `description` сущности `Repair` можно написать следующее условие: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_6.xml[]
---- 
+
При использовании такого условия исходный запрос источника данных: 
+
[source, jpql]
----
select c from sample$Car c order by c.createTs
----
+
будет трансформирован в следующий:
+
[source, jpql]
----
select c from sample$Car c join c.repairs cr
where (cr.description like ?)
order by c.createTs
----

** `paramWhere` − задает выражение на JPQL для отбора списка значений параметра условия, если параметр является связанной сущностью. См. описание одноименного <<gui_Filter_property_paramWhere,атрибута>> элемента `property`.

** `paramView` − задает <<views,представление>>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. См. описание одноименного <<gui_Filter_property_paramView,атрибута>> элемента `property`.
--

Атрибуты `filter`:

[[gui_Filter_editable]]
* `editable` - если значение этого атрибута равно `false`, то кнопка *Фильтр* скрывается.

[[gui_Filter_manualApplyRequired]]
* `manualApplyRequired` − определяет, в какой момент будет применяться фильтр. Если значение атрибута равно `false`, то фильтр (пустой или по умолчанию) будет применяться сразу при открытии экрана. Это означает, что источник данных будет обновлен и связанные компоненты (например, `Table`) отобразят данные. Если значение атрибута равно `true`, то фильтр будет применяться только после нажатия на кнопку *Search*.
+
Данный атрибут имеет приоритет над свойством приложения <<cuba.gui.genericFilterManualApplyRequired,cuba.gui.genericFilterManualApplyRequired>>.

[[gui_Filter_useMaxResults]]
* `useMaxResults` − ограничивает размер страницы загружаемых в источник данных экземпляров сущности. По умолчанию `true`.
+
Если значение этого атрибута равно `false`, то фильтр не будет отображать поле *Show rows*. Количество записей в источнике данных (и соответственно, показываемых таблицей) будет ограничено только параметром `MaxFetchUI` механизма <<entity_statistics,статистики сущностей>>, по умолчанию - 10000.
+
Если данный атрибут не указан, или равен `true`, то поле *Show rows* отображается, если у пользователя также есть специфическое разрешение <<permissions,cuba.gui.filter.maxResults>>. Если разрешение `cuba.gui.filter.maxResults` отсутствует, то фильтр будет принудительно отбирать только первые N строк без возможности пользователя отключить это или указать другое N. Число N определяется параметрами `FetchUI`, `DefaultFetchUI`, получаемыми из механизма <<entity_statistics,статистики сущностей>>.
+
На рисунке далее показан вид фильтра со значением атрибута `useMaxResults="true"`, запретом специфического разрешения `cuba.gui.filter.maxResults` и параметром `DefaultFetchUI=2`
+
image::gui_filter_useMaxRezult.png[align="center"]

[[gui_Filter_textMaxResults]]
* `textMaxResults` - позволяет использовать текстовое поле вместо выпадающего списка в качестве поля *Show rows*. По умолчанию `false`.

[[gui_Filter_folderActionsEnabled]]
* `folderActionsEnabled` − при указании значения `false` позволяет скрыть следующие действия с фильтром: *Сохранить как папку поиска*, *Сохранить как папку приложения*. По умолчанию значение атрибута равно `true`, действия *Сохранить как папку поиска*, *Сохранить как папку приложения* доступны.

[[gui_Filter_applyTo]]
* `applyTo` − необязательный атрибут, содержит идентификатор компонента, с которым связан фильтр. Используется в случае, когда необходимо иметь доступ к <<gui_Table_presentations,представлениям>> связанного компонента-таблицы. Например, сохраняя фильтр как <<search_folder,папку поиска>> или как <<application_folder,папку приложения>>, можно указать, какое представление будет применятся при просмотре этой папки.
+
image::gui_filter_apply_to.png[align="center"]

[[gui_Filter_caption]]
* `caption` - позволяет задать заголовок панели фильтров.

[[gui_Filter_columnsCount]]
* `columnsCount` - задает количество колонок с условиями для конкретного фильтра. Значение по умолчанию - 3.

[[gui_Filter_defaultMode]]
* `defaultMode` - задает режим фильтра при открытии экрана. Возможные значения: `generic` и `fts`. При указании значения `fts` фильтр будет открыт в режиме полнотекстового поиска (если сущность индексируется). Значение по умолчанию - `generic`.

[[gui_Filter_modeSwitchVisible]]
* `modeSwitchVisible` - определяет видимость чек-бокса для перевода фильтра в режим полнотекстового поиска. Если полнотекстовый поиск невозможен, то чек-бокс будет невидим независимо от указаного значения. Возможные значения атрибута: `true` и `false`.

*Методы интерфейса Filter:*

* `setBorderVisible()` - определяет видимость границы фильтра. Значение по умолчанию - `true`.

*Слушатели компонента Filter:*
[[gui_Filter_ExpandedStateChangeListener]]
* `ExpandedStateChangeListener` - позволяет отслеживать изменения состояния компонета (свёрнутое/развёрнутое).

[[gui_Filter_FilterEntityChangeListener]]
* `FilterEntityChangeListener` - срабатывает при первом выборе фильтра и дальнейшем выборе сохранённых фильтров.

'''

Атрибуты filter::
<<gui_Filter_applyTo,applyTo>> -
<<gui_Filter_caption,caption>> -
<<gui_Filter_columnsCount,columnsCount>> -
<<gui_attr_datasource,datasource>> -
<<gui_Filter_defaultMode,defaultMode>> -
<<gui_Filter_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_Filter_folderActionsEnabled,folderActionsEnabled>> -
<<gui_attr_id,id>> -
<<gui_Filter_manualApplyRequired,manualApplyRequired>> -
<<gui_attr_margin,margin>> -
<<gui_Filter_modeSwitchVisible,modeSwitchVisible>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_attr_stylename,stylename>> -
<<gui_Filter_textMaxResults,textMaxResults>> -
<<gui_Filter_useMaxResults,useMaxResults>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы filter::
<<gui_Filter_custom,custom>> -
<<gui_Filter_properties,properties>> -
<<gui_Filter_property,property>>

Атрибуты properties::
<<gui_Filter_properties_exclude,exclude>> -
<<gui_Filter_properties_include,include>>

Атрибуты property::
<<gui_Filter_property_caption,caption>> -
<<gui_Filter_property_name,name>> -
<<gui_Filter_property_paramView,paramView>> -
<<gui_Filter_property_paramWhere,paramWhere>>

Атрибуты custom::
<<gui_Filter_custom_caption,caption>> -
<<gui_Filter_custom_name,name>> -
<<gui_Filter_custom_inExpr,inExpr>> -
<<gui_Filter_custom_join,join>> -
<<gui_Filter_custom_paramClass,paramClass>> -
<<gui_Filter_property_paramView,paramView>> -
<<gui_Filter_property_paramWhere,paramWhere>>

API::
<<gui_api_expanded,addExpandedStateChangeListener>> -
<<gui_Filter_FilterEntityChangeListener,addFilterEntityChangeListener>> -
<<gui_api_settings,applySettings>> -
<<gui_api_margin,getMargin>> -
<<gui_api_settings,saveSettings>> -
<<gui_api_margin,setMargin>>

'''

[[gui_Filter_permissions]]
*Права пользователей*

* Для создания/изменения/удаления глобальных (доступных всем пользователям) фильтров пользователь должен иметь разрешение `cuba.gui.filter.global`.

* Для создания/изменения `custom` условий пользователь должен иметь разрешение `cuba.gui.filter.customConditions`.

* Чтобы иметь возможность изменять максимальное количество строк на странице таблицы с помощью флажка и поля *Show rows* пользователь должен иметь разрешение `cuba.gui.filter.maxResults`. См. также атрибут фильтра <<gui_Filter_useMaxResults,useMaxResults>>.

Информация о том, как настраивать специфические разрешения, приведена в руководстве Подсистема безопасности.

[[gui_Filter_ext_params]]
*Внешние параметры для управления фильтрами*

[[gui_Filter_app_properties]]
* *Общесистемные параметры*
+
--
Следующие свойства приложения влияют на поведение фильтров:

* <<cuba.gui.genericFilterManualApplyRequired,cuba.gui.genericFilterManualApplyRequired>> − позволяет отключить автоматическое применение фильтра (то есть загрузку данных) сразу при открытии экрана. См. также атрибут фильтра <<gui_Filter_manualApplyRequired,manualApplyRequired>>.

* <<cuba.gui.genericFilterChecking,cuba.gui.genericFilterChecking>> − позволяет включить проверку заполненности хотя-бы одного условия перед применением фильтра.

* <<cuba.gui.genericFilterControlsLayout,cuba.gui.genericFilterControlsLayout>> − определяет расположение элементов внутри фильтра.

* <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> позволяет отключить механизм <<gui_Filter_sequential_apply,последовательного наложения фильтров>>.

* <<cuba.gui.genericFilterColumnsCount,cuba.gui.genericFilterColumnsCount>> - задает количество колонок по умолчанию для размещения условий фильтра. См также атрибут фильтра <<gui_Filter_columnsCount,columnsCount>>.

* <<cuba.gui.genericFilterConditionsLocation,cuba.gui.genericFilterConditionsLocation>> - задает расположение панели условий.

* <<cuba.gui.genericFilterPopupListSize,cuba.gui.genericFilterPopupListSize>> - задает количество позиций в выпадающем списке кнопки *Search*.
--

[[gui_Filter_screen_parameters]]
* *Параметры вызова экрана*
+
--
При вызове экрана можно указать, какой фильтр и с какими параметрами должен быть применен сразу после открытия экрана. Для этого фильтр должен быть заранее создан, сохранен в базе данных, и соответствующая запись в таблице `SEC_FILTER` должна иметь заполненное поле `CODE`. Параметры вызова экрана задаются в конфигурационном файле `web-menu.xml`.

Чтобы сохранить фильтр в базе данных, необходимо добавить скрипт вставки фильтра в скрипт `30.create-db.sql` сущности. Для генерации скрипта найдите фильтр в справочнике *Entity Inspector* меню *Administration*, в контекстном меню выберите *System Information*, нажмите на кнопку *Script for insert* и скопируйте текст скрипта.

Теперь можно добавить скрипт к экрану. Для указания кода фильтра в экран следует передать параметр с именем, равным идентификатору компонента фильтра в данном экране. Значением параметра должен быть код фильтра, который нужно установить и применить.

Для установки значений параметров фильтра в экран нужно передать параметры с именами, равными именам параметров, и значения в виде строк.

Пример описателя пункта главного меню, устанавливающего в открываемом экране `sample$Car.browse` в компоненте `carsFilter` фильтр с кодом `FilterByVIN`, с подстановкой в параметр условия `component$carsFilter.vin79216` значения `TMA`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_ext_param_1.xml[]
----

Следует отметить, что фильтр с установленным полем `CODE` обладает особыми свойствами:

* Его не могут редактировать пользователи.

* Название такого фильтра можно отображать на нескольких языках. Для этого в <<main_message_pack,главном пакете сообщений>> приложения должна быть строка с ключом, равным коду фильтра.
--

[[gui_Filter_sequential_apply]]
*Последовательное наложение фильтров*

При включенном свойстве приложения <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> в пользовательском интерфейсе компонента можно закреплять последний примененный фильтр и текущие результаты фильтрации. После этого можно выбрать другой фильтр или параметры и применить их на уже выбранных записях.

Данный подход позволяет решить две проблемы:

* Декомпозировать сложные фильтры.

* Применять фильтры на записи, отобранные с помощью папок <<application_folder,приложения>> или <<search_folder,поиска>>.

Чтобы применить этот механизм в пользовательском интерфейсе, выберите и примените один из фильтров. Затем нажмите на кнопку настроек фильтра и выберите *Pin applied (Закрепить)*. Фильтр закрепится в верхней части панели фильтров. Далее можно применить к выбранным записям другой фильтр. Так последовательно можно накладывать друг на друга любое количество фильтров. Также фильтры можно удалять последовательно с помощью кнопки image:gui_filter_remove.png[].

image::gui_filter_sequential.png[align="center"]

Механизм последовательного наложения фильтров основан на возможности <<dataManager,DataManager>> выполнять <<query_from_selected,последовательные запросы>>.

[[gui_Filter_params_api]]
*API для работы с параметрами фильтра*

Интерфейс `Filter` предоставляет методы для установки и чтения значений параметра фильтра из кода контроллера экрана:

* `setParamValue(String paramName, Object value)`
* `getParamValue(String paramName)`

`paramName` - имя параметра фильтра. Имя параметра фильтра является составной частью имени компонента, отображающего значение параметра фильтра. Как получить имя компонента рассматривалось <<gui_Filter_parameter_component_name, выше>>. Имя параметра - это часть имени компонента, находящаяся после последней точки. Например, если имя компонента `component$filter.model_manufacturer90062`, то имя параметра фильтра `model_manufacturer90062`.

Обратите внимание, что в методе <<abstractFrame,init()>> контроллера экрана данные методы использовать нельзя, т.к. в этот момент фильтр еще не проинициализирован. Вы можете работать с параметрами фильтра в методе <<abstractWindow,ready()>>.

[[gui_Filter_fts]]
*Режим полнотекстового поиска в фильтре*

Если источник данных фильтра содержит сущности, индексируемые системой полнотекстового поиска (см. link:{fts_man_url}[Платформа CUBA. Полнотекстовый поиск]), то в фильтре становится доступным режим полнотекстового поиска. Чтобы переключиться в него, используйте флажок *Full-Text Search* ("Полнотекстовый поиск").

image::gui_filter_fts.png[align="center"]

В этом режиме фильтр имеет всего одно поле для задание критериев поиска, и поиск производится по индексируемым подсистемой FTS полям сущности.

Если таблица указана в атрибуте <<gui_Filter_applyTo,applyTo>>, то при наведении указателя мыши на строку таблицы во всплывающем окне будет написано, в каких полях сущности было найдено условие поиска.

Для скрытия переключателя режима фильтра установите значение `false` атрибуту фильтра <<gui_Filter_modeSwitchVisible,modeSwitchVisible>>.

Если необходимо, чтобы фильтр по умолчанию открывался в режиме полнотекстового поиска, установите значение `fts` атрибуту <<gui_Filter_defaultMode,defaultMode>>.

[[gui_GroupTable]]
====== GroupTable

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=group-table" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `GroupTable` - это таблица с возможностью динамической группировки по любому полю. Для того чтобы сгруппировать таблицу по какой-либо колонке, нужно в заголовке таблицы перетащить эту колонку в позицию слева от элемента image:gui_groupTableIcon.png[]. Сгруппированные значения можно разворачивать и сворачивать с помощью кнопок image:gui_groupBox_plus.png[]/image:gui_groupBox_minus.png[].

image::gui_groupTableDragColumn.png[align="center"]

XML-имя компонента: `groupTable`.

Компонент реализован только для блока *Web Client*. В *Desktop Client* ведет себя как обычная таблица.

Для `GroupTable` в атрибуте `datasource` элемента `rows` должен быть указан <<datasources,groupDatasource>>. В противном случае группировка работать не будет.

Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/grouptable_1.xml[]
----

[[gui_GroupTable_group]]
`group` − необязательный элемент, может в единственном экземпляре находиться внутри <<gui_Table_columns,columns>>. Содержит набор элементов `column`, по которым будет выполняться первоначальная группировка при открытии экрана.

[[gui_GroupTable_groupAllowed]]
Элемент `column` может содержать атрибут `groupAllowed` с булевым значением. С помощью этого атрибута можно запретить пользователю группировать таблицу по данной колонке.

[[gui_GroupTable_showTotalAggregation]]
При включенном атрибуте `aggregatable` таблица отображает результаты агрегации по всем строкам в дополнительной строке вверху, а также результаты агрегации по группам. Отображение агрегации по всем строкам можно отключить, установив `false` в атрибуте `showTotalAggregation`.

При включенном атрибуте `multiselect` клик по строке группировки с зажатой клавишей *Ctrl* разворачивает группу (если была свёрнута) и применяет выделение ко всем строкам этой группы. При этом, если вся группа выделена, *Ctrl+click* не снимает выделение со всей группы. Вы по-прежнему можете снять выделение с отдельных строк, пользуясь стандартным поведением клавиши *Ctrl*.

В остальном функциональность `GroupTable` аналогична простой таблице <<gui_Table,Table>>.

'''

Атрибуты groupTable::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_GroupTable_showTotalAggregation,showTotalAggregation>> -
<<gui_Table_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_textSelectionEnabled,textSelectionEnabled>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы groupTable::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Элементы columns::
<<gui_Table_columns,column>> -
<<gui_GroupTable_group,group>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_GroupTable_groupAllowed,groupAllowed>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

API::
<<gui_Table_ColumnCollapseListener,addColumnCollapseListener>> -
<<gui_Table_CellClickListener,setClickListener>>

'''

[[gui_Image]]
====== Image

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=url-image" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Image` предназначен для отображения графического содержимого из различных источников. Компонент можно привязать к источнику данных или сконфигурировать программно.

XML имя компонента: `image`.

Компонент `Image` может отображать значение атрибута сущности с типом `FileDescriptor` или `byte[]`. Для этого используются атрибуты `datasource` и `property`, например:

[source, xml]
----
<image id="image" datasource="employeeDs" property="avatar"/>
----

В данном случае компонент отображает атрибут `avatar` сущности `Employee`, находящейся в источнике данных `employeeDs`.

Помимо источников данных, компонент `Image` может использовать в качестве источника содержимого различные типы ресурсов. Тип ресурса можно указать декларативно с помощью элементов `image`, перечисленных ниже:

[[gui_Image_classpath]]
* `classpath` - ресурс, расположенный в classpath.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_4.xml[]
----

[[gui_Image_file]]
* `file` - файл с изображением.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_2.xml[]
----

[[gui_Image_relativePath]]
* `relativePath` - относительный путь к файлу в каталоге приложения.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_10.xml[]
----

[[gui_Image_theme]]
* `theme` - ресурс из <<web_theme,темы>> приложения, например: `VAADIN/themes/customTheme/some/path/image.png`.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_3.xml[]
----

[[gui_Image_url]]
* `url` - ресурс, загружаемый по URL.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_1.xml[]
----

Атрибуты `image`:

[[gui_Image_scaleMode]]
* `scaleMode` - устанавливает режим масштабирования изображения. Доступны следующие режимы:
+
--
* `FILL` - изображение масштабируется, чтобы заполнить всю область компонента: используется вся ширина и высота компонента.

* `CONTAIN` - изображение подстраивается под размер компонента с сохранением пропорций, уменьшаясь или растягиваясь по меньшей стороне компонента.

* `SCALE_DOWN` - изображение изменяет размер, сравнивая разницу между `NONE` и `CONTAIN`, для того, чтобы найти наименьший конкретный размер объекта.

* `NONE` - изображение сохранит свой исходный размер, размер компонента будет равен размеру изображения.
--

[[gui_Image_alternateText]]
* `alternateText` - устанавливает альтернативный текст на случай, если ресурс недоступен или не задан.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_14.xml[]
----

Параметры ресурсов `image`:

[[gui_Image_bufferSize]]
* `bufferSize` - размер буфера, используемого для загрузки этого ресурса, в байтах.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_13.xml[]
----

[[gui_Image_cacheTime]]
* `cacheTime` - время хранения объекта в кэше в миллисекундах.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_11.xml[]
----

[[gui_Image_mimeType]]
* `mimeType` - MIME-тип ресурса.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/image_12.xml[]
----

Методы интерфейса `Image`:

[[gui_Image_setDatasource]]
* `setDatasource()` - устанавливает для изображения источник данных и его атрибут. Поддерживаются только атрибуты типов `FileDescriptor` и `byte[]`.
+
Программное указание источника данных позволяет, к примеру, отображать изображения в ячейках таблицы:
+
[source,java]
----
include::{sourcesdir}/gui_vcl/image_8.java[]
----
+
image::gui_Image_1.png[align="center"]

[[gui_Image_setSource]]
* `setSource()` - устанавливает источник изображения. Метод принимает тип ресурса и возвращает объект ресурса, который может быть сконфигурирован далее. Для каждого типа ресурсов есть свои методы, например, `setPath()` для `ThemeResource` или `setStreamSupplier()` для `StreamResource`:
+
--
[source,java]
----
include::{sourcesdir}/gui_vcl/image_7.java[]
----

или

[source,java]
----
include::{sourcesdir}/gui_vcl/image_9.java[]
----

Можно использовать следующие типы ресурсов, реализующие интерфейс `Resource`, или расширить их:

* `ClasspathResource` - для изображений, хранимых в classpath. Этот ресурс также можно использовать декларативно с помощью элемента `classpath` компонента `image`.

* `FileDescriptorResource` - для изображений, получаемых из `FileStorage`.

* `FileResource` - для изображений, хранимых в файловой системе. Этот ресурс также можно использовать декларативно с помощью элемента `file` компонента `image`.

* `RelativePathResource` - для изображений, хранимых в каталоге приложения. Этот ресурс также можно использовать декларативно с помощью элемента `relativePath` компонента `image`.

* `StreamResource` - для изображений, получаемых из потока.

* `ThemeResource` - для изображений темы, например, `VAADIN/themes/yourtheme/some/path/image.png`. Этот ресурс также можно использовать декларативно с помощью элемента `theme` компонента `image`.

* `UrlResource` - для изображений, загружаемых по указанному URL. Этот ресурс также можно использовать декларативно с помощью элемента `url` компонента `image`.
--

[[gui_Image_createResource]]
* `createResource()` - создаёт ресурс изображения указанного типа. Созданный объект может быть позже передан в метод `setSource()`.
+
--
[source,java]
----
include::{sourcesdir}/gui_vcl/image_6.java[]
----
--

[[gui_Image_SourceChangeListener]]
* `addSourceChangeListener()` - добавляет слушатель для отслеживания изменений источника изображения.

'''

Атрибуты image::
<<gui_attr_align,align>> -
<<gui_Image_alternateText,alternateText>> -
<<gui_attr_caption,caption>> -
<<gui_attr_colspan,colspan>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_responsive,responsive>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_Image_scaleMode,scaleMode>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты ресурсов image::
<<gui_Image_bufferSize,bufferSize>> -
<<gui_Image_cacheTime,cacheTime>> -
<<gui_Image_mimeType,mimeType>>

Элементы image::
<<gui_Image_classpath,classpath>> -
<<gui_Image_file,file>> -
<<gui_Image_relativePath,relativePath>> -
<<gui_Image_theme,theme>> -
<<gui_Image_url,url>>

API::
<<gui_Image_SourceChangeListener,addSourceChangeListener>> -
<<gui_Image_createResource,createResource>> -
<<gui_Image_scaleMode,setScaleMode>> -
<<gui_Image_setDatasource,setDatasource>> -
<<gui_Image_setSource,setSource>>

'''

[[gui_Label]]
====== Label

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-label" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Надпись (`Label`) − текстовый компонент, отображающий статический текст либо значение атрибута сущности.

XML-имя компонента: `label`

Компонент `Label` реализован для блоков *Web Client* и *Desktop Client*.

Пример задания надписи с текстом, взятым из <<message_packs,пакета локализованных сообщений>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_1.xml[]
----

[[gui_Label_value]]
Атрибут `value` предназначен для задания текста надписи.

В веб клиенте текст, содержащийся в атрибуте `value`, будет разбит на несколько строк, если по длине он превысит значение атрибута <<gui_attr_width,width>>. Поэтому для отображения многострочной надписи, достаточно указать абсолютное значение атрибута <<gui_attr_width,width>>. Если текст надписи слишком длинный, а значение атрибута <<gui_attr_width,width>> не определено, то текст будет урезан.

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_2.xml[]
----

Параметры надписи можно задать в контроллере экрана. Для этого необходимо задать компоненту идентификатор, по которому получить ссылку на него в контроллере:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_3.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/label_4.java[]
----

Компонент `Label` может отображать значение атрибута сущности. Для этого используются атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_5.xml[]
----

В данном случае компонент отображает атрибут `name` сущности `Customer`, находящейся в источнике данных `customerDs`.

[[gui_Label_htmlEnabled]]
Атрибут `htmlEnabled` указывает, каким образом будет рассматриваться значение атрибута <<gui_Label_value,value>>: при `htmlEnabled="true"` как HTML-код, иначе как строка. Обратите внимание, что не все HTML-теги поддерживаются в десктоп-реализации экрана.

[[gui_Label_stylenames]]
Стили компонента Label::
+
--
В веб-клиенте с темой, основанной на Halo, к компоненту `Label` можно применить заданные <<gui_Label_stylenames,стили>>. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
[source, xml]
----
include::{sourcesdir}/gui_vcl/label_6.xml[]
----
Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `LABEL_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/label_7.java[]
----

[[gui_label_bold]]
* `bold` - жирный шрифт. Подходит для выделения важных текстовых элементов UI.

[[gui_label_colored]]
* `colored` - цветной текст.

[[gui_label_failure]]
* `failure` - стиль сообщения об ошибке. Добавляет рамку вокруг компонента и пиктограмму рядом с текстом. Используется как уведомление рядом с другим компонентом.

[[gui_label_h1]]
* `h1` - стиль основных заголовков приложения.

[[gui_label_h2]]
* `h2` - стиль заголовков разделов приложения.

[[gui_label_h3]]
* `h3` - стиль подзаголовков.

[[gui_label_h4]]
* `h4` - стиль подзаголовков.

[[gui_label_light]]
* `light` - облегченный шрифт. Подходит для выделения второстепенных текстовых элементов UI.

[[gui_label_no-margin]]
* `no-margin` - убирает отступы заголовков.

[[gui_label_spinner]]
* `spinner` - стиль спиннера. Используйте для пустых компонентов `Label`, чтобы создать спиннер.

[[gui_label_success]]
* `success` - стиль сообщения об успешном выполнении. Добавляет рамку вокруг компонента и пиктограмму рядом с текстом.  Используется как уведомление рядом с другим компонентом.

--

'''

Атрибуты label::
<<gui_attr_align,align>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_Label_htmlEnabled,htmlEnabled>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_Label_value,value>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы label::
<<gui_formatter,formatter>>

Предопределенные стили label::
<<gui_label_bold,bold>> -
<<gui_label_colored,colored>> -
<<gui_label_failure,failure>> -
<<gui_label_h1,h1>> -
<<gui_label_h2,h2>> -
<<gui_label_h3,h3>> -
<<gui_label_h4,h4>> -
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>> -
<<gui_label_light,light>> -
<<gui_label_no-margin,no-margin>> -
<<gui_attr_stylename_small,small>> -
<<gui_label_spinner,spinner>> -
<<gui_label_success,success>> -
<<gui_attr_stylename_tiny,tiny>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_Link]]
====== Link

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-link" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Ссылка (`Link`) − компонент-гиперссылка, позволяющая открывать внешние веб-ресурсы единообразно для веб и десктоп клиента.

XML-имя компонента: `link`

Пример XML-описания компонента `link`: 

[source, xml]
----
<link caption="Link" url="https://www.cuba-platform.com" target="_blank"/>
----

Атрибуты `link`: 

[[gui_Link_url]]
* `url` - адрес ресурса.

[[gui_Link_target]]
* `target` - для веб клиента задает способ открытия страницы, аналогичен атрибуту `target` HTML-тега `<a>`.

'''

Атрибуты link::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_Link_url,url>> -
<<gui_Link_target,target>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_LinkButton]]
====== LinkButton

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=link-button" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Кнопка-ссылка (`LinkButton`) − кнопка, выглядящая как гиперссылка.

XML-имя компонента: `linkButton`

Компонент кнопки-ссылки реализован для блоков *Web Client* и *Desktop Client*.

Кнопка-ссылка может содержать текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.

image::gui_linkButtonTypes.png[align="center"]

Кнопка-ссылка отличается от обычной кнопки `Button` только своим внешним видом. Все свойства и поведение идентичны описанным для <<gui_Button,Button>>.

Пример XML-описания кнопки-ссылки, вызывающей метод `someMethod()` контроллера, с надписью (атрибут <<gui_attr_caption,caption>>), всплывающей подсказкой (атрибут <<gui_attr_description,description>>) и пиктограммой (атрибут <<gui_attr_icon,icon>>):

[source, xml]
----
include::{sourcesdir}/gui_vcl/linkbutton_1.xml[]
----

'''

Атрибуты linkButton::
<<gui_Button_action,action>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_Button_invoke,invoke>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_LookupField]]
====== LookupField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-lookupfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент для выбора значения из выпадающего списка. Выпадающий список реализует фильтрацию значений по мере ввода пользователя и постраничный вывод доступных значений.

image::gui_lookupField.png[align="center"]

XML-имя компонента: `lookupField`.

Компонент LookupField реализован для блоков *Web Client* и *Desktop Client*.

* Простейший вариант использования `LookupField` - выбор значения перечисления (`enum`) для атрибута сущности. Например, сущность `Role` имеет атрибут `type` типа `RoleType`, который является перечислением. Тогда для редактирования этого атрибута можно использовать `LookupField` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `roleDs` для сущности `Role`. В компоненте `lookupField` в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено. В данном случае атрибут является перечислением, и в выпадающем списке будут отображены <<enum_localization,локализованные названия>> всех значений этого перечисления.

* Аналогично можно использовать `LookupField` для выбора экземпляра связанной сущности. Для формирования списка опций используется атрибут <<gui_attr_optionsDatasource,optionsDatasource>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_2.xml[]
----
+
В данном случае компонент отобразит отобразит <<namePattern_annotation,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `colorsDs`, а выбранное значение подставится в атрибут `colour` сущности `Car`, находящейся в источнике данных `carDs`.
+
С помощью атрибута <<gui_attr_captionProperty,captionProperty>> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций.

* Список опций компонента может быть задан произвольно с помощью методов `setOptionsList()`, `setOptionsMap()` и `setOptionsEnum()`, либо с помощью XML-атрибута `optionsDatasource`.

[[gui_LookupField_setOptionsList]]
** Метод `setOptionsList()` позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_3.xml[]
----
+
Затем инжектируем компонент в контроллер и в методе `init()` задаем ему список опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_4.java[]
----
+
В выпадающем списке компонента отобразятся числа 2, 4, 5, 7. Выбранное число подставится в атрибут `numberOfSeats` сущности, находящейся в источнике данных `modelDs`.

[[gui_LookupField_setOptionsMap]]
** Метод `setOptionsMap()` позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента `numberOfSeatsField` в методе `init()` контроллера задаем мэп опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_5.java[]
----
+
В выпадающем списке компонента отобразятся строки `*two*`, `*four*`, `*five*`, `*seven*`. Однако значением компонента будет число, соответствующее выбранной строке. Оно и подставится в атрибут `numberOfSeats` сущности, находящейся в источнике данных `modelDs`.

[[gui_LookupField_setOptionsEnum]]
** `setOptionsEnum()` принимает в качестве параметра класс перечисления. Выпадающий список будет содержать локализованные названия значений перечисления, значением компонента будет являться выбранное значение перечисления.

[[gui_LookupField_iconProvider]]
* Каждый элемент выпадающего списка может иметь пиктограмму слева. Создайте реализацию интерфейса `LookupField.OptionIconProvider` в контроллере экрана и установите ее для компонента `lookupField`:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_8.java[]
----
+
image::gui_lookupField_2.png[align="center"]

[[gui_LookupField_filterMode]]
* С помощью атрибута `filterMode` можно задать тип фильтрации опций при вводе пользователя:

** `NO` − нет фильтрации.

** `STARTS_WITH` − по началу фразы.

** `CONTAINS` − по любому вхождению (используется по умолчанию).

* Если у компонента `LookupField` не установлен атрибут <<gui_attr_required,required>>, и если связанный атрибут сущности не объявлен как обязательный, то в списке опций компонента присутствует пустая строка, при выборе которой компонент возвращает значение `null`. Атрибут <<gui_attr_nullName,nullName>> позволяет задать строку, отображаемую в этом случае вместо пустой. Пример использования:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_6.xml[]
----
+
В данном случае вместо пустой строки отобразится строка `(none)`, при выборе которой в связанный атрибут сущности подставится значение `null`.
+
При программном задании списка опций методом `setOptionsList()` можно одну из опций передать в метод `setNullOption()`. Тогда при ее выборе пользователем значением компонента будет `null`.

* Компонент `LookupField` способен обрабатывать ввод пользователя при отсутствии подходящей опции в списке. Для этого используются методы `setNewOptionAllowed()` и `setNewOptionHandler()`. Например:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_7.java[]
----
+
Обработчик `NewOptionHandler` вызывается, если пользователь ввел некоторое значение, не совпадающее ни с одной из опций, и нажал *Enter*. В данном случае в обработчике создается новый экземпляр сущности `Colour`, его атрибут `name` устанавливается в значение, введенное пользователем, этот экземпляр добавляется в источник данных опций и выбирается в компоненте.
+
[[gui_LookupField_newOptionHandler]]
Вместо имплементации интерфейса `LookupField.NewOptionHandler` для обработки ввода пользователя можно использовать XML-атрибут `newOptionHandler` с указанным в нем методом контроллера. Данный метод должен иметь два параметра - первый типа `LookupField`, второй типа `String`. В них будут переданы соответственно экзампляр компонента и введенное пользователем значение. Атрибут `newOptionAllowed` используется вместо метода `setNewOptionAllowed()` для того, чтобы разрешить добавление новых опций.

[[gui_LookupField_nullOptionVisible]]
* XML-атрибут `nullOptionVisible` устанавливает видимость элемента со значением null в списке опций. Может работать только если атрибут <<gui_attr_required,required>> имеет значение `false`.

[[gui_LookupField_textInputAllowed]]
* XML-атрибут `textInputAllowed` используется для отключения возможности фильтрации опций с клавиатуры. Это бывает удобно для коротких списков. Значение по умолчанию - `true`.

[[gui_LookupField_pageLength]]
* XML-атрибут `pageLength` позволяет переопределить количество опций на одной странице выпадающего списка, заданное свойством приложения <<cuba.gui.lookupFieldPageLength,cuba.gui.lookupFieldPageLength>>.

* В веб-клиенте с темой, основанной на Halo, к компоненту `LookupField` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
+
--
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_8.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `LOOKUPFIELD_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_9.java[]
----

Стили компонента LookupField:

[[gui_LookupField_align-center]]
*  `align-center` - align the text inside the field to center.

[[gui_LookupField_align-right]]
* `align-right` - align the text inside the field to the right.

[[gui_LookupField_borderless]]
* `borderless` - removes the border and background from the text field.

--

'''

Атрибуты lookupField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_LookupField_nullOptionVisible,nullOptionVisible>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_LookupField_pageLength,pageLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_LookupField_textInputAllowed,textInputAllowed>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы lookupField::
<<gui_validator,validator>>

Предопределенные стили lookupField::
<<gui_LookupField_align-right,align-right>> -
<<gui_LookupField_align-center,align-center>> -
<<gui_LookupField_borderless,borderless>> -
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>> -
<<gui_LookupField_setOptionsEnum,setOptionsEnum>> -
<<gui_LookupField_setOptionsList,setOptionsList>> -
<<gui_LookupField_setOptionsMap,setOptionsMap>>

'''

[[gui_LookupPickerField]]
====== LookupPickerField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-lookuppickerfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `LookupPickerField` позволяет отображать экземпляр сущности в текстовом поле, выбирать экземпляр в выпадающем списке и выполнять действия нажатием на кнопки справа.

image::gui_lookupPickerField.png[align="center"]

XML-имя компонента: `lookupPickerField`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

`LookupPickerField` является по сути гибридом <<gui_LookupField,LookupField>> и <<gui_PickerField,PickerField>>, поэтому все описанное для этих интерфейсов верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для `LookupPickerField` это действия `lookup` image:lookupBtn.png[] и `open` image:openBtn.png[].

Пример использования `LookupPickerField` для выбора значения ссылочного атрибута `colour` сущности `Car`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/lookuppickerfield_1.xml[]
----

'''

Атрибуты lookupPickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_LookupField_pageLength,pageLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы lookupPickerField::
<<gui_Action,actions>> -
<<gui_validator,validator>>

Предопределённые стили lookupPickerField::
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

'''

[[gui_MaskedField]]
====== MaskedField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=masked-field" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Текстовое поле, в которое данные вводятся в определенном формате. `MaskedField` удобно использовать, например, для ввода телефонных номеров. 

XML-имя компонента: `maskedField`.

Компонент `MaskedField` реализован только для блока *Web Client*.

`MaskedField` в основном повторяет функциональность <<gui_TextField,TextField>>, за исключением того, что ему нельзя установить `datatype`. То есть `MaskedField` предназначен для работы только с текстом и строковыми атрибутами сущностей. `MaskedField` имеет следующие специфические атрибуты:

[[gui_MaskedField_mask]]
* `mask` - задает маску для поля. Чтобы задать маску, используются следующие символы:

** `#` - цифра

** `U` - буква верхнего регистра

** `L` - буква нижнего регистра

** `?` - буква

** `А` - буква или цифра

** `*` - любой символ

** `H` - hex символ в верхнем регистре

** `h` - hex символ в нижнем регистре

** `~` - знак + или -

[[gui_MaskedField_valueMode]]
* `valueMode` - определяет формат возвращаемого значения (с маской, или без) и может принимать значение `masked` или `clear`.

Пример текстового поля с маской для ввода номеров телефонов: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/maskedfield_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/maskedfield_2.java[]
----

image::gui_MaskedField.png[align="center"]

image::gui_MaskedField_maskedValueMode.png[align="center"]

'''

Атрибуты maskedField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_MaskedField_mask,mask>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_TextField_trim,trim>> -
<<gui_MaskedField_valueMode,valueMode>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы maskedField::
<<gui_validator,validator>>

API::
<<gui_TextField_EnterPressListener,addEnterPressListener>> -
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_OptionsGroup]]
====== OptionsGroup

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-optionsgroup" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент, который обеспечивает выбор из списка опций, используя группу переключателей для выбора единственного значения или группу флажков для выбора нескольких значений.

image::gui_optionsGroup.png[align="center"]

XML-имя компонента: `optionsGroup`.

Компонент `OptionsGroup` реализован для блоков *Web Client* и *Desktop Client*.

* Простейший вариант использования `OptionsGroup` - выбор значения перечисления (`enum`) для атрибута сущности. Например, сущность `Role` имеет атрибут `type` типа `RoleType`, который является перечислением. Тогда для редактирования этого атрибута можно использовать `OptionsGroup` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `roleDs` для сущности `Role`. В компоненте `optionsGroup` в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено.
+
В результате компонент примет следующий вид:
+
image::gui_optionsGroup_roleType.png[align="center"]

* Список опций компонента может быть задан произвольно с помощью методов `setOptionsList()`, `setOptionsMap()` и `setOptionsEnum()`, либо с помощью XML-атрибута `optionsDatasource`.

[[gui_OptionsGroup_setOptionsList]]
** Метод `setOptionsList()` позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_2.xml[]
----
+
Затем инжектируем компонент в контроллер и в методе `init()` задаем ему список опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_3.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_integerList.png[align="center"]
+
При этом метод `getValue()` компонента в зависимости от выбранной опции будет возвращать `Integer` значения 2,4,5,7.

[[gui_OptionsGroup_setOptionsMap]]
** Метод `setOptionsMap()` позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента `numberOfSeatsField` в методе `init()` контроллера задаем мэп опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_4.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_integerMap.png[align="center"]
+
При этом метод `getValue()` компонента в зависимости от выбранной опции будет возвращать `Integer` значения 2,4,5,7, а не строки, отображаемые на экране.

[[gui_OptionsGroup_setOptionsEnum]]
** `setOptionsEnum()` принимает в качестве параметра класс перечисления. Список опций будет состоять из локализованных названий значений перечисления, значением компонента будет являться выбранное значение перечисления.

** Компонент может брать список опций из источника данных. Для этого используется атрибут <<gui_attr_optionsDatasource,optionsDatasource>>. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_5.xml[]
----
+
В данном случае компонент `coloursField` отобразит <<namePattern_annotation,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `coloursDs`, а его метод `getValue()` вернет выбранный экземпляр сущности.
+
С помощью атрибута <<gui_attr_captionProperty,captionProperty>> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций.

[[gui_OptionsGroup_multiselect]]
* С помощью атрибута `multiselect` можно переключить `OptionsGroup` в режим множественного выбора. Если `multiselect` включен, то компонент отображается как группа независимых флажков, а значением компонента является список выбранных опций.
+
Например, создадим в XML-дескрипторе экрана компонент:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_6.xml[]
----
+
И в контроллере зададим для него список опций - значения перечисления `RoleType`:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_7.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_roleType_multi.png[align="center"]
+
В данном случае метод `getValue()` компонента вернет объект типа `java.util.List`, содержащий значения `RoleType.READONLY` и `RoleType.DENYING`.
+
Этот пример иллюстрирует также способность компонента `OptionsGroup` автоматически отображать локализованные значения перечислений, входящих в модель данных приложения.

[[gui_OptionsGroup_orientation]]
* Атрибут `orientation` задает расположение элементов группы. По умолчанию элементы располагаются по вертикали. Значение `horizontal` задает горизонтальное расположение.

'''

Атрибуты optionsGroup::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_OptionsGroup_multiselect,multiselect>> -
<<gui_attr_height,height>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_OptionsGroup_orientation,orientation>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы optionsGroup::
<<gui_validator,validator>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_OptionsGroup_setOptionsEnum,setOptionsEnum>> -
<<gui_OptionsGroup_setOptionsList,setOptionsList>> -
<<gui_OptionsGroup_setOptionsMap,setOptionsMap>>

'''

[[gui_OptionsList]]
====== OptionsList

`OptionsList` представляет собой вариацию компонента <<gui_OptionsGroup,OptionsGroup>> с представлением опций в виде вертикального прокручиваемого списка. Если включена возможность множественного выбора, элементы могут быть выбраны с удерживанием клвиши Ctrl при клике или диапазона при удерживании клавиши Shift.

image::gui_optionsList.png[align="center"]

XML-имя компонента: `optionsList`.

Компонент `OptionsList` реализован для блока *Web Client*.

[[gui_OptionsGroup_nullOptionVisible]]
По умолчанию компонент `OptionsList` отображает первый пустой элемент в списке опций. Пустой элемент можно скрыть с помощью атрибута `nullOptionVisible`, установив ему значение `false`.

Единственная разница в API между `OptionsList` и <<gui_OptionsGroup,OptionsGroup>> заключается в том, что `OptionsList` не имеет атрибута `orientation`.

'''

Атрибуты optionsList::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_OptionsGroup_multiselect,multiselect>> -
<<gui_OptionsGroup_nullOptionVisible,nullOptionVisible>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы optionsList::
<<gui_validator,validator>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_PasswordField]]
====== PasswordField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-passwordfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Текстовое поле, которое вместо символов, введенных пользователем, отображает эхо-символы. 

XML-имя компонента: `passwordField`.

`PasswordField` реализован для блоков *Web Client* и *Desktop Client*.

`PasswordField` в основном аналогичен компоненту <<gui_TextField,TextField>>, за исключением того, что ему нельзя установить `datatype`. То есть `PasswordField` предназначен для работы только с текстом и строковыми атрибутами сущностей. 

Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/passwordfield_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/passwordfield_2.java[]
----

image::gui_PasswordField.png[align="center"]

[[gui_PasswordField_autocomplete]]
Атрибут `autocomplete` позволяет включить сохранение паролей в веб браузере. По умолчанию отключено.

'''

Атрибуты passwordField::
<<gui_attr_align,align>> -
<<gui_PasswordField_autocomplete,autocomplete>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы passwordField::
<<gui_validator,validator>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_PickerField]]
====== PickerField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-pickerfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`PickerField` позволяет отображать экземпляр сущности в текстовом поле и выполнять действия нажатием на кнопки справа.

image::PickerField.png[align="center"]

XML-имя компонента: `pickerField`.

Компонент `PickerField` реализован для блоков *Web Client* и *Desktop Client*.

* Как правило, `PickerField` используется для работы со ссылочными атрибутами сущностей. При этом компоненту достаточно указать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `carDs` для некоторой сущности `Car`, имеющей атрибут `colour`. В элементе `pickerField` в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено в компоненте. Атрибут сущности должен являться ссылкой на другую сущность, в приведенном примере это `Colour`.

[[gui_PickerField_actions]]
* Для `PickerField` можно определить произвольное количество <<gui_Action,действий>>, отображаемых кнопками справа.
+
[[gui_PickerField_addAction]]
Это можно сделать как в XML-дескрипторе с помощью вложенного элемента `actions`, так и программно в контроллере методом `addAction()`.

** Существуют <<standard_actions,стандартные действия>>, определенные перечислением `PickerField.ActionType`: `lookup`, `clear`, `open`. Они выполняют соответственно выбор связанной сущности, очистку поля и открытие экрана редактирования выбранной связанной сущности. Для стандартных действий в XML не нужно определять никаких атрибутов, кроме идентификатора. Если при объявлении компонента никаких действий в элементе `actions` не задано, загрузчик XML определит для него действия `lookup` и `clear`. Чтобы добавить к действиям по умолчанию, например, действие `open`, нужно определить элемент `actions` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_2.xml[]
----
+
Элемент `action` не дополняет, а переопределяет набор стандартных действий, поэтому необходимо указывать идентификаторы всех требуемых действий. Компонент примет следующий вид:
+
image::gui_pickerFieldActionsSt.png[align="center"]
+
[[gui_PickerField_addLookupAction]] [[gui_PickerField_addOpenAction]] [[gui_PickerField_addClearAction]]
Для программного задания стандартных действий служат методы `addLookupAction()`, `addOpenAction()` и `addClearAction()`. Если компонент определен в XML-дескрипторе без вложенного элемента `actions`, то достаточно добавить недостающие действия:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_3.java[]
----
+
Если же компонент создается в контроллере, то никаких действий по умолчанию он не получает, и необходимо добавить все нужные действия явно:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_4.java[]
----
+
Стандартные действия можно параметризовать. В XML-дескрипторе возможности для этого ограничены: существует только атрибут `openType`, в котором можно задать режим открытия экрана выбора (для `LookupAction`) или редактирования (для `OpenAction`).
+
При программном создании действий можно задать любые свойства объектов `PickerField.LookupAction`, `PickerField.OpenAction` и `PickerField.ClearAction`, возвращаемых методами добавления стандартных действий. Например, так можно задать специфический экран выбора:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_5.java[]
----
+
Подробнее см. JavaDocs классов <<standard_actions,стандартных действий>>.

** Произвольные действия в XML-дескрипторе также определяются во вложенном элементе `actions`, например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_6.xml[]
----
+
Программно задать произвольное действие можно следующим образом:
+
[[gui_PickerField_setLookupScreen]]
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_7.java[]
----
+
Декларативное и программное создание действий подробно описано в разделе <<gui_Action>>.

[[gui_PickerField_metaclass]]
* Компонент `PickerField` можно использовать без непосредственной привязки к данным, то есть без указания <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>. В этом случае для указания типа сущности, с которой должен работать `PickerField`, используется атрибут `metaClass`. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_8.xml[]
----
+
Экземпляр выбранной сущности можно получить, инжектировав компонент в контроллер и вызвав его метод `getValue()`.
+
[WARNING]
====
Для правильной работы компонента `PickerField` необходима либо установка атрибута `metaClass`, либо одновременная установка атрибутов <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.
====

* В компоненте `PickerField` можно использовать горячие клавиши: см. <<shortcuts,>>.

'''

Атрибуты pickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы pickerField::
<<gui_PickerField_actions,actions>> -
<<gui_validator,validator>>

API::
<<gui_PickerField_addAction,addAction>> -
<<gui_PickerField_addClearAction,addClearAction>> -
<<gui_PickerField_addLookupAction,addLookupAction>> -
<<gui_PickerField_addOpenAction,addOpenAction>> -
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>> -
<<gui_PickerField_setLookupScreen,setLookupScreen>>

'''

[[gui_PopupButton]]
====== PopupButton

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-popupbutton" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Кнопка с выпадающим меню. Меню может содержать список действий или отображать собственное содержимое.

image::PopupButton.png[align="center"]

XML-имя компонента: `popupButton`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Кнопка `PopupButton` может содержать текст, заданный с помощью атрибута <<gui_attr_caption,caption>>, или <<gui_attr_icon,пиктограмму>> (или и то, и другое). Всплывающую подсказку можно задать с помощью атрибута <<gui_attr_description,description>>. На рисунке ниже отражены разные виды кнопок:

image::gui_popupButtonTypes.png[align="center"]

Элементы `popupButton`:

[[gui_PopupButton_actions]]
* `actions` - определяет выпадающий список <<gui_Action,действий>>.
+
Отображаются только следующие свойства действий: `caption`, `enable`, `visible`. Свойства `description`, `shortcut` игнорируются. Обработка свойства `icon` зависит от свойства приложения <<cuba.gui.showIconsForPopupMenuActions,cuba.gui.showIconsForPopupMenuActions>> и от атрибута `showActionIcons` компонента. Последний имеет приоритет.
+
Пример кнопки с выпадающим списком, содержащим два действия:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/popupButton_1.xml[]
----

[[gui_PopupButton_popup]]
* `popup` - позволяет создать собственное содержимое всплывающего меню. Если оно задано, элемент `actions` игнорируется.
+
Пример кнопки с собственным содержимым:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/popupButton_2.xml[]
----
+
image::gui_popupButton_custom.png[align="center"]

Атрибуты `popupButton`:

[[gui_PopupButton_autoClose]]
* `autoClose` - определяет, должно ли всплывающее меню закрываться автоматически после вызова действия.

[[gui_PopupButton_closePopupOnOutsideClick]]
* `closePopupOnOutsideClick` - если установлено значение `true`, щелчок по области за пределами всплывающего меню закрывает его. Это не относится к щелчкам по самой кнопке компонента.

[[gui_PopupButton_menuWidth]]
* `menuWidth` - устанавливает ширину всплывающего меню.

[[gui_PopupButton_popupOpenDirection]]
* `popupOpenDirection` - задаёт направление открытия всплывающего окна. Возможные значения:
+
** `BOTTOM_LEFT`,
+
** `BOTTOM_RIGHT`,
+
** `BOTTOM_CENTER`.

[[gui_PopupButton_showActionIcons]]
* `showActionIcons` - разрешает отображение пиктограмм для кнопок действий.

[[gui_PopupButton_togglePopupVisibilityOnClick]]
* `togglePopupVisibilityOnClick` - определяет, должны ли последовательные щелчки по кнопке компонента изменять видимость всплывающего меню.

Методы интерфейса `PopupButton`:

[[gui_PopupButton_PopupVisibilityListener]]
* `addPopupVisibilityListener()` - добавляет компоненту слушатель для отслеживания событий изменения видимости компонента.
+
[source, java]
----
popupButton.addPopupVisibilityListener(popupVisibilityEvent -> {
    showNotification("Popup visibility changed");
});
----

'''

Атрибуты popupButton::
<<gui_attr_align,align>> -
<<gui_PopupButton_autoClose,autoClose>> -
<<gui_attr_caption,caption>> -
<<gui_PopupButton_closePopupOnOutsideClick,closePopupOnOutsideClick>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_PopupButton_menuWidth,menuWidth>> -
<<gui_PopupButton_popupOpenDirection,popupOpenDirection>> -
<<gui_PopupButton_showActionIcons,showActionIcons>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_PopupButton_togglePopupVisibilityOnClick,togglePopupVisibilityOnClick>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы popupButton::
<<gui_PopupButton_actions,actions>> -
<<gui_PopupButton_popup,popup>>

API::
<<gui_PopupButton_PopupVisibilityListener,addPopupVisibilityListener>>

'''

[[gui_PopupView]]
====== PopupView

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=opening-popupview" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`PopupView` представляет собой компонент, позволяющий открывать popup с контейнером. Контейнер может открываться по клику на минимизированное значение или программно. Он может быть закрыт отведением курсора или по клику вне контейнера.

Обычный `PopupView` со скрытым и видимым popup-ом:

.Popup скрыт
image::gui_popup_view_mini.png[Popup hidden, align="center"]

.Popup открыт
image::gui_popup_view_mini_open.png[Popup visible, align="center"]

Компонент реализован для блока *Web Client*.

Пример использования PopupView, где минимизированное значение получено из пакета локализации:
[source, xml]
----
include::{sourcesdir}/gui_vcl/popup_view_1.xml[]
----

Содержимое popup-а должно быть контейнером, например <<gui_BoxLayout,BoxLayout>>.

Методы `PopupView`:
--
* `setPopupVisible()` позволяет открывать и закрывать popup программно.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/popup_view_2.java[]
----

* `setMinimizedValue()` позволяет программно менять минимизированное значение.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/popup_view_3.java[]
----

[[gui_PopupView_PopupVisibilityListener]]
* `addPopupVisibilityListener(PopupVisibilityListener listener)` позволяет отслеживать изменения видимости popup.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/popup_view_4.java[]
----
--

Атрибуты `PopupView`:
--
[[gui_PopupView_minimizedValue]]
* `minimizedValue` определяет текст минимизированного значения.

[[gui_PopupView_hideOnMouseOut]]
* Если атрибуту `hideOnMouseOut` установлено значение `false`, popup будет закрываться по клику вне popup.

[[gui_PopupView_captionAsHtml]]
* `captionAsHtml` позволяет использовать HTML теги в подписи компонента.
--

'''

Атрибуты popupView::
<<gui_attr_caption,caption>> -
<<gui_PopupView_captionAsHtml,captionAsHtml>> -
<<gui_attr_description,description>> -
<<gui_attr_height,height>> -
<<gui_PopupView_hideOnMouseOut,hideOnMouseOut>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_PopupView_minimizedValue,minimizedValue>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_PopupView_PopupVisibilityListener,addPopupVisibilityListener>>

'''

[[gui_ProgressBar]]
====== ProgressBar

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=normal-progressbar" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `ProgressBar` служит для отображения хода выполнения некоторого длительного процесса. 

image::gui_progressBar.png[align="center"]

XML-имя компонента: `progressBar`

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Пример использования компонента совместно с механизмом <<background_tasks,фоновых задач>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/progressbar_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/progressbar_2.java[]
----

Здесь в методе `BackgroundTask.progress()`, выполняемом в UI-потоке, компоненту `ProgressBar` устанавливается текущее значение. Значением компонента должно быть число типа `float` от `0.0` до `1.0`.

Изменения значения компонента `ProgressBar` можно отслеживать с помощью слушателя `ValueChangeListener`.

[[gui_ProgressBar_indeterminate]]
Если выполняемый процесс не может передавать информацию о прогрессе, то с помощью атрибута `indeterminate` можно задать отображение неопределенного состояния индикатора. Если значение атрибута равно `true`, то индикатор отображает неопределенное состояние. По умолчанию `false`. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/progressbar_3.xml[]
----
[[gui_ProgressBar_indeterminate-circle]]
По умолчанию неопределённый индикатор представляет собой горизонтальную полосу. Чтобы отобразить `ProgressBar` в виде крутящегося колесика, установите атрибут `stylename="indeterminate-circle"`.

[[gui_ProgressBar_point]]
Чтобы изменить форму индикатора на точку, перемещающуюся по полосе, вместо растущей полосы, используйте стиль `point`:

[source, java]
----
include::{sourcesdir}/gui_vcl/progressbar_4.java[]
----

'''

Атрибуты progressBar::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_ProgressBar_indeterminate,indeterminate>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Предопределенные стили progressBar::
<<gui_ProgressBar_indeterminate-circle,indeterminate-circle>> -
<<gui_ProgressBar_point,point>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_RelatedEntities]]
====== RelatedEntities

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-relatedentities" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`RelatedEntities` - компонент в виде кнопки с выпадающим списком, при нажатии показывающим список классов, связанных с сущностью, экземпляры которой отображаются в таблице. Пользователь выбирает интересующий его класс сущности, после чего открывается новый браузер с экземплярами данной сущности, связанными с выбранными экземплярами в начальной таблице.

image::gui_relatedEntities.png[align="center"]

XML-имя компонента: `relatedEntities`

Компонент реализован для блоков *Web Client* и *Desktop Client*.

При отборе связанных сущностей для отображения учитываются разрешения пользователя на открытие экранов, чтение сущностей и чтение атрибутов.

По умолчанию для выбранного в списке класса сущности открывается браузер сущности, определенный по соглашениям (`{entity_name}.browse`, `{entity_name}.lookup`). Опционально, экран можно явно задать в компоненте.

В открытом браузере динамически создается фильтр, который выбирает связанные с выбранными сущностями записи.

Пример описания компонента в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/relatedentities_1.xml[]
----

[[gui_RelatedEntities_for]]
Атрибут `for` является обязательным. В нем указывается идентификатор таблицы.

Атрибут `++openType="NEW_TAB"++` устанавливает режим открытия браузера (новая вкладка). По умолчанию браузер открывается в текущей вкладке.

Элемент `property` позволяет явно задать связанную сущность, которая будет отображаться в выпадающем списке.

Атрибуты `property`:

[[gui_RelatedEntities_property_name]]
* `name` - имя атрибута текущей сущности, ссылающегося на связанную сущность

[[gui_RelatedEntities_property_screen]]
* `screen` - идентификатор браузера, открывающегося при выборе сущности в списке

[[gui_RelatedEntities_property_filterCaption]]
* `filterCaption` - имя динамически формируемого фильтра

[[gui_RelatedEntities_exclude]]
Атрибут `exclude` позволяет исключить определенные связанные сущности из числа отображаемых. В качестве значения указывается регулярное выражение, отбирающее ссылочные атрибуты текущей сущности для исключения.

image::gui_relatedEntitiesTable.png[align="center"]

В платформе есть API для открытия экранов связанных сущностей без использования компонента `RelatedEntities`: интерфейс `RelatedEntitiesAPI` и его реализация `RelatedEntitiesBean`.
Логика задаётся методом `openRelatedScreen()`, который принимает коллекцию сущностей с одной стороны отношения, `MetaClass` отдельной сущности из этой коллекции и поле, являющееся ссылкой на связанные сущности.

[source, xml]
----
include::{sourcesdir}/gui_vcl/relatedentities_2.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/relatedentities_3.java[]
----

По умолчанию метод открывает стандартный экран просмотра списка. Дополнительно можно указать параметр `RelatedScreenDescriptor`, если требуется открыть экран, отличный от стандартного, или открыть его с параметрами. `RelatedScreenDescriptor` - это простой Java-объект, хранящий идентификатор экрана (`String`), тип его открытия (`WindowManager.OpenType`), заголовок фильтра (`String`) и параметры экрана (`Map<String, Object>`).

[source, java]
----
include::{sourcesdir}/gui_vcl/relatedentities_4.java[]
----

'''

Атрибуты relatedEntities::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_RelatedEntities_exclude,exclude>> -
<<gui_RelatedEntities_for,for>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_openType,openType>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты property::
<<gui_attr_caption,caption>> -
<<gui_RelatedEntities_property_filterCaption,filterCaption>> -
<<gui_RelatedEntities_property_name,name>> -
<<gui_RelatedEntities_property_screen,screen>>

'''

[[gui_RichTextArea]]
====== RichTextArea

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-richtextarea" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Текстовая область для отображения и ввода форматированного текста.

XML-имя компонента: `richTextArea`

Компонент `RichTextArea` реализован только для блока *Web Client*.

`RichTextArea` в основном повторяет функциональность `<<gui_TextField,TextField>>`, за исключением того, что ему нельзя установить `datatype`. То есть `RichTextArea` предназначен для работы только с текстом и строковыми атрибутами сущностей.

image::gui_RichTextAreaInfo.png[align="center"]

'''

Атрибуты richTextArea::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_SearchPickerField]]
====== SearchPickerField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-searchpickerfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `SearchPickerField` служит для поиска экземпляров сущностей по вводимой пользователем строке. Пользователю достаточно ввести несколько символов и нажать клавишу *Enter*. Если поиск дал несколько совпадений, найденные значения отображаются в виде выпадающего списка. Если же критерию поиска соответствует только один экземпляр, он сразу становится значением компонента. `SearchPickerField` позволяет также выполнять действия нажатием на кнопки справа.

image::gui_searchPickerFieldOverlap.png[align="center"]

См. также <<gui_SuggestionPickerField,SuggestionPickerField>>.

XML-имя компонента: `searchPickerField`.

Компонент реализован для блоков *Web Client* и *Desktop Client*.

* Для работы компонента `SearchPickerField` необходимо создать <<datasources,collectionDatasource>>, и задать в нем запрос, содержащий условия поиска. Условие обязательно должно содержать параметр с именем `custom$searchString` - именно в него компонент передает введенную пользователем подстроку при нажатии *Enter*. Источник данных с условием поиска должен быть указан в атрибуте <<gui_attr_optionsDatasource,optionsDatasource>> компонента. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/searchpickerfield_1.xml[]
----
+
В данном случае компонент будет искать экземпляры сущности `Colour` по вхождению подстроки в ее атрибут `name`. Префикс `(?i)` служит для регистро-независимого поиска (см. <<datasource_query_case_insensitive,Поиск подстроки без учета регистра>>). Выбранное значение подставится в атрибут `colour` сущности `Car`, находящейся в источнике данных `carDs`.
+
[[gui_SearchPickerField_escapeValueForLike]]
Атрибут `escapeValueForLike` со значением `true` позволяет искать значения, содержащие специальные символы `%`, `\` и `_` при помощи like. Чтобы использовать `escapeValueForLike = true`, необходимо добавить в запрос источника данных escape-значение:
+
[source, sql]
----
include::{sourcesdir}/gui_vcl/searchpickerfield_3.sql[]
----
+
Атрибут `escapeValueForLike` работает со всеми типами базы данных, кроме HSQLDB.

[[gui_SearchPickerField_minSearchStringLength]]
* С помощью атрибута `minSearchStringLength` можно задать минимальное количество символов, которое должен ввести пользователь для поиска значения.

* В контроллере экрана для компонента можно реализовать методы, вызываемые в двух случаях:
** если количество введенных символов меньше значения атрибута `minSearchStringLength`.

** если поиск введенных пользователем символов не дал результатов.
+
Пример реализации методов для вывода на экран сообщений:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/searchpickerfield_2.java[]
----

* `SearchPickerField` реализует интерфейсы <<gui_LookupField,LookupField>> и <<gui_PickerField,PickerField>>, поэтому все описанное для этих интерфейсов в части работы с сущностями верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для `SearchPickerField` это действия `lookup` image:lookupBtn.png[] и `open` image:openBtn.png[].

'''

Атрибуты searchPickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_SearchPickerField_minSearchStringLength,minSearchStringLength>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы searchPickerField::
<<gui_Action,actions>> -
<<gui_validator,validator>>

Предопределённые стили searchPickerField::
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_SideMenu]]
====== SideMenu

Компонент `SideMenu` позволяет создать боковое главное меню в <<main_window_layout,главном окне приложения>>, управлять элементами меню, добавлять пиктограммы и ярлыки и применять стили.

Его также можно использовать в экранах приложения как обычный визуальный компонент. Для этого необходимо добавить пространство имён `xmlns:main="http://schemas.haulmont.com/cuba/mainwindow.xsd"` в дескриптор экрана.

image::gui_sidemenu.png[align="center"]

XML-имя компонента: `sideMenu`.

Пример описания компонента в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/sidemenu.xml[]
----

CUBA Studio предоставляет готовый шаблон главного экрана с реализацией компонента `sideMenu` и готовыми стилями боковой панели:

[source, xml]
----
include::{sourcesdir}/gui_vcl/sidemenu_default.xml[]
----

*Атрибуты sideMenu:*

[[gui_SideMenu_selectOnClick]]
* `selectOnClick` - установка атрибута в `true` подсвечивает выделение элемента меню после его выбора кликом мыши. По умолчанию `false`.

image::gui_sidemenu_2.png[align="center"]

*Методы интерфейса SideMenu:*

[[gui_SideMenu_createMenuItem]]
* `createMenuItem` - создаёт новый объект элемента меню, но не добавляет его к меню. Идентификатор `id` должен быть уникальным в области всего меню.

[[gui_SideMenu_addMenuItem]]
* `addMenuItem` - добавляет элемент к меню.

[[gui_SideMenu_removeMenuItem]]
* `removeMenuItem` - удаляет элемент из списка элементов меню.

* `getMenuItem` - возвращает объект элемента меню по его идентификатору.

* `hasMenuItems` - возвращает `true`, если в меню есть вложенные элементы.

Компонент `SideMenu` предназначен для отображения элементов меню. Чтобы создать элемент меню, используется API компонента `MenuItem` в контроллере экрана. Методы, перечисленные ниже, можно использовать для динамического обновления элементов меню, реализуя бизнес-логику приложения. Пример программного создания элемента меню:

[source, java]
----
include::{sourcesdir}/gui_vcl/sidemenu_add.java[]
----

image::gui_sidemenu_3.png[align="center"]

*Методы интерфейса MenuItem:*

[[gui_SideMenu_MenuItem_setCaption]]
* `setCaption` - устанавливает заголовок элемента меню.

[[gui_SideMenu_MenuItem_setCaptionAsHtml]]
* `setCaptionAsHtml` - разрешает/запрещает использование HTML-заголовков.

[[gui_SideMenu_MenuItem_setBadgeText]]
* `setBadgeText` - устанавливает текст ярлыка элемента меню. Ярлыки представляют собой небольшие виджеты справа от элемента меню, к примеру:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/sidemenu_badge.java[]
----
+
image::gui_sidemenu_4.png[align="center"]

+
Текст ярлыка можно обновлять автоматически с помощью компонента <<gui_Timer,Timer>>:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/sidemenu_timer.java[]
----
+
image::gui_sidemenu_5.png[align="center"]

[[gui_SideMenu_MenuItem_setIcon]]
* `setIcon` - устанавливает пиктограмму элемента меню.

[[gui_SideMenu_MenuItem_setCommand]]
* `setCommand` - используется для описания действия, которое должно быть выполнено при выборе этого элемента меню кликом мыши.

[[gui_SideMenu_MenuItem_addChildItem]]
* `addChildItem/removeChildItem` - добавляет/удаляет элементы меню в подгруппу корневого элемента.

[[gui_SideMenu_MenuItem_setExpanded]]
* `setExpanded` - раскрывает или сворачивает подгруппы меню по умолчанию.

[[gui_SideMenu_MenuItem_setStyleName]]
* `setStyleName` - устанавливает один или более пользовательских стилей для компонента, заменяя все ранее заданные стили. Имена стилей при перечислении отделаются пробелами. Имя стиля должно быть названием существующего CSS-класса.
+
Стандартный шаблон главного экрана с `sideMenu` стилизован несколькими предопределёнными стилями: `c-sidemenu-layout`, `c-sidemenu-panel` и `c-sidemenu-title`. Стиль бокового меню по умолчанию `c-sidemenu` поддерживается только в рамках темы `Halo` и темах, её расширяющих. В теме `Havana` стили `sideMenu` не поддерживаются.

[[gui_SideMenu_MenuItem_setTestId]]
* `setTestId` - устанавливает значение `cuba-id` для тестирования UI.

'''

Атрибуты sideMenu::

<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_SideMenu_selectOnClick,selectOnClick>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты ftsfield::

<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API sideMenu::
<<gui_SideMenu_addMenuItem,addMenuItem>> -
<<gui_SideMenu_createMenuItem,createMenuItem>> -
<<gui_SideMenu_removeMenuItem,removeMenuItem>>

API menuItem::
<<gui_SideMenu_MenuItem_addChildItem,addChildItem>> -
<<gui_SideMenu_MenuItem_addChildItem,removeChildItem>> -
<<gui_SideMenu_MenuItem_setBadgeText,setBadgeText>> -
<<gui_SideMenu_MenuItem_setCaption,setCaption>> -
<<gui_SideMenu_MenuItem_setCaptionAsHtml,setCaptionAsHtml>> -
<<gui_SideMenu_MenuItem_setCommand,setCommand>> -
<<gui_SideMenu_MenuItem_setExpanded,setExpanded>> -
<<gui_SideMenu_MenuItem_setIcon,setIcon>> -
<<gui_SideMenu_MenuItem_setStyleName,setStyleName>> -
<<gui_SideMenu_MenuItem_setTestId,setTestId>>

'''

[[gui_SourceCodeEditor]]
====== SourceCodeEditor

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-codeeditor" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`SourceCodeEditor` - компонент для отображения и ввода исходного кода. Он представляет собой многострочное текстовое поле с возможностью подсветки кода и отображения полей печати и номеров строк.

XML-имя компонента: `sourceCodeEditor`.

Компонент `SourceCodeEditor` реализован для блока *Web Client*.

`SourceCodeEditor` в основном повторяет функциональность <<gui_TextField,TextField>> и имеет следующие специфические атрибуты:

[[gui_sourceCodeEditor_handleTabKey]]
* если `handleTabKey` имеет значение `true`, нажатие на кнопку *Tab* на клавиатуре добавляет отступ текущей строки, если значение равно `false`, нажатие перемещает курсор или фокус на следующую позицию табуляции. Данный атрибут необходимо установить во время инициализации экрана, он не может быть изменён во время работы.

Следующие свойства можно легко изменять в работающем приложении:
[[gui_sourceCodeEditor_highlightActiveLine]]
* `highlightActiveLine` используется для подсветки текущей строки, на которой находится курсор.

[[gui_sourceCodeEditor_mode]]
* атрибут `mode` предоставляет список языков, для которых поддерживается подсветка синтаксиса. Этот список задан в перечислении `Mode` интерфейса `SourceCodeEditor` и включает в себя следующие языки: Java, HTML, XML, Groovy, SQL, JavaScript, Properties и Text без подсветки.

[[gui_sourceCodeEditor_printMargin]]
* `printMargin` определяет, отображать или скрыть линию края печати в текстовом поле.

[[gui_sourceCodeEditor_showGutter]]
* `showGutter` используется для отображения или скрытия левой панели с номерами строк.

Ниже приведён пример компонента `SourceCodeEditor` с динамически настраиваемыми атрибутами.

XML-дескриптор:
[source, xml]
----
include::{sourcesdir}/gui_vcl/sourceCodeEditor_1.xml[]
----
Контроллер:
[source, java]
----
include::{sourcesdir}/gui_vcl/sourceCodeEditor_2.java[]
----
Результат выполения кода:

image::gui_SourceCodeEditor_1.png[align="center"]

Компонент `SourceCodeEditor` также поддерживает автодополнение кода, определяемое с помощью класса `Suggester`. Чтобы подключить автодополнение, необходимо переопределить и вызвать метод `setSuggester`, например:
[source, java]
----
include::{sourcesdir}/gui_vcl/sourceCodeEditor_1.java[]
----

Результат:

image::gui_SourceCodeEditor_2.png[align="center"]

'''

Атрибуты sourceCodeEditor::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_colspan,colspan>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_sourceCodeEditor_handleTabKey,handleTabKey>> -
<<gui_attr_height,height>> -
<<gui_sourceCodeEditor_highlightActiveLine,highlightActiveLine>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_sourceCodeEditor_mode,mode>> -
<<gui_sourceCodeEditor_printMargin,printMargin>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_sourceCodeEditor_showGutter,showGutter>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_SuggestionPickerField]]
====== SuggestionPickerField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=datasource-suggestion-picker-field" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `SuggestionPickerField` предназначен для поиска экземпляров сущности по строке, вводимой пользователем. Он отличается от <<gui_SearchPickerField,SearchPickerField>> тем, что обновляет список опций при каждом вводе символа пользователем без необходимости нажимать Enter. Список опций загружается асинхронно в соответствии с логикой, задаваемой разработчиком на стороне сервера.

`SuggestionPickerField` является также <<gui_PickerField,PickerField>> и может содержать действия, отображаемые кнопками справа.

image::gui_suggestionPickerField_1.png[align="center"]

XML-имя компонента: `suggestionPickerField`.

Компонент реализован для блока *Web Client*.

`SuggestionPickerField` используется для выбора значений ссылочных атрибутов, поэтому для компонента обычно указываются атрибуты `datasource` и `property`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField.xml[]
----

Атрибуты `suggestionPickerField`:

[[gui_suggestionPickerField_asyncSearchDelayMs]]
* `asyncSearchDelayMs` - устанавливает задержку между последним нажатием клавиши и асинхронным поиском.

[[gui_suggestionPickerField_metaClass]]
* `metaClass` - указывает ссылку на интерфейс метаданных компонента в случае, если компонент используется без непосредственной привязки к данным, то есть без указания <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.

[[gui_suggestionPickerField_minSearchStringLength]]
* `minSearchStringLength` - устанавливает минимальную длину строки для начала поиска.

[[gui_suggestionPickerField_suggestionsLimit]]
* `suggestionsLimit` - устанавливает ограничение количества выводимых подсказок.

Элементы `suggestionPickerField`:

[[gui_suggestionPickerField_actions]]
* `actions` - необязательный элемент для описания действий, связанных с компонентом. Кроме описания произвольных действий, поддерживаются следующие <<picker_actions,стандартные действия>>, определяемые перечислением `PickerField.ActionType`: `lookup`, `open`, `clear`.

[[gui_suggestionPickerField_query]]
* `query` - элемент, позволяющий задать запрос для выбора предлагаемых значений. Элемент `query`, в свою очередь, имеет следующие атрибуты:
+
--
[[gui_suggestionPickerField_query_entityClass]]
** `entityClass` (обязательный атрибут) - полное квалифицированное имя класса сущности.

[[gui_suggestionPickerField_query_escapeValueForLike]]
** `escapeValueForLike` - позволяет разрешить поиск по значениям, содержащим специальные символы: `%`, `\`, и т.д. По умолчанию `false`,

[[gui_suggestionPickerField_query_searchStringFormat]]
** `searchStringFormat` - строка Groovy, что позволяет использовать в запросе валидные Groovy-выражения.

[source, xml]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField_2.xml[]
----
--

Простой пример использования SuggestionPickerField::
+
--
Как правило, для компонента достаточно установить `SearchExecutor`. `SearchExecutor` - это функциональный интерфейс, содержащий один метод: `List<E extends Entity> search(String searchString, Map<String, Object> searchParams)`:

[source, java]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField.java[]
----

[WARNING]
====
Метод `search()` выполняется в фоновом потоке, поэтому он не может обращаться к визуальным компонентам или источникам данных, связанным с визуальными компонентами. Можно использовать <<dataManager,DataManager>> или напрямую вызывать сервисы среднего слоя, или обрабатывать и возвращать данные, предварительно загруженные в экран.
====

Параметр `searchString` может быть использован для фильтрации кандидатов по строке, введенной пользователем:

[source, java]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField_3.java[]
----
--

Использование ParametrizedSearchExecutor::
+
--
В примерах выше параметр `searchParams` является пустым. Для поиска с параметрами используется `ParametrizedSearchExecutor`:

[source, java]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField_1.java[]
----
--

Использование EnterActionHandler и ArrowDownActionHandler::
+
--
Компонент также может быть использован с обработчиками событий `EnterActionHandler` и `ArrowDownActionHandler`. Эти листнеры срабатывают, когда пользователь нажимает клавиши *Enter* или *Arrow Down* при скрытом всплывающем окне для подсказок. Они также представляют собой функциональные интерфейсы с единственным методом с одним параметром - `currentSearchString`. Вы можете настроить и свои обработчики событий и использовать метод `showSuggestions()` интерфейса `SuggestionField`, который принимает список сущностей, для отображения подсказок:

[source, java]
----
include::{sourcesdir}/gui_vcl/suggestionPickerField_2.java[]
----
--

'''

Атрибуты suggestionPickerField::
<<gui_attr_align,align>> -
<<gui_suggestionPickerField_asyncSearchDelayMs,asyncSearchDelayMs>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_colspan,colspan>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_suggestionPickerField_metaClass,metaClass>> -
<<gui_suggestionPickerField_minSearchStringLength,minSearchStringLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_responsive,responsive>> -
<<gui_attr_rowspan,rowspan>> -
<<gui_attr_stylename,stylename>> -
<<gui_suggestionPickerField_suggestionsLimit,suggestionsLimit>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы suggestionPickerField::
<<gui_suggestionPickerField_actions,actions>> -
<<gui_suggestionPickerField_query,query>> -
<<gui_validator,validator>>

Атрибуты query::
<<gui_suggestionPickerField_query_entityClass,entityClass>> -
<<gui_suggestionPickerField_query_escapeValueForLike,escapeValueForLike>> -
<<gui_suggestionPickerField_query_searchStringFormat,searchStringFormat>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_Table]]
====== Table

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-table" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Table` позволяет выводить информацию в табличном виде, сортировать данные, управлять колонками и заголовками таблицы, вызывать действия для выбранных строк.

image::gui_table.png[align="center"]

XML-имя компонента: `table`

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Пример описания таблицы в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/table_1.xml[]
----

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `collectionDatasource`, который выбирает сущности `Order` с помощью <<jpql,JPQL>> запроса `select o from sales$Order o order by o.date`. Для компонента `table` в элементе `rows` указывается используемый источник данных, а в элементе `columns` - какие атрибуты сущности, содержащейся в источнике данных, использовать в качестве колонок.

Элементы `table`:

[[gui_Table_rows]]
* `rows` - обязательный элемент, в атрибуте `datasource` которого необходимо объявить используемый таблицей <<datasources,источник данных>>.
+
Для строк можно настроить отображение заголовков - задать каждой строке свой значок в дополнительной колонке слева. Для этого в контроллере экрана необходимо реализовать интерфейс `ListComponent.IconProvider` и установить его таблице:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tableIconProvider_1.java[]
---- 

[[gui_Table_columns]]
* `columns` - обязательный элемент, определяет набор колонок таблицы.
+
Каждая колонка описывается во вложенном элементе `column` со следующими атрибутами:
+
--
[[gui_Table_column_id]]
** `id` − обязательный атрибут, содержит название атрибута сущности, выводимого в колонке. Может быть как непосредственным атрибутом сущности, находящейся в источнике данных, так и атрибутом связанной сущности - переход по графу объектов обозначается точкой. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableId_1.xml[]
---- 

[[gui_Table_column_caption]]
** `caption` − необязательный атрибут, содержит заголовок колонки. Если не задан, будет отображено <<entity_localization,локализованное название атрибута>> сущности.

[[gui_Table_column_collapsed]]
** `collapsed` − необязательный атрибут, при указании `true` колонка будет изначально скрыта. Пользователь может управлять отображением колонок с помощью меню, доступного по кнопке image:gui_table_columnControl.png[] в правой верхней части таблицы, если атрибут `columnControlVisible` таблицы не `false`. По умолчанию `collapsed` имеет значение `false`.

[[gui_Table_column_width]]
** `width` − необязательный атрибут, отвечает за изначальную ширину колонки. Может принимать только числовые значения в пикселах.

[[gui_Table_column_align]]
** `align` - необязательный атрибут, устанавливает выравнивание текста в ячейках данной колонки. Возможные значения: `LEFT`, `RIGHT`, `CENTER`. По умолчанию `LEFT`.

[[gui_Table_column_editable]]
** `editable` − необязательный атрибут, разрешает/запрещает редактирование данной колонки в редактируемой таблице. Чтобы колонка была редактируемой, атрибут <<gui_Table_editable,editable>> всей таблицы также должен быть установлен в `true`. Динамическое изменение значения этого атрибута не поддерживается.

[[gui_Table_column_sortable]]
** `sortable` − необязательный атрибут, позволяющий запретить сортировку колонки. Вступает в действие, если атрибут <<gui_Table_sortable,sortable>> всей таблицы установлен в `true` (что имеет место по умолчанию).

[[gui_Table_column_maxTextLength]]
** `maxTextLength` - необязательный атрибут, позволяет ограничивать количество символов в ячейке. При этом если разница между фактическим и допустимым количеством символов не превышает порог в 10 символов, "лишние" символы не скрываются. Для просмотра полной записи надо кликнуть на ее видимую часть. Пример колонки с ограничением в 5 символов:
+
image::gui_table_column_maxTextLength.png[align="center"]

[[gui_Table_column_link]]
** `link` - установка атрибута в `true` позволяет отобразить в ячейке таблицы ссылку на экран просмотра экземпляра сущности (поддерживается только для *Web Client*). Атрибут `link="true"`) может указываться и для колонок примитивных типов: в этом случае, при нажатии на ссылку будет открываться редактор основной сущности таблицы. Такой подход может применяться для упрощения навигации - пользователи смогут открывать редактор одним кликом по некоторому ключевому атрибуту.

[[gui_Table_column_linkScreen]]
** `linkScreen` - позволяет указать идентификатор экрана, который будет открыт по нажатию на ссылку, включенную свойством `link`.

[[gui_Table_column_linkScreenOpenType]]
** `linkScreenOpenType` - задает режим открытия экрана (`++THIS_TAB++`, `++NEW_TAB++` или `DIALOG`).

[[gui_Table_column_linkInvoke]]
** `linkInvoke` - позволяет заменить открытие окна на вызов метода контроллера.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_4.java[]
----

[[gui_Table_column_captionProperty]]
** `captionProperty` - имя атрибута сущности, который должен быть отображен в колонке вместо указанного в <<gui_Table_column_id,id>>. Например, если имеется связанная сущность `Priority` с атрибутами `name` и `orderNo`, можно определить следующую колонку:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableColumnCaptionProperty_1.xml[]
----
+
В этом случае в колонке будет отображаться название приоритета, а сортировка колонки будет осуществляться по атрибуту `orderNo`.

[[gui_Table_column_generator]]
** необязательный атрибут `generator` содержит ссылку на метод в контроллере экрана, который создает визуальный компонент для отображения содержимого ячейки:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/table_generator.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_generator.java[]
----
+
Он может быть использован вместо передачи реализации `Table.ColumnGenerator` в метод <<gui_Table_addGeneratedColumn,addGeneratedColumn()>>.

** Элемент `column` может содержать вложенный элемент <<gui_formatter,formatter>> для представления значения атрибута в виде, отличном от стандартного для данного <<datatype,Datatype>>: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableFormatter_1.xml[]
----
--

[[gui_Table_rowsCount]]
* `rowsCount` − необязательный элемент, создающий для таблицы компонент `RowsCount`, который позволяет загружать в таблицу данные постранично. Размер страницы задается путем ограничения количества записей в источнике данных методом `CollectionDatasource.setMaxResults()`. Как правило, это делает связанный с источником данных таблицы компонент <<gui_Filter,Filter>>, однако при отсутствии универсального фильтра можно вызвать этот метод и напрямую из контроллера экрана.
+
Компонент `RowsCount` может также отобразить общее число записей, возвращаемых текущим запросом в источнике данных, без извлечения этих записей. Для этого при щелчке пользователя на знаке "?" он вызывает метод `AbstractCollectionDatasource.getCount()`, что приводит к выполнению в БД запроса с такими же, как у текущего запроса условиями, но с агрегатной функцией `++COUNT(*)++` вместо результатов. Полученное число отображается вместо знака "?".

[[gui_Table_actions]]
* `actions` − необязательный элемент для описания <<gui_Action,действий>>, связанных с таблицей. Кроме описания произвольных действий, поддерживаются следующие <<standard_actions, стандартные действия>>, определяемые перечислением `ListActionType`: `create`, `edit`, `remove`, `refresh`, `add`, `exclude`, `excel`.

[[gui_Table_buttonsPanel]]
* `buttonsPanel` - необязательный элемент, создающий над таблицей контейнер <<gui_ButtonsPanel,ButtonsPanel>> для отображения кнопок действий.

Атрибуты `table`:

[[gui_Table_multiselect]]
* Атрибут `multiselect` позволяет задать режим множественного выделения строк в таблице. Если `multiselect` равен `true`, то пользователь может выделить несколько строк с помощью клавиатуры или мыши, удерживая клавиши *Ctrl* или *Shift*. По умолчанию режим множественного выделения отключен.

[[gui_Table_sortable]]
* Атрибут `sortable` разрешает или запрещает сортировку в таблице. По умолчанию имеет значение `true`. Если сортировка разрешена, то при нажатии на название колонки справа от названия появляется значок image:gui_sortable_down.png[]/image:gui_sortable_up.png[]. Сортировку некоторой отдельной колонки можно запретить с помощью атрибута <<gui_Table_column_sortable, sortable>> этой колонки.
+
При включенной с помощью элемента `rowsCount` (см. выше) страничной загрузке таблицы сортировка производится разными способами в зависимости от того, умещаются ли все записи на одной странице. Если умещаются, то сортировка производится в памяти, без обращений к БД. Если же страниц больше одной, то сортировка производится на базе данных путем отправки нового запроса с соответствующим `ORDER BY`.
+
Колонка таблицы может ссылаться на локальный атрибут или на связанную сущность. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableSortable_1.xml[]
----
+
В последнем случае, сортировка на базе данных производится по атрибутам, указанным в аннотации `@NamePattern` связанной сущности. Если у связанной сущности нет такой аннотации, то сортировка производится в памяти только в пределах текущей страницы.
+
Если колонка таблицы ссылается на неперсистентный атрибут, то сортировка на базе данных производится по атрибутам, указанным в параметре `related()` аннотации `@MetaProperty`. Если такой параметр не указан, то сортировка производится в памяти только в пределах текущей страницы.
+
Если таблица соединена со вложенным <<datasources,источником данных>>, который содержит коллекцию связанных сущностей, то для того, чтобы таблицу можно было сортировать, атрибут-коллекция должен быть упорядоченного типа (`List` или `LinkedHashSet`). Если атрибут имеет тип `Set`, то атрибут `sortable` не оказывает влияния и пользователи не смогут сортировать таблицу.

[[gui_Table_presentations]]
* Атрибут `presentations` управляет механизмом <<gui_presentations,представлений>>. Значение по умолчанию равно `false`. Когда значение атрибута равно `true`, то в верхнем правом углу таблицы появляется значок image:gui_presentation.png[]. Механизм представлений реализован только для блока *Web Client*.

[[gui_Table_columnControlVisible]]
* Установка атрибута `columnControlVisible` в `false` запрещает пользователю скрывать колонки с помощью меню, выпадающего при нажатия на кнопку image:gui_table_columnControl.png[] в правой части шапки таблицы. Флажками в меню отмечаются отображаемые в данный момент колонки.
+
image::gui_table_columnControl_all.png[align="center"]

[[gui_Table_reorderingAllowed]]
* Установка атрибута `reorderingAllowed` в `false` запрещает пользователю менять местами колонки, перетаскивая их с помощью мыши.

[[gui_Table_columnHeaderVisible]]
* Установка атрибута `columnHeaderVisible` в `false` скрывает заголовок таблицы.

[[gui_Table_showSelection]]
* При установленном в `false` атрибуте `showSelection` текущая строка не имеет выделения.

[[gui_Table_allowPopupMenu]]
* Атрибут `contextMenuEnabled` разрешает или запрещает показывать контекстное меню. По умолчанию атрибут имеет значение `true`. В контекстном меню отображаются действия таблицы (если они есть), и пункт *Системная информация*, содержащий информацию о выбранной сущности (если у пользователя есть <<permissions,разрешение>> `cuba.gui.showInfo`).

[[gui_Table_multiLineCells]]
* Если атрибуту `multiLineCells` таблицы присвоить значение `true`, то ячейки, содержащие текст с переносами строк, будут отображать его в несколько строк. В таком режиме в веб клиенте для правильной работы полосы прокрутки все строки текущей страницы таблицы будут загружены веб-браузером сразу, без ленивой загрузки видимой части таблицы. По умолчанию атрибут имеет значение `false`.

[[gui_Table_aggregatable]]
* Атрибут `aggregatable` включает режим агрегации строк таблицы. Поддерживаются следующие операции:
+
--

** `SUM` - сумма

** `AVG` - среднее значение

** `COUNT` - количество

** `MIN` - минимальное значение

** `MAX` - максимальное значение

[[gui_Table_column_aggregation]]
Для агрегируемых колонок необходимо указать элемент `aggregation` с атрибутом `type`, задающим функцию агрегации. По умолчанию в агрегируемых колонках поддерживаются только числовые типы данных, такие как `Integer, Double, Long` и `BigDecimal`. Агрегированные значения столбцов выводятся в дополнительной строке вверху таблицы. Пример описания таблицы с агрегацией:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tableAggregatable_1.xml[]
---- 

[[gui_Table_column_aggregation_strategyClass]]
Элемент `aggregation` может также содержать атрибут `strategyClass`, указывающий класс, реализующий интерфейс `AggregationStrategy` interface (см. ниже пример установки стратегии агрегации программно).

Для отображения агрегированного значения в виде, отличном от стандартного для данного <<datatype,Datatype>>, для него можно указать <<gui_formatter,Formatter>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/tableAggregatable_2.xml[]
---- 

[[gui_Table_aggregationStyle]]
Атрибут `aggregationStyle` позволяет задать положение строки агрегации: `TOP` или `BOTTOM`. По умолчанию используется `TOP`.

В дополнение к операциям, перечисленным выше, можно задать собственную стратегию агрегации путем создания класса, реализующего интерфейс `AggregationStrategy`, и передачи его методу `setAggregation()` класса `Table.Column` в составе экземпляра `AggregationInfo`. Например: 

[source, java]
----
include::{sourcesdir}/gui_vcl/tableAggregationStrategy_1.java[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/tableAggregationStrategy_2.java[]
----
--

[[gui_Table_editable]]
* Атрибут `editable` позволяет перевести таблицу в режим in-place редактирования ячеек. В этом режиме в колонках, имеющих атрибут `editable = true`, отображаются компоненты для редактирования значений атрибутов сущности, находящейся в источнике данных.
+
Тип компонента для каждой редактируемой колонки выбирается автоматически на основании типа атрибута сущности. Например, для строковых и числовых атрибутов используется <<gui_TextField,TextField>>, для `Date` - <<gui_DateField,DateField>>, для перечислений - <<gui_LookupField,LookupField>>, для ссылок на другие сущности - <<gui_PickerField,PickerField>>. 
+
Для редактируемой колонки типа `Date` можно дополнительно указать атрибуты `dateFormat` или `resolution` аналогично описанным для <<gui_DateField,DateField>>.
+
Для редактируемой колонки, отображающей связанную сущность, можно дополнительно указать атрибуты <<gui_attr_optionsDatasource,optionsDatasource>> и <<gui_attr_captionProperty,captionProperty>>. При указании `optionsDatasource` вместо <<gui_PickerField,PickerField>> используется компонент <<gui_LookupField,LookupField>>.
+
Произвольно настроить отображение ячеек, в том числе для редактирования содержимого, можно с помощью метода `Table.addGeneratedColumn()` - см. ниже.

[[gui_Table_stylename]]
* В веб-клиенте с темой, основанной на Halo, атрибут `stylename` позволяет применять к таблице предопределенные стили `Table`. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
+
--
[source, xml]
----
include::{sourcesdir}/gui_vcl/table_2.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `TABLE_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/table_3.java[]
----

Стили компонента Table:

[[gui_table_borderless]]
* `borderless` - удаляет внешнюю рамку таблицы.

[[gui_table_compact]]
* `compact` - уменьшает отступы внутри ячеек таблицы.

[[gui_table_no-header]]
* `no-header` - скрывает заголовки таблицы.

[[gui_table_no-horizontal-lines]]
* `no-horizontal-lines` - удаляет горизонтальные строковые разделители.

[[gui_table_no-stripes]]
* `no-stripes` - отключает чередование цветов строк таблицы.

[[gui_table_no-vertical-lines]]
* `no-vertical-lines` - удаляет вертикальные разделители столбцов.

[[gui_table_small]]
* `small` - уменьшает размер шрифта и отступы внутри ячеек таблицы.
--

Методы интерфейса `Table`:

[[gui_Table_ColumnCollapseListener]]
* метод `addColumnCollapsedListener`() позволяет отслеживать видимость колонок таблицы с помощью интерфейса слушателя `ColumnCollapsedListener`.

[[gui_Table_getSelected]]
* `getSelected()`, `getSingleSelected()` - возвращают экземпляры сущностей, соответствующие выделенным в таблице строкам. Коллекцию можно получить вызовом метода `getSelected()`. Если ничего не выбрано, возвращается пустой набор. Если `multiselect` отключен, удобно пользоваться методом `getSingleSelected()`, возвращающим одну выбранную сущность или `null`, если ничего не выбрано.

[[gui_Table_addGeneratedColumn]]
* Метод `addGeneratedColumn()` позволяет задать собственное представление данных в колонке. Он принимает два параметра: идентификатор колонки и реализацию интерфейса `Table.ColumnGenerator`. Идентификатор может совпадать с одним из идентификаторов, указанных для колонок таблицы в XML-дескрипторе - в этом случае новая колонка вставляется вместо заданной в XML. Если идентификатор не совпадает ни с одной колонкой, создается новая справа.
+
[[gui_Table_generateCell]]
Метод `generateCell()` интерфейса `Table.ColumnGenerator` вызывается таблицей для каждой строки, и в него передается экземпляр сущности, отображаемой в данной строке. Метод `generateCell()` должен вернуть визуальный компонент, который и будет отображаться в ячейке. 
+
Пример использования: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tableColumnGenerator_1.java[]
---- 
+
В данном случае в ячейках колонки `colour` таблицы отображается компонент <<gui_LookupPickerField,LookupPickerField>>. Компонент должен сохранять свое значение в атрибут `colour` сущности, экземпляр которой отображается в данной строке. Для этого у таблицы методом `getItemDatasource()` запрашивается источник данных для текущего экземпляра сущности, и передается компоненту `LookupPickerField`. 
+
Если в ячейке необходимо отобразить просто динамически сформированный текст, вместо компонента <<gui_Label,Label>> используйте класс `Table.PlainTextCell`. Это упростит отрисовку и сделает таблицу быстрее.
+
Если в метод `addGeneratedColumn()` передан идентификатор колонки, не объявленной в XML-дескрипторе, то может понадобиться установить заголовок новой колонки следующим образом: 
+
[source, java]
----
carsTable.getColumn("colour").setCaption("Colour");
---- 
+
Существует также более декларативный подход, использующий XML-атрибут <<gui_Table_column_generator,generator>>.

[[gui_Table_requestFocus]]
* Метод `requestFocus()` позволяет установить фокус на определенное поле конкретной записи. Принимает два параметра: экземпляр сущности, определяющй строку и идентификатор колонки. Пример программной установки фокуса:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_requestFocus_1.java[]
----

[[gui_Table_scrollTo]]
* Метод `scrollTo()` позволяет программно прокрутить таблицу до нужной записи. Метод принимает экземпляр сущности, определяющий нужную строку в таблице.
+
Пример использования метода:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_scrollTo_1.java[]
----

[[gui_Table_CellClickListener]]
* Метод `setClickListener()` может избавить от необходимости добавлять генерируемые колонки с компонентами, если нужно нарисовать что-либо в ячейках и получать оповещения когда пользователь кликает на эти ячейки. Имплементация класса `CellClickListener`, передаваемая в данный метод, получает текущий экземпляр сущности и идентификатор колонки. Содержимое ячеек будет завернуто в элемент `span` со стилем `cuba-table-clickable-cell`, который можно использовать для задания отображения ячеек.

[[gui_Table_setStyleProvider]]
* Метод `setStyleProvider()` позволяет задать стиль отображения ячеек таблицы. Параметром метода должна быть реализация интерфейса `Table.StyleProvider`. Метод `getStyleName()` этого интерфейса вызывается таблицей отдельно для каждой строки и для каждой ячейки. Если метод вызван для строки, то первый параметр содержит экземпляр сущности, отображаемый этой строкой, а второй параметр `null`. Если же метод вызван для ячейки, то второй параметр содержит имя атрибута, отображаемого этой ячейкой.
+
Пример задания стилей: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_setStyleProvider_1.java[]
----
+
Далее нужно определить заданные для строк и ячеек стили в теме приложения. Подробная информация о создании темы находится в <<gui_themes,Создание темы приложения>>. Для веб-клиента новые стили определяются в файле `styles.scss`. Имена стилей, заданные в контроллере, совместно с префиксами, обозначающими строку или колонку таблицы, образуют CSS-селекторы. Например:
+
[source, css]
----
include::{sourcesdir}/gui_vcl/table_setStyleProvider_2.css[]
----

[[gui_Table_addPrintable]]
* Метод `addPrintable()` позволяет задать специфическое представление данных колонки при выводе в XLS-файл, осуществляемом <<standard_actions,стандартным действием>> `excel` или напрямую с помощью класса `ExcelExporter`. Метод принимает идентификатор колонки и реализацию интерфейса `Table.Printable` для нее. Например: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_addPrintable_1.java[]
---- 
+
Метод `getValue()` интерфейса `Table.Printable` должен возвращать данные, которые будут находиться в ячейке таблицы. Это может быть не только строка - метод может возвращать значения других типов, например, числовые данные или даты, и они будут представлены в XLS-файле соответствующим образом. 
+
Если форматированный вывод в XLS необходим для генерируемой колонки, нужно использовать реализацию интерфейса `Table.PrintableColumnGenerator`, передавая ее методу `addGeneratedColumn()`. Значение для вывода в ячейку XLS-документа задается в методе `getValue()` этого интерфейса: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_addPrintable_2.java[]
---- 
+
Если генерируемой колонке тем или иным способом не задано представления `Printable`, то в случае, если колонке соответствует атрибут сущности, будет выведено его значение, в противном случае не будет выведено ничего.

[[gui_Table_setItemClickAction]]

* Метод `setItemClickAction()` позволяет задать <<gui_Action,действие>>, выполняемое при двойном клике на строке таблицы. Если такое действие не задано, при двойном клике таблица пытается найти среди своих действий подходящее в следующем порядке:

** Действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

** Действие с именем `edit`.

** Действие с именем `view`.
+
Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.

[[gui_Table_setEnterPressAction]]
* Метод `setEnterPressAction()` позволяет задать <<gui_Action,действие>>, выполняемое при нажатии клавиши *Enter*. Если такое действие не задано, таблица пытается найти среди своих действий подходящее в следующем порядке:
+
--
** Действие, назначенное методом `setItemClickAction()`.

** Действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

** Действие с именем `edit`.

** Действие с именем `view`.

Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.
--

'''

Атрибуты table::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_columnHeaderVisible,columnHeaderVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_Table_showSelection,showSelection>> -
<<gui_Table_sortable,sortable>> -
<<gui_Table_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_textSelectionEnabled,textSelectionEnabled>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы table::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_Table_column_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_Table_column_generator,generator>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_column_aggregation,aggregation>>::
<<gui_Table_column_aggregation,type>> -
<<gui_Table_column_aggregation_strategyClass,strategyClass>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

Предопределенные стили table::
<<gui_table_borderless,borderless>> -
<<gui_table_compact,compact>> -
<<gui_table_no-header,no-header>> -
<<gui_table_no-horizontal-lines,no-horizontal-lines>> -
<<gui_table_no-stripes,no-stripes>> -
<<gui_table_no-vertical-lines,no-vertical-lines>> -
<<gui_table_small,small>>

API::
<<gui_Table_addGeneratedColumn,addGeneratedColumn>> -
<<gui_Table_addPrintable,addPrintable>> -
<<gui_Table_ColumnCollapseListener,addColumnCollapseListener>> -
<<gui_api_settings,applySettings>> -
<<gui_Table_generateCell,generateCell>> -
<<gui_Table_getSelected,getSelected>> -
<<gui_Table_requestFocus,requestFocus>> -
<<gui_api_settings,saveSettings>> -
<<gui_Table_scrollTo,scrollTo>> -
<<gui_Table_CellClickListener,setClickListener>> -
<<gui_Table_setEnterPressAction,setEnterPressAction>> -
<<gui_Table_setItemClickAction,setItemClickAction>> -
<<gui_Table_setStyleProvider,setStyleProvider>>

'''

[[gui_TextArea]]
====== TextArea

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-textarea" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Текстовая область − многострочное текстовое поле для редактирования текста.

XML-имя компонента: `textArea`

Компонент `TextArea` реализован для блоков *Web Client* и *Desktop Client*.

`TextArea` в основном повторяет функциональность <<gui_TextField,TextField>> и имеет следующие специфические атрибуты:

[[gui_TextArea_cols_rows]]
* `cols` и `rows` задают количество строк и столбцов текста:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textarea_1.xml[]
----
+
Значения `width` и `height` имеют приоритет над значениями `cols` и `rows`.

[[gui_TextArea_resizableDirection]]
* `resizableDirection` – задаёт возможность изменения размера области и его направление.
+
--
[source, xml]
----
include::{sourcesdir}/gui_vcl/textarea_2.xml[]
----

image::gui_textField_resizable.png[align="center"]

Доступны следующие режимы изменения размера:

* `BOTH` - компонент может изменять размер в обоих направлениях. Режим не будет работать, если задан размер компонента в процентах.

* `NONE` - компонент не может изменять размер.

* `VERTICAL` - компонент может изменять размер только по вертикали. Режим не будет работать, если задана высота компонента в процентах.

* `HORIZONTAL` - компонент может изменять размер только по горизонтали. Режим не будет работать, если задана ширина компонента в процентах.

[[gui_TextArea_ResizeListener]]
События изменения размеров области можно отслеживать с помощью слушателя `ResizeListener`, например:

[source, java]
----
include::{sourcesdir}/gui_vcl/textarea_6.java[]
----
--

[[gui_TextArea_wordwrap]]
* `wordwrap` - установите данный атрибут в `false`, чтобы отключить перенос строк по словам.

Компонент `TextArea` поддерживает слушатель `TextChangeListener`, определёный в родительском интерфейсе `TextInputField`. События изменения текста обрабатываются асинхронно после ввода, не блокируя сам ввод.

[source, java]
----
include::{sourcesdir}/gui_vcl/textarea_5.java[]
----

image::gui_TextArea_2.png[align="center"]

Параметром `TextChangeEventMode` задаётся режим передачи изменений на сервер для вызова события на серверной стороне. В платформе реализовано 3 режима передачи:

* `LAZY` (по умолчанию) - событие вызывается во время паузы в наборе текста. Продолжительность паузы можно задать с помощью метода `setInputEventTimeout()`. Событие изменения текста обрабатывается принудительно перед возможным событием `ValueChangeEvent`, даже если пользователь не выдержал паузу в наборе текста.

* `TIMEOUT` - событие вызывается после периода ожидания. В случае ввода нескольких изменений за один период, на сервер отсылается событие со всеми изменениями, включая последнее. Продолжительность периода ожидания можно задать с помощью метода `setInputEventTimeout()`.
+
В случае, если `ValueChangeEvent` может случиться до истечения периода ожидания, событие `TextChangeEvent` обрабатывается до его истечения, при условии, что набранный текст был изменён  после предыдущего `TextChangeEvent`.

* `EAGER` - событие вызывается незамедлительно после каждого изменения текста, то есть после каждого нажатия клавиш. Запросы отправляются по отдельности и обрабатываются последовательно один за другим. Тем не менее, асинхронная передача событий изменения на сервер позволяет не блокировать дальнейший ввод текста.


Стили компонента TextArea::
+
--
В веб-клиенте с темой, основанной на Halo, к компоненту `TextArea` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/textarea_3.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `TEXTAREA_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/textarea_4.java[]
----

[[gui_textarea_align-center]]
* `align-center` - выравнивание текста по центру области.

[[gui_textarea_align-right]]
* `align-right` - выравнивание текста по правому краю области.

[[gui_textarea_borderless]]
* `borderless` - удаляет рамку и фон текстовой области.
--

'''

Атрибуты textArea::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_TextField_caseConversion,caseConversion>> -
<<gui_TextArea_cols_rows,cols>> -
<<gui_attr_datasource,datasource>> -
<<gui_TextField_datatype,datatype>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TextArea_resizableDirection,resizableDirection>> -
<<gui_TextArea_cols_rows,rows>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_TextField_trim,trim>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>> -
<<gui_TextArea_wordwrap,wordwrap>>

Предопределенные стили textArea::
<<gui_textarea_align-center,align-center>> -
<<gui_textarea_align-right,align-right>> -
<<gui_textarea_borderless,borderless>> -
<<gui_attr_stylename_huge,huge>> -
<<gui_attr_stylename_large,large>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>


API::
<<gui_TextArea_ResizeListener,addResizeListener>> -
<<gui_TextField_TextChangeListener,addTextChangeListener>> -
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_settings,applySettings>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>> -
<<gui_api_settings,saveSettings>>

'''

[[gui_TextField]]
====== TextField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-textfield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Поле для редактирования текста. Может использоваться как для работы с атрибутами сущностей, так и для ввода и отображения произвольной текстовой информации.

XML-имя компонента: `textField`

Компонент текстового поля реализован для блоков *Web Client* и *Desktop Client*.

* Пример текстового поля с заголовком, взятым из <<message_packs,пакета локализованных сообщений>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_1.xml[]
----
+
На рисунке ниже показан вид простого текстового поля.
+
image::gui_textField_data.png[align="center"]

* В веб-клиенте с темой, основанной на Halo, к компоненту `TextField` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
+
--
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_7.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `TEXTFIELD_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/textfield_8.java[]
----

Стили компонента TextField:

[[gui_textfield_align-center]]
*  `align-center` - выравние текста по центру поля.

[[gui_textfield_align-right]]
* `align-right` - выравнивание текста по правому краю поля.

[[gui_textfield_borderless]]
* `borderless` - удаляет рамку и фон текстового поля.

[[gui_textfield_inline-icon]]
* `inline-icon` - расположение пиктограммы внутри текстового поля.

[[gui_TextField_caseConversion]]
Компонент TextField поддерживает автоматическую конвертацию регистра. Атрибут `caseConvertion` может принимать следующие значения:

* `UPPER` - верхний регистр,

* `LOWER` - нижний регистр,

* `NONE` - конвертация отключена (значение по умолчанию). Используйте это значение для поддержки клавиатурного ввода с использованием IME, к примеру, для японского, корейского и китайского языков.
--

* Для создания текстового поля, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_2.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `customerDs` для некоторой сущности `Покупатель (Customer)`, имеющей атрибут `name`. В компоненте текстового поля в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено в текстовом поле.

[[gui_TextField_datatype]]
* Если поле не связано с атрибутом сущности (то есть не указан источник данных и название атрибута), то можно указать тип данных с помощью атрибута `datatype`. Тип данных используется для форматирования значения поля. В качестве значения атрибута может быть указано любое имя типа данных, зарегистрированного в метаданных приложения - см. <<datatype,>>. Как правило, в `TextField` используются следующие типы данных:
** `decimal`

** `double`

** `int`

** `long`
+
В качестве примера рассмотрим текстовое поле с типом данных `Integer`. 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_3.xml[]
----
+
Если в таком поле ввести значение, которое невозможно интерпретировать как целое число, то при потере фокуса полем будет выведено сообщение об ошибке и значение поля вернется на предыдущее.

* Текстовому полю может быть назначен <<gui_validator,валидатор>> - класс, реализующий интерфейс `Field.Validator`. Валидатор позволяет дополнительно к `datatype` ограничить вводимую пользователем информацию. Например, для создания поля ввода положительных целых чисел нужно создать класс валидатора:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/textfield_4.java[]
----
+
и задать его для текстового поля с типом данных `int` в элементе <<gui_validator,validator>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_5.xml[]
----
+
В отличие от проверки вводимой строки на соответствие типу данных, валидация срабатывает не сразу при потере полем фокуса, а только при вызове у поля метода `validate()`. Это означает, что поле (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации (в приведенном примере неположительное число). Это не является проблемой, так как обычно поля редактирования с валидацией располагаются в <<screen_edit,экране редактирования>>, а он автоматически вызывает валидацию всех своих полей перед коммитом. Если же поле находится не в экране редактирования, то необходимо вызывать метод `validate()` поля в контроллере явно.

[[gui_TextField_TextChangeListener]]
* Компонент `TextField` поддерживает слушатель `TextChangeListener`, определёный в родительском интерфейсе `TextInputField`. События изменения текста обрабатываются асинхронно после ввода, не блокируя сам ввод.
+
--
[source, java]
----
include::{sourcesdir}/gui_vcl/textfield_9.java[]
----

image::gui_textfield_2.png[align="center"]
--
* Параметром `TextChangeEventMode` задаётся режим передачи изменений на сервер для вызова события на серверной стороне. В платформе реализовано 3 режима передачи:
+
--
* `LAZY` (по умолчанию) - событие вызывается во время паузы в наборе текста. Продолжительность паузы можно задать с помощью метода `setInputEventTimeout()`. Событие изменения текста обрабатывается принудительно перед возможным событием `ValueChangeEvent`, даже если пользователь не выдержал паузу в наборе текста.

* `TIMEOUT` - событие вызывается после периода ожидания. В случае ввода нескольких изменений за один период, на сервер отсылается событие со всеми изменениями, включая последнее. Продолжительность периода ожидания можно задать с помощью метода `setInputEventTimeout()`.
+
В случае, если `ValueChangeEvent` может случиться до истечения периода ожидания, событие `TextChangeEvent` обрабатывается до его истечения, при условии, что набранный текст был изменён  после предыдущего `TextChangeEvent`.

* `EAGER` - событие вызывается незамедлительно после каждого изменения текста, то есть после каждого нажатия клавиш. Запросы отправляются по отдельности и обрабатываются последовательно один за другим. Тем не менее, асинхронная передача событий изменения на сервер позволяет не блокировать дальнейший ввод текста.
--

[[gui_TextField_EnterPressListener]]
* `EnterPressListener` позволяет указать <<gui_Action,действие>>, которое должно быть выполнено по нажатию клавиши Enter:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/textfield_10.java[]
----

[[gui_TextField_ValueChangeListener]]
* `ValueChangeListener` позволяет обрабатывать изменения значения в текстовом поле, когда пользователь уже закончил ввод, т.е. после нажатия клавиши Enter или при потере компонентом фокуса. В слушатель передается объект события типа `ValueChangeEvent`, который имеет следующие методы:
+
** `getPrevValue()` возвращает значение компонента до изменения.
+
** `getValue()` возвращает текущее значение компонента.
+
[source, java]
----
textField.addValueChangeListener(e ->
        showNotification("Before: " + e.getPrevValue() + ". After: " + e.getValue()));
----

* Если текстовое поле связано с атрибутом сущности (через `datasource` и `property`), и если для атрибута сущности в <<entity_attr_annotations,JPA-аннотации>> `@Column` указан параметр `length`, то `TextField` будет соответственно ограничивать максимальную длину вводимого текста.
+
[[gui_TextField_maxLength]]
Если текстовое поле не связано с атрибутом, либо для него не определено значение `length`, либо это значение нужно переопределить, то для ограничения максимальной длины вводимого текста можно использовать атрибут `maxLength`. Значение "-1" означает отсутствие ограничения. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_6.xml[]
----

[[gui_TextField_trim]]
* По умолчанию текстовое поле отсекает пробелы в начале и конце введенной строки. То есть если пользователь ввел строку " aaa bbb " то значением поля, возвращаемым методом `getValue()` и сохраняемым в связанный атрибут сущности, будет строка "aaa bbb". Для того, чтобы отключить отсечение пробелов, используйте атрибут `trim` со значением `false`.
+
Следует иметь в виду, что отсечение пробелов работает только при вводе нового значения. Если в значении связанного атрибута уже присутствуют пробелы, они будут отображаться, пока пользователь не изменит значение поля.

* Текстовое поле всегда вместо введенной пустой строки возвращает `null`. Соответственно, при включенном атрибуте `trim` строка, состоящая из одних пробелов также превратится в `null`.

* Метод `setCursorPosition()` используется для установки позиции курсора в указанный индекс (начинается с 0). После вызова метода поле принимает фокус ввода.

'''

Атрибуты textField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_TextField_caseConversion,caseConversion>> -
<<gui_attr_datasource,datasource>> -
<<gui_TextField_datatype,datatype>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_TextField_trim,trim>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы textField::
<<gui_validator,validator>>

Предопределенные стили textField::
<<gui_textfield_align-center,align-center>> -
<<gui_textfield_align-right,align-right>> -
<<gui_textfield_borderless,borderless>> -
<<gui_attr_stylename_huge,huge>> -
<<gui_textfield_inline-icon,inline-icon>> -
<<gui_attr_stylename_large,large>> -
<<gui_attr_stylename_small,small>> -
<<gui_attr_stylename_tiny,tiny>>

API::
<<gui_TextField_EnterPressListener,addEnterPressListener>> -
<<gui_TextField_TextChangeListener,addTextChangeListener>> -
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

'''

[[gui_TimeField]]
====== TimeField

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-timefield" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Поле для отображения и ввода времени.

image::gui_timeField.png[align="center"]

XML-имя компонента: `timeField`.

Компонент `TimeField` реализован для блоков *Web Client* и *Desktop Client*.

* Для создания поля времени, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/timefield_1.xml[]
----
+
Как видно из примера, в экране описывается источник данных `orderDs` для некоторой сущности Заказ (`Order`), имеющей атрибут `deliveryTime`. В компоненте ввода времени в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено в поле.
+
Связанный атрибут сущности должен быть типа `java.util.Date` или `java.sql.Time`.

* Формат отображения времени определяется <<datatype,типом данных>> `time` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `timeFormat`.

[[gui_TimeField_timeFormat]]
* Формат отображения времени можно также задать в атрибуте `timeFormat` компонента. Это может быть как сама строка формата, так и ключ в пакете сообщений (с префиксом `msg://`).

[[gui_TimeField_showSeconds]]
* Независимо от упомянутого выше формата отображением секунд можно управлять с помощью атрибута `showSeconds`. По умолчанию секунды отображаются, если формат содержит символы `ss`.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/timefield_2.xml[]
----
+
image::gui_timeFieldSec.png[align="center"]

'''

Атрибуты timeField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TimeField_showSeconds,showSeconds>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_TimeField_timeFormat,timeFormat>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы timeField::
<<gui_validator,validator>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_api_commit,commit>> -
<<gui_api_discard,discard>> -
<<gui_api_isModified,isModified>>

'''

[[gui_TokenList]]
====== TokenList

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=normal-tokenlist" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `TokenList` представляет собой упрощенный вариант работы со списком сущностей: названия экземпляров располагаются в вертикальном или горизонтальном списке, добавление производится из выпадающего списка, удаление - с помощью кнопок, расположенных рядом с каждым экземпляром.

image::gui_tokenList.png[align="center"]

XML-имя компонента: `tokenList`

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример описания компонента `TokenList` в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/tokenList_1.xml[]
---- 

Здесь в элементе `dsContext` определен вложенный источник данных `productsDs`, содержащий коллекцию входящих в состав заказа продуктов. Кроме того, определен источник данных `allProductsDs`, содержащий коллекцию всех продуктов, имеющихся в базе данных. Компонент `TokenList` с идентификатором `productsList` отображает содержимое источника данных `productsDs`, а также позволяет изменять эту коллекцию, добавляя в него экземпляры из источника данных `allProductsDs`.

Атрибуты `tokenList`:

[[gui_TokenList_position]]
* `position` - задает позиционирование раскрывающегося списка. Атрибут может принимать два значения: `TOP`, `BOTTOM`. По умолчанию `TOP`.
+
image::gui_tokenListBottom.png[align="center"]

[[gui_TokenList_inline]]
* Атрибут `inline` задает отображение списка выбранных значений: вертикально или горизонтально. Значение `true` соответствует горизонтальному расположению, значение `false` − вертикальному. Так выглядит компонент с горизонтальным расположением значений:
+
image::gui_tokenListInline.png[align="center"]

[[gui_TokenList_simple]]
*  `simple` - значение `true` позволяет убрать компонент выбора, оставляя только кнопку добавления и очистки списка. При нажатии на кнопку добавления *Add* сразу показывается экран списка экземпляров сущности, тип которой задан источником данных `datasource`. Идентификатор экрана выбора определяется по правилам, описанным для <<picker_actions,стандартного действия>> `PickerField.LookupAction`. Кнопка очистки списка *Clear* удаляет все элементы из источника данных компонента `TokenList`.
+
image::gui_tokenListSimple_withClear.png[align="center"]

[[gui_TokenList_clearEnabled]]
* `clearEnabled` - значение `false` позволяет скрыть кнопку очистки *Clear*.

Элементы `tokenList`:

[[gui_TokenList_lookup]]
* `lookup` − описатель компонента выбора значений.
+
--
Атрибуты элемента `lookup`:

[[gui_TokenList_lookup_lookup]]
** Атрибут `lookup` задает возможность выбора значений через экран выбора сущностей:
+
image::gui_tokenListLookup.png[align="center"]

[[gui_TokenList_lookup_inputPrompt]]
* `inputPrompt` - текстовая подсказка, которая отображается в поле выбора. Если подсказка не задана, поле будет пустым.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gui_tokenList_2.xml[]
----
+
image::gui_TokenList_inputPrompt.png[align="center"]

[[gui_TokenList_lookup_lookupScreen]]
** Атрибут `lookupScreen` задает идентификатор экрана для выбора значений в режиме `lookup="true"`. Если данный атрибут не задан, то идентификатор экрана выбора определяется по правилам, описанным для <<picker_actions,стандартного действия>> `PickerField.LookupAction`.

** Атрибут `openType` можно задать способ открытия экрана выбора, аналогично описанному для <<picker_actions,стандартного действия>> `PickerField.LookupAction`. По умолчанию - `++THIS_TAB++`.

[[gui_TokenList_lookup_multiselect]]
** Если значение атрибута `multiselect` установлено в `true`, то в мэп параметров экрана выбора в ключе `MULTI_SELECT` передается значение `true`. Этот признак можно использовать для установки в экране режима множественного выбора. Данный ключ определен в перечислении `WindowParams`, поэтому с ним удобно работать следующим образом:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tokenListMultiselect_1.java[]
----

--

[[gui_TokenList_button]]
* `addButton` − описатель кнопки добавления значений. Может содержать атрибуты <<gui_attr_caption,caption>> и <<gui_attr_icon,icon>>.

Слушатели `tokenList`:

[[gui_TokenList_ItemClickListener]]
* `ItemClickListener` позволяет отслеживать клики по элементам `tokenList`.

* `ValueChangeListener` отслеживает изменения значения`tokenList`, так же, как и любого другого компонента, реализующего интерфейс `Field`.

'''

Атрибуты tokenList::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_TokenList_clearEnabled,clearEnabled>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_TokenList_inline,inline>> -
<<gui_TokenList_position,position>> -
<<gui_TokenList_simple,simple>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы tokenList::
<<gui_TokenList_button,addButton>> -
<<gui_TokenList_lookup,lookup>>

Атрибуты <<gui_TokenList_lookup,lookup>>::
<<gui_attr_captionProperty,captionProperty>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_TokenList_lookup_inputPrompt,inputPrompt>> -
<<gui_TokenList_lookup_lookup,lookup>> -
<<gui_TokenList_lookup_lookupScreen,lookupScreen>> -
<<gui_TokenList_lookup_multiselect,multiselect>> -
<<gui_attr_openType,openType>> -
<<gui_attr_optionsDatasource,optionsDatasource>>

Атрибуты <<gui_TokenList_button,button>>::
<<gui_attr_caption,caption>> -
<<gui_attr_icon,icon>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>> -
<<gui_TokenList_ItemClickListener,setItemClickListener>>

'''

[[gui_Tree]]
====== Tree

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-tree" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `Tree` предназначен для отображения иерархической структуры, представленной сущностями, содержащими ссылки на самих себя.

image::gui_Tree.png[align="center"]

XML-имя компонента: `tree`

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

[[gui_Tree_treechildren]]
Для `Tree` в атрибуте `datasource` элемента `treechildren` должен быть указан <<datasources,hierarchicalDatasource>>. Объявление `hierarchicalDatasource` должно содержать атрибут `hierarchyProperty` - имя атрибута сущности, являющегося ссылкой на саму себя. 

Пример описания компонента `Tree` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tree_1.xml[]
----

В атрибуте `captionProperty` элемента `treechildren` можно задать имя свойства сущности, отображаемого в дереве. Если этот атрибут не определен, то будет отображаться <<namePattern_annotation,имя экземпляра>> сущности.

[[gui_Tree_multiselect]]
Атрибут `multiselect` позволяет задать режим множественного выделения элементов дерева. Если `multiselect` равен `true`, то пользователь может выделить несколько элементов с помощью клавиатуры или мыши, удерживая клавиши *Ctrl* или *Shift*. По умолчанию режим множественного выделения отключен.

Метод `setItemClickAction()` позволяет задать <<gui_Action,действие>>, которое будет выполнено при двойном клике по узлу дерева.

Каждый элемент дерева может иметь пиктограмму слева. Создайте реализацию интерфейса `ListComponent.IconProvider` в контроллере экрана и установите ее для компонента `Tree`:

[source, java]
----
include::{sourcesdir}/gui_vcl/treeIconProvider_1.java[]
----

'''

Атрибуты tree::
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Tree_multiselect,multiselect>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы tree::
<<gui_Table_actions,actions>> -
<<gui_Tree_treechildren,treechildren>>

Атрибуты treechildren::
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>>

'''

[[gui_TreeTable]]
====== TreeTable

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=tree-table" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `TreeTable` − иерархическая таблица, отображающая в первой колонке древовидную структуру. Предназначена для работы с сущностями, которые содержат ссылки на самих себя. Это могут быть например, файловая система или организационная структура предприятия.

image::gui_treeTable.png[align="center"]

XML-имя компонента: `treeTable`

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Для `TreeTable` в атрибуте `datasource` элемента `rows` должен быть указан <<datasources,hierarchicalDatasource>>. Объявление `hierarchicalDatasource` должно содержать атрибут `hierarchyProperty` - имя атрибута сущности, являющегося ссылкой на саму себя. 

Пример описания таблицы в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/treetable_1.xml[]
----

Функциональность `TreeTable` аналогична простой таблице <<gui_Table,Table>>. 

'''

Атрибуты treeTable::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_Table_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_textSelectionEnabled,textSelectionEnabled>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы treeTable::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

API::
<<gui_Table_ColumnCollapseListener,addColumnCollapseListener>> -
<<gui_Table_CellClickListener,setClickListener>>

'''

[[gui_TwinColumn]]
====== TwinColumn

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-twincolumn" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Компонент `TwinColumn` представляет собой сдвоенный список для множественного выбора опций. В левом списке содержатся доступные невыбранные значения, в правом списке содержатся выбранные значения. Пользователь выбирает значения, перенося их из левого в правый список и обратно с помощью двойного клика или соответствующих кнопок. Для каждого значения можно задать уникальный стиль отображения и пиктограмму.

image::TwinColumn.png[align="center"]

XML-имя компонента: `twinColumn`

Компонент реализован только для блока *Web Client*.

Пример использования компонента `twinColumn` для выбора экземпляров сущности:

[source, xml]
----
include::{sourcesdir}/gui_vcl/twincolumn_1.xml[]
----

В данном случае компонент `coloursField` отобразит <<namePattern_annotation,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `coloursDs`, а его метод `getValue()` вернет коллекцию выбранных экземпляров сущности.

[[gui_TwinColumn_addAllBtnEnabled]]
Атрибут `addAllBtnEnabled` задает отображение кнопок, позволяющих перемещать между списками все опции сразу.

[[gui_TwinColumn_columns_rows]]
Атрибут `columns` используется для задания количества символов в строке, а атрибут `rows` − для задания количества строк текста в каждом списке. 

[[gui_TwinColumn_captions]]
Атрибуты `leftColumnCaption` и `rightColumnCaption` используются для назначения заголовков списков.

Для задания внешнего вида опций можно реализовать интерфейс `TwinColumn.StyleProvider` и возвращать название стиля и путь к пиктограмме в зависимости от конкретного экземпляра сущности, отображаемого в компоненте.

Список опций компонента `TwinColumn` может быть задан произвольно с помощью методов `setOptionsList()`, `setOptionsMap()` и `setOptionsEnum()`, аналогично описанному для компонента <<gui_OptionsGroup,OptionsGroup>>.

'''

Атрибуты twinColumn::
<<gui_attr_align,align>> -
<<gui_TwinColumn_addAllBtnEnabled,addAllBtnEnabled>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_TwinColumn_columns_rows,columns>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_TwinColumn_captions,leftColumnCaption>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TwinColumn_captions,rightColumnCaption>> -
<<gui_TwinColumn_columns_rows,rows>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы twinColumn::
<<gui_validator,validator>>

API::
<<gui_api_addValueChangeListener,addValueChangeListener>>

'''

[[gui_layouts]]
===== Контейнеры

<<gui_Accordion, Accordion>>

<<gui_BoxLayout,BoxLayout>>

<<gui_ButtonsPanel,ButtonsPanel>>

<<gui_CssLayout,CssLayout>>

<<gui_Frame,Frame>>

<<gui_GridLayout,GridLayout>>

<<gui_GroupBoxLayout,GroupBoxLayout>>

<<gui_HtmlBoxLayout,HtmlBoxLayout>>

<<gui_ScrollBoxLayout,ScrollBoxLayout>>

<<gui_SplitPanel,SplitPanel>>

<<gui_TabSheet,TabSheet>>

[[gui_Accordion]]
====== Accordion

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-accordion" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Контейнер `Accordion` - это вертикальный контейнер со сворачиваемыми вкладками, который позволяет легко скрывать и отображать большой объем контента. `Accordion` реализован для блока *Web Client*.

image::gui_accordion.png[align="center"]

XML-имя компонента: `accordion`.
Пример описания аккордеона в XML-дескрипторе экрана:
[source, xml]
----
include::{sourcesdir}/gui_vcl/accordion_1.xml[]
----

Компонент `accordion` должен иметь вложенные элементы `tab`, описывающие вкладки. Каждая вкладка является контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>. Контейнер *аккордеон* может быть использован при нехватке места на странице приложения, или же если название вкладки слишком длинное для отображения в `TabSheet`. Аккордеон предоставляет анимацию плавного перехода.

Атрибуты элемента `tab`:

* `id` – идентификатор вкладки. Следует отметить, что вкладка не является компонентом, и данный идентификатор используется только в рамках `Accordion` для работы с ней из кода контроллера..

* <<gui_attr_caption,caption>> – заголовок вкладки.

* <<gui_attr_icon,icon>> - указывает на местоположение пиктограммы в каталоге темы. Подробную информацию о том, где следует располагать файлы пиктограмм, можно прочитать в <<gui_themes>>.

[[gui_accordion_tab_lazy]]
* `lazy` – задает отложенную загрузку содержимого вкладки.
+
При открытии экрана `lazy`-вкладки не загружают свое содержимое, что приводит к созданию меньшего количества компонентов в памяти. Компоненты вкладки загружаются только в тот момент, когда пользователь выбирает данную вкладку. Кроме того, если на `lazy`-вкладке расположены визуальные компоненты, связанные с <<datasources, источником данных>>, содержащим JPQL запрос, то этот запрос также не выполняется. В результате экран открывается быстрее, а данные загружаются только в тот момент, когда пользователь действительно хочет их увидеть, выбирая данную вкладку.
+
[[gui_accordion_SelectedTabChangeListener]]
Следует иметь в виду, что компоненты, расположенные на `lazy`-вкладке, не существуют в момент открытия экрана. Поэтому их нельзя <<screen_controller_injection,инжектировать>> в контроллер, и нельзя получить вызовом `getComponent()` в методе `init()` контроллера. Обратиться к компонентам `lazy`-вкладки можно только после того, как пользователь на нее переключился. Этот момент можно отловить с помощью слушателя `Accordion.SelectedTabChangeListener`, например:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/accordion_1.java[]
----
+
По умолчанию вкладки не являются `lazy`, а значит, загружают свое содержимое в момент открытия экрана.

* В веб-клиенте с темой, основанной на Halo, атрибут `stylename` позволяет установить для компонента `accordion` стиль `borderless`, который удаляет рамку и фон контейнера:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/accordion_2.java[]
----

Вкладка компонента `accordion` может содержать любой другой визуальный контейнер, такой как таблица, сетка и т.д.:
[source, xml]
----
include::{sourcesdir}/gui_vcl/accordion_2.xml[]
----
image::gui_accordion_2.png[align="center"]

'''

Атрибуты accordion::
<<gui_attr_colspan, colspan>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_rowspan, rowspan>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabCaptionsAsHtml,tabCaptionsAsHtml>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты tab::
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_accordion_tab_lazy,lazy>> -
<<gui_attr_margin,margin>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>>

API::
<<gui_api_add,add>> -
<<gui_accordion_SelectedTabChangeListener,addSelectedTabChangeListener>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>>

'''

[[gui_BoxLayout]]
====== BoxLayout

`BoxLayout` представляет собой контейнер с последовательным размещением компонентов.

Существует три типа `BoxLayout`, определяемых именем XML-элемента:

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=hbox-sample" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

* `hbox` − горизонтальное расположение компонентов.
+
image::gui_hbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_1.xml[]
----

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=vbox-sample" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

* `vbox` − вертикальное расположение компонентов. `vbox` имеет 100% ширину по умолчанию.
+
image::gui_vbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_2.xml[]
----

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=flowbox-sample" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

* `flowBox` − горизонтальное расположение компонентов с переносом вниз. При недостатке места по горизонтали непомещающиеся компоненты будут перенесены "на следующую строку" (поведение аналогично *Swing* `FlowLayout`).
+
image::gui_flowbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_3.xml[]
----

В веб-клиенте с темой, основанной на Halo, `BoxLayout` может быть использован для создания сложных составных компонентов. Атрибут `stylename` со значением `card` или `well` в сочетании с атрибутом `stylename="v-panel-caption"` вложенного контейнера задают компоненту внешний вид https://vaadin.com/docs/-/part/framework/layout/layout-panel.html[Vaadin Panel].

* стиль `card` придаёт контейнеру вид карточки.

* `well` делает карточку "утопленной" с затемнением фона.

image::gui_boxlayout.png[align="center"]

[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_4.xml[]
----

Метод <<gui_api_getComponent,getComponent()>> позволяет получить дочерний компонент `BoxLayout` по его индексу:

[source, java]
----
include::{sourcesdir}/gui_vcl/boxlayout_1.java[]
----

[[gui_BoxLayout_addShortcutAction]]
В компоненте `BoxLayout` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/boxlayout.java[]
----

'''

Атрибуты hbox, vbox, flowBox::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_api_addLayoutClickListener,addLayoutClickListener>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_margin,getMargin>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_indexOf,indexOf>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_margin,setMargin>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_ButtonsPanel]]
====== ButtonsPanel

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=table-buttonspanel" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`ButtonsPanel` - контейнер, унифицирующий использование и размещение компонентов (чаще всего кнопок) для управления данными в таблице.

image::gui_buttonsPanel.png[align="center"]

XML-имя компонента: `buttonsPanel`.

Пример описания `ButtonsPanel` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/buttonspanel_1.xml[]
----

Элемент `buttonsPanel` можно разместить как внутри `table`, так и в произвольном месте экрана. 

Если `buttonsPanel` находится внутри `table`, то она комбинируется с компонентом <<gui_Table_rowsCount,rowsCount>> таблицы, тем самым оптимально расходуя место по вертикали. Кроме того, в этом случае при открытии экрана выбора методом `Frame.openLookup()` (например, из компонента <<gui_PickerField,PickerField>>) панель кнопок скрывается.

[[gui_ButtonsPanel_alwaysVisible]]
Атрибут `alwaysVisible` служит для отключения скрытия панели в экране выбора при его открытии методом `Frame.openLookup()`. Если значение атрибута равно `true`, то панель с кнопками не скрывается. По умолчанию значение атрибута равно `false`.

[[gui_ButtonsPanel_LayoutClickListener]]
События щелчка по области компонента `buttonsPanel` можно отслеживать с помощью интерфейса `LayoutClickListener`.

[[gui_ButtonsPanel_addShortcutAction]]
В компоненте `ButtonsPanel` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/buttonspanel.java[]
----

'''

Атрибуты buttonsPanel::
<<gui_attr_align,align>> -
<<gui_ButtonsPanel_alwaysVisible,alwaysVisible>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_addLayoutClickListener,addLayoutClickListener>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_CssLayout]]
====== CssLayout

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=responsive-csslayout" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Контейнер `CssLayout` позволяет управлять размещением и стилизацией своих компонентов с помощью CSS.

XML-имя компонента: `cssLayout`.

Ниже приведен пример использования `cssLayout` в простом responsive экране.

Отображение компонентов на широком дисплее:

image::gui_cssLayout_1.png[align="center"]

Отображение компонентов на узком дисплее:

image::gui_cssLayout_2.png[align="center"]

XML-дескриптор экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/cssLayout_1.xml[]
----

Содержимое файла `modules/web/themes/halo/halo-ext.scss` (в разделе <<web_theme_extension>> приведена информация о том как создать этот файл):

[source, css]
----
include::{sourcesdir}/gui_vcl/cssLayout_2.css[]
----

* Атрибут `stylename` позволяет применять стили к компоненту `CssLayout` в XML-дескрипторе или контроллере экрана.
+
--
* стиль `v-component-group` используется для склеивания компонентов, т.е. группировки без отступов между ними:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/cssLayout_3.xml[]
----
+
image::gui_csslayout_3.png[align="center"]

* стиль `well` делает контейнер "утопленным" с затемнением фона.

* стиль `card` придаёт контейнеру вид карточки. В сочетании со стилем `v-panel-caption`, установленным для любого вложенного контейнера, он позволяет создавать сложные составные контейнеры, например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/cssLayout_4.xml[]
----
+
image::gui_csslayout_4.png[align="center"]

--

[[gui_СssLayout_LayoutClickListener]]
События щелчка по области компонента `CssLayout` можно отслеживать с помощью интерфейса `LayoutClickListener`.

[[gui_СssLayout_addShortcutAction]]
В компоненте `СssLayout` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/cssLayout.java[]
----

'''

Атрибуты cssLayout::
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_responsive,responsive>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_addLayoutClickListener,addLayoutClickListener>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_indexOf,indexOf>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>>

'''

[[gui_Frame]]
====== Frame

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-frame" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Элемент `frame` предназначен для включения в экран <<frame,фреймов>>.

Атрибуты:

[[gui_Frame_src]]
* `src` − путь к XML-дескриптору фрейма.

[[gui_Frame_screen]]
* `screen` - идентификатор фрейма в <<screens.xml,screens.xml>> (если фрейм зарегистрирован).

Должен быть указан один из этих атрибутов. Если указано оба, фрейм будет загружен из явно указанного в `src` файла.

'''

Атрибуты frame::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Frame_screen,screen>> -
<<gui_Frame_src,src>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_margin,getMargin>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_indexOf,indexOf>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_margin,setMargin>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_GridLayout]]
====== GridLayout

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-grid" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`GridLayout` - контейнер, располагающий компоненты по сетке.

image::gui_gridlayout.png[align="center"]

XML-имя компонента: `grid`.

Пример использования контейнера:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_1.xml[]
----

Элементы `grid`:
[[gui_GridLayout_columns]]
* `columns` - обязательный элемент, описывает колонки сетки. Должен либо иметь атрибут `count`, либо вложенные элементы `column` для каждой колонки.
+
[[gui_GridLayout_columns_count]]
В простейшем случае достаточно задать число колонок в атрибуте `count`. Тогда, если ширина всего контейнера явно задана в пикселах или процентах, незанятое место будет распределяться между колонками равными долями.
+
[[gui_GridLayout_column_flex]]
Для распределения незанятого места неравными долями необходимо определить для каждой колонки элемент `column` и задать для него атрибут `flex`.
+
Пример сетки, в которой вторая и четвертая колонки занимают все лишнее место по горизонтали, причем четвертая колонка забирает себе в три раза больше лишнего места:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_2.xml[]
----
+
Если атрибут `flex` не указан, или указано значение 0, то ширина данной колонки будет установлена по содержимому, если хотя-бы одна другая колонка имеет ненулевой `flex`. В приведенном примере первая и третья колонки получат ширину по максимальной длине текста надписей.
+
[TIP]
====
Для того, чтобы лишнее место вообще образовалось, необходимо установить всему контейнеру ширину в пикселах или процентах. В противном случае ширина колонок будет рассчитана по ширине содержимого, и атрибут `flex` не будет иметь никакого эффекта.
====

[[gui_GridLayout_rows]]
* `rows` − обязательный элемент, содержит последовательность строк. Каждая строка определяется в своем элементе `row`.
+
[[gui_GridLayout_row_flex]]
Элемент `row` может содержать атрибут `flex`, аналогичный описанному для `column`, но влияющий на распределение лишнего места по вертикали при заданной общей высоте сетки.
+
Элемент `row` должен содержать элементы компонентов, отображаемых в ячейках данной строки сетки. Число компонентов в одной строке не должно превышать заданного количества колонок, но может быть меньше.

Любой компонент, находящийся в контейнере `grid`, может иметь атрибуты <<gui_attr_colspan,colspan>> и <<gui_attr_rowspan,rowspan>>. Эти атрибуты задают соответственно сколько колонок и строк будет занимать данный компонент. Например, так можно растянуть поле `Field3` на три колонки:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_3.xml[]
----

В результате компоненты будут располагаться следующим образом:

image::gui_gridlayout_colspan.png[align="center"]

[[gui_GridLayout_LayoutClickListener]]
События щелчка по области компонента `GridLayout` можно отслеживать с помощью интерфейса `LayoutClickListener`.

Метод <<gui_api_getComponent,getComponent()>> позволяет получить дочерний компонент `GridLayout` по индексам его колонки и строки:

[source, java]
----
include::{sourcesdir}/gui_vcl/gridlayout_1.java[]
----

[[gui_GridLayout_addShortcutAction]]
В компоненте `GridLayout` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/gridlayout.java[]
----

'''

Атрибуты grid::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы grid::
<<gui_GridLayout_columns,columns>> -
<<gui_GridLayout_rows,rows>>

Атрибуты columns::
<<gui_GridLayout_columns_count,count>>

Атрибуты column::
<<gui_GridLayout_column_flex,flex>>

Атрибуты row::
<<gui_GridLayout_row_flex,flex>> -
<<gui_attr_visible,visible>>

API::
<<gui_api_add,add>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_addLayoutClickListener,addLayoutClickListener>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_margin,getMargin>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_margin,setMargin>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_GroupBoxLayout]]
====== GroupBoxLayout

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-groupbox" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`GroupBoxLayout` - контейнер, позволяющий выделить рамкой содержащиеся в нем компоненты, и задать им общий заголовок. Кроме того, он умеет сворачивать свое содержимое.

image::gui_groupBox.png[align="center"]

XML-имя компонента: `groupBox`.

Пример описание контейнера в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/groupboxlayout_1.xml[]
----

Атрибуты `groupBox`:

* `caption` - заголовок группы.

[[gui_GroupBox_orientation]]
* `orientation` - задает направление расположения вложенных компонентов − `horizontal` или `vertical`. По умолчанию `vertical`.

[[gui_GroupBox_collapsable]]
* `collapsable` − значение `true` позволяет пользователю скрывать содержимое компонента с помощью значков image:gui_groupBox_minus.png[]/image:gui_groupBox_plus.png[].

[[gui_GroupBox_collapsed]]
* `collapsed` − если указано значение `true`, то содержимое компонента будет свернуто сразу после открытия экрана. Используется совместно с `collapsable="true"`. 
+
Пример свернутого `GroupBox`:
+
image::gui_groupBox_collapsed.png[align="center"]
+
[[gui_GroupBox_ExpandedStateChangeListener]]
Изменения состояния компонента `groupBox` (сворачивание и разворачивание) можно отслеживать с помощью интерфейса `ExpandedStateChangeListener`.

[[gui_GroupBox_panel]]
* `showAsPanel` – если указано значение `true`, то компонент будет выглядеть как link:https://vaadin.com/docs/-/part/framework/layout/layout-panel.html[Vaadin Panel]. Значение по-умолчанию - `false`.
+
image::gui_groupBox_Panel.png[align="center"]

Контейнер `groupBox` по умолчанию имеет ширину 100% аналогично <<gui_BoxLayout,vbox>>.

В веб-клиенте с темой, основанной на Halo, к компоненту `groupBox` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`. Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `LAYOUT_` или `GROUPBOX_`. Следующие стили должны использоваться совместно с атрибутом `showAsPanel`, имеющим значение `true`:

[[gui_groupbox_borderless]]
* стиль `borderless` удаляет рамку и фон контейнера `groupBox`:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/groupboxlayout_3.java[]
----

[[gui_groupbox_card]]
* стиль `card` придаёт контейнеру вид карточки.

[[gui_groupbox_well]]
* стиль `well` делает контейнер "утопленным" с затемнением фона:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/groupboxlayout_2.xml[]
----
+
image::gui_groupBox_Panel_2.png[align="center"]

[[gui_GroupBox_addShortcutAction]]
В компоненте `Groupbox` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/groupboxlayout.java[]
----


'''

Атрибуты groupBox::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_GroupBox_collapsable,collapsable>> -
<<gui_GroupBox_collapsed,collapsed>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_GroupBox_orientation,orientation>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_width,width>>

Предопределенные стили groupBox::
<<gui_groupbox_borderless,borderless>> -
<<gui_groupbox_card,card>> -
<<gui_groupbox_well,well>>

API::
<<gui_api_add,add>> -
<<gui_api_expanded,addExpandedStateChangeListener>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_settings,applySettings>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_indexOf,indexOf>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_settings,saveSettings>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_HtmlBoxLayout]]
====== HtmlBoxLayout

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=html-box" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`HtmlBoxLayout` позволяет определять расположение компонентов в HTML-шаблоне, который включается в <<web_theme,тему>>.

XML-имя компонента: `htmlBox`.

Ниже приведен пример использования `htmlBox` в простом экране.

image::gui_htmlBox_1.png[align="center"]

XML-дескриптор экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/htmlBox_1.xml[]
----

[[gui_htmlBox_template]]
Атрибут `template` задает имя HTML-файла, находящегося в подкаталоге `layouts` темы. Перед созданием шаблона необходимо создать <<web_theme_extension,расширение темы>> или <<web_theme_creation,новую тему>>. Например, если вы используете тему Halo и хотите назвать шаблон `my_template`, укажите `my_template` в атрибуте и разместите шаблон в файле `modules/web/themes/halo/layouts/my_template.html`.

Содержимое шаблона `modules/web/themes/halo/layouts/sample.html`:

[source, html]
----
include::{sourcesdir}/gui_vcl/htmlBox_2.html[]
----

Шаблон должен содержать элементы `<div>` с атрибутами `location`. В этих элементах будут отображаться компоненты CUBA, определенные в XML дескрипторе с соответствующими идентификаторами.

Содержимое файла `modules/web/themes/halo/halo-ext.scss` (в разделе <<web_theme_extension>> приведена информация о том как создать этот файл):

[source, css]
----
include::{sourcesdir}/gui_vcl/htmlBox_3.scss[]
----

'''

Атрибуты htmlBox::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_htmlBox_template,template>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>>

'''

[[gui_ScrollBoxLayout]]
====== ScrollBoxLayout

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-scrollbox" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`ScrollBoxLayout` − контейнер, который позволяет прокручивать свое содержимое.

image::gui_scrollBox.png[align="center"]

XML-имя компонента: `scrollBox`

Пример описание контейнера с прокруткой в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/scrollboxlayout_1.xml[]
----

[[gui_ScrollBox_orientation]]
* С помощью атрибута `orientation` можно задавать направление расположения вложенных компонентов − `horizontal` или `vertical`. По умолчанию `vertical`.

[[gui_ScrollBox_scrollBars]]
* Атрибут `scrollBars` позволяет настраивать полосы прокрутки. Может принимать значения `horizontal`, `vertical` - для прокрутки по горизонтали и вертикали соответственно, `both` - для прокрутки во всех направлениях. Установка значения `none` запрещает прокрутку в любом направлении

[WARNING]
====
Вложенные в `scrollBox` компоненты должны иметь фиксированные размеры или размеры по умолчанию. Нельзя устанавливать `height="100%"` или `width="100%"`.

В то же время `scrollBox` не может вычислять свои собственные размеры по содержимому. Ему нужно либо указать абсолютные размеры, либо растянуть в родительском контейнере, установив `height="100%"` и `width="100%"`.
====

[[gui_ScrollBox_addShortcutAction]]
В компоненте `ScrollBox` можно использовать горячие клавиши. Задать сочетание клавиш и вызываемое действие можно с помощью метода `addShortcutAction()`:

[source, java]
----
include::{sourcesdir}/gui_vcl/scrollboxlayout.java[]
----

'''

Атрибуты scrollBox::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_ScrollBox_orientation,orientation>> -
<<gui_ScrollBox_scrollBars,scrollBars>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_api_shortcut,addShortcutAction>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_margin,getMargin>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_indexOf,indexOf>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_margin,setMargin>> -
<<gui_api_spacing,setSpacing>>

'''

[[gui_SplitPanel]]
====== SplitPanel

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-split" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

`SplitPanel` − контейнер, разбитый на две области, размер которых по горизонтали либо вертикали можно менять путем перемещения разделителя. 

image::gui_splitPanel.png[align="center"]

XML-имя компонента: `split`.

Пример описания панели с разделителем в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/splitpanel_1.xml[]
----

Внутри контейнера `split` обязательно должны находиться два вложенных контейнера или компонента, которые и будут расположены по обе стороны разделителя.

Атрибуты `split`:

[[gui_SplitPanel_minmax]]
* `minSplitPosition`, `maxSplitPosition` - определяют диапазон допустимых значений позиции разделителя. Могут быть установлены в пикселях или в процентах.
+
Например, вы можете запретить перетаскивать сплиттер вне диапазона между 100 и 300 пикселями с левой стороны компонента:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/splitpanel_2.xml[]
----
+
Если вы хотите установить диапазон программно, вы должны указать единицу измерения с помощью `Component.UNITS_PIXELS` или `Component.UNITS_PERCENTAGE`
+
[source, java]
----
include::{sourcesdir}/gui_vcl/splitpanel_3.java[]
----

[[gui_SplitPanel_orientation]]
* `orientation` - задает ориентацию расположения компонентов. `horizontal` - вложенные компоненты располагаются горизонтально, `vertical` - вертикально.

[[gui_SplitPanel_pos]]
* `pos` - целое число, определяющее процентное соотношение размера первой области по отношению ко второй. Например, `pos="30"` означает соотношение областей 30/70. По умолчанию соотношение областей составляет 50/50.

[[gui_SplitPanel_reversePosition]]
* `reversePosition` - указывает, что атрибут `pos` содержит позицию разделителя, отсчитанную с обратной стороны компонента.

[[gui_SplitPanel_locked]]
* Если атрибут `locked` установлен в `true`, то пользователи не смогут изменить положение разделителя.

[[gui_SplitPanel_stylename]]
* Атрибут `stylename` со значением `large` увеличивает толщину разделителя.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/splitpanel_4.java[]
----

Методы `SplitPanel`:

[[gui_SplitPanel_getPosition]]
* Позицию разделителя можно получить с помощью метода `getSplitPosition()`.

[[gui_SplitPanel_PositionUpdateListener]]
* События изменения положения разделителя можно отлеж `PositionUpdateListener`.

* Если нужно получить единицу измерения позиции разделителя, используйте метод `getSplitPositionUnit()`. Он возвращает `Component.UNITS_PIXELS` или `Component.UNITS_PERCENTAGE`.

* `isSplitPositionReversed()` возвращает `true` в случае, если позиция отсчитывается с обратной стороны компонента.

'''

Атрибуты split::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_SplitPanel_locked,locked>> -
<<gui_SplitPanel_minmax,minSplitPosition>> -
<<gui_SplitPanel_minmax,maxSplitPosition>> -
<<gui_SplitPanel_orientation,orientation>> -
<<gui_SplitPanel_pos,pos>> -
<<gui_SplitPanel_reversePosition,reversePosition>> -
<<gui_attr_settingsEnabled,settingsEnabled>> -
<<gui_SplitPanel_stylename,stylename>> -
<<gui_attr_width,width>>

API::
<<gui_api_add,add>> -
<<gui_SplitPanel_PositionUpdateListener,addPositionUpdateListener>> -
<<gui_api_settings,applySettings>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>> -
<<gui_api_settings,saveSettings>>

'''

[[gui_TabSheet]]
====== TabSheet

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=simple-tabsheet" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Контейнер `TabSheet` - это панель с вкладками (`tabs`). В один момент времени отображается содержимое только одной вкладки.

image::gui_tabsheet.png[align="center"]

XML-имя компонента: `tabSheet`.

Пример описания панели с вкладками в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tabsheet_1.xml[]
----

Компонент `tabSheet` должен иметь вложенные элементы `tab`, описывающие вкладки. Каждая вкладка является контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>.

Атрибуты элемента `tab`:

[[gui_TabSheet_tab_id]]
* `id` - идентификатор вкладки. Следует отметить, что вкладка не является компонентом, и данный идентификатор используется только в рамках `TabSheet` для работы с ней из кода контроллера.

* <<gui_attr_caption,caption>> - заголовок вкладки.

[[gui_TabSheet_closable]]
* `closable` - определяет, будет ли отображаться кнопка *x* для закрытия вкладки. Значение по умолчанию - `false`.

* <<gui_attr_icon,icon>> - указывает на местоположение пиктограммы в каталоге темы. Применяется только для блока *Web Client*. Подробную информацию о том, где следует располагать файлы пиктограмм, можно прочитать в <<gui_themes,Создание темы приложения>>.

[[gui_TabSheet_tab_lazy]]
* `lazy` - задает отложенную загрузку содержимого вкладки. 
+
При открытии экрана lazy-вкладки не загружают свое содержимое, что приводит к созданию меньшего количества компонентов в памяти. Компоненты вкладки загружаются только в тот момент, когда пользователь выбирает данную вкладку. Кроме того, если на lazy-вкладке расположены визуальные компоненты, связанные с <<datasources,источником данных>>, содержащим JPQL запрос, то этот запрос также не выполняется. В результате экран открывается быстрее, а данные загружаются только в тот момент, когда пользователь действительно хочет их увидеть, выбирая данную вкладку. 
+
[[gui_TabSheet_SelectedTabChangeListener]]
Следует иметь в виду, что компоненты, расположенные на lazy-вкладке, не существуют в момент открытия экрана. Поэтому их нельзя <<screen_controller_injection,инжектировать>> в контроллер, и нельзя получить вызовом `getComponent()` в методе `init()` контроллера. Обратиться к компонентам `lazy`-вкладки можно только после того, как пользователь на нее переключился. Этот момент можно отловить с помощью слушателя `TabSheet.SelectedTabChangeListener`, например:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tabsheet_2.java[]
----
+
По умолчанию вкладки не являются `lazy`, а значит, загружают свое содержимое в момент открытия экрана.

[[gui_TabSheet_tab_detachable]]
* `detachable` - значение `true` в десктоп-реализации экрана дает возможность отсоединять вкладку в отдельное окно. Это позволяет, например, размещать части UI приложения на разных мониторах. Отделяемая вкладка имеет специальную кнопку в заголовке:
+
image::gui_tabsheetDetachable.png[align="center"]

Стили TabSheet::
+
--
В веб-клиенте с темой, основанной на Halo, к контейнеру `TabSheet` можно применить предопределенные стили. Стили задаются в XML-дексрипторе или контроллере экрана с помощью атрибута `stylename`:
[source, xml]
----
include::{sourcesdir}/gui_vcl/tabsheet_3.xml[]
----

Чтобы применить стиль программно, выберите одну из констант класса `HaloTheme` с префиксом компонента `TABSHEET_`:
[source, java]
----
include::{sourcesdir}/gui_vcl/tabsheet_4.java[]
----

[[gui_tabsheet_centered-tabs]]
* `centered-tabs` - центрирует вкладки на панели. Подходит для страниц, где все вкладки целиком помещаются на панели (т.е. нет прокрутки вкладок).

[[gui_tabsheet_compact-tabbar]]
* `compact-tabbar` - уменьшает отступы вокруг вкладок.

[[gui_tabsheet_equal-width-tabs]]
* `equal-width-tabs` - задаёт всем вкладкам на панели равный размер (т.е. expand ratio == 1 для всех вкладок). Заголовки вкладок будут обрезаны, если они не поместятся на вкладку целиком. Прокрутка вкладок в этом случае не работает (будут видны одновременно все вкладки).

[[gui_tabsheet_framed]]
* `framed` - добавляет рамку как вокруг всего контейнера целиком, так и вокруг каждой вкладки на панели.

[[gui_tabsheet_icons-on-top]]
* `icons-on-top` - располагает пиктограмму вкладки над её заголовком (по умолчанию пиктограммы располагаются слева от заголовка).

[[gui_tabsheet_only-selected-closeable]]
* `only-selected-closeable` - только выделенная вкладка имеет кнопку закрытия. Стиль не запрещает программного закрытия вкладок, а только скрывает кнопку от пользователя.

[[gui_tabsheet_padded-tabbar]]
* `padded-tabbar` - добавляет небольшие отступы вокруг вкладок на панели, так что они не касаются границ контейнера.
--

'''

Атрибуты tabSheet::
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_tabCaptionsAsHtml,tabCaptionsAsHtml>> -
<<gui_attr_tabIndex,tabIndex>> -
<<gui_attr_tabsVisible,tabsVisible>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты tab::
<<gui_attr_caption,caption>> -
<<gui_TabSheet_closable,closable>> -
<<gui_TabSheet_tab_detachable,detachable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_margin,margin>> -
<<gui_attr_icon,icon>> -
<<gui_TabSheet_tab_id,id>> -
<<gui_TabSheet_tab_lazy,lazy>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>>

Предопределенные стили tabSheet::
<<gui_tabsheet_centered-tabs,centered-tabs>> -
<<gui_tabsheet_compact-tabbar,compact-tabbar>> -
<<gui_tabsheet_equal-width-tabs,equal-width-tabs>> -
<<gui_tabsheet_framed,framed>> -
<<gui_tabsheet_icons-on-top,framed>> -
<<gui_tabsheet_only-selected-closeable,only-selected-closeable>> -
<<gui_tabsheet_padded-tabbar,padded-tabbar>>

API::
<<gui_api_add,add>> -
<<gui_TabSheet_SelectedTabChangeListener,addSelectedTabChangeListener>> -
<<gui_api_getComponent,getComponent>> -
<<gui_api_getComponentNN,getComponentNN>> -
<<gui_api_getComponents,getComponents>> -
<<gui_api_getOwnComponent,getOwnComponent>> -
<<gui_api_getOwnComponents,getOwnComponents>> -
<<gui_api_remove,remove>> -
<<gui_api_removeAll,removeAll>>

'''

[[gui_misc]]
===== Разное

В данном разделе рассматриваются различные элементы универсального пользовательского интерфейса, имеющие отношение к визуальным компонентам.

[[gui_formatter]]
====== Formatter

Formatter предназначен для преобразования некоторого значения в строку.

[WARNING]
====
Formatter предназначен для использования с read-only компонентами, такими как <<gui_Label,Label>>, колонка <<gui_Table,Table>> и тому подобными. Для форматирования значения в редактируемых компонентах, например <<gui_TextField,TextField>>, используйте механизм `<<datatype,Datatype>>`.
====

В XML-дескрипторе экрана formatter для компонента может быть задан во вложенном элементе `formatter`. Элемент имеет единственный атрибут:

* `class` − имя класса, реализующего интерфейс `com.haulmont.cuba.gui.components.Formatter`

Если конструктор класса formatter принимает параметр типа `org.dom4j.Element`, то ему будет передан элемент XML, описывающий данный `formatter`. Это можно использовать для параметризации экземпляра formatter'а, например, строкой форматирования. В частности, имеющиеся в платформе классы `DateFormatter` и `NumberFormatter` могут брать строку форматирования из атрибута `format`. Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/formatter_1.xml[]
----

Кроме того, класс `DateFormatter` распознает также атрибут `type`, который может принимать значения `DATE` или `DATETIME`. В этом случае форматирование производится с помощью механизма `<<datatype,Datatype>>` по строке формата `dateFormat` или `dateTimeFormat` соответственно. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/formatter_2.xml[]
----

[TIP]
====
Если formatter реализован внутренним классом, то он должен быть объявлен с модификатором `static`, а его имя для загрузки отделяется символом "$", например:

`<formatter class="com.sample.sales.gui.OrderBrowse$CurrencyFormatter"/>`
====

Formatter можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр formatter'а в метод `setFormatter()` компонента.

Пример объявления собственного formatter'а и использования его для форматирования значения колонки таблицы:

[source, java]
----
include::{sourcesdir}/gui_vcl/formatter_3.java[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/formatter_4.java[]
----

[[gui_presentations]]
====== Presentations

Механизм представлений позволяет пользователям системы управлять настройками отображения таблиц.

image::gui_presentations.png[align="center"]

Пользователи могут:

* Сохранять представления под уникальными именами. Настройки таблицы автоматически сохраняются в активном представлении.

* Редактировать и удалять представления.

* Переключаться между представлениями.

* Задавать представление по умолчанию, которое будет применяться при открытии экрана.

* Создавать глобальные представления, доступные всем пользователям системы. Для создания, изменения и удаления глобальных представлений пользователь должен иметь <<permissions,разрешение>> `cuba.gui.presentations.global`.

Представления доступны в компонентах, реализующих интерфейс `com.haulmont.cuba.gui.components.Component.HasPresentations`. В платформе такими компонентами являются:

* <<gui_Table,Table>>

* <<gui_GroupTable,GroupTable>>

* <<gui_TreeTable,TreeTable>>

[[gui_Timer]]
====== Timer

Таймер − это невизуальный компонент, позволяющий выполнять некоторый код контроллера экрана через определенные промежутки времени. Срабатывание таймера происходит в потоке обработки событий пользовательского интерфейса, что позволяет обновлять экран без каких-либо ограничений. Таймер прекращает работу при закрытии экрана, для которого он был создан.

Компонент реализован для блоков *Web Client* и *Desktop Client*. Для веб клиента реализация таймеров основана на опросе сервера из веб-браузера, для десктоп клиента - на `javax.swing.Timer`.

Основной способ создания таймеров - декларативно в XML-дескрипторе экрана в элементе `timers`, располагающемся между элементами `dsContext` и `layout`. 

Для описания таймера используется элемент `timer`.

* Атрибут `delay` является обязательным атрибутом, в нем задается интервал срабатывания таймера в миллисекундах.

* `autostart` - необязательный атрибут, при установке которого в `true` таймер стартует сразу после открытия экрана. По умолчанию `false`, что означает что для старта таймера необходимо вызвать его метод `start()`.

* `repeating` − необязательный атрибут, включает многократное срабатывание таймера. Если значение атрибута равно `true`, то таймер выполняется циклически, через равные промежутки времени, заданные в атрибуте `delay`. В противном случае таймер выполняется один раз через `delay` миллисекунд после старта таймера.

* `onTimer` − необязательный атрибут, содержащий имя метода, вызываемого при срабатывании таймера. Метод-обработчик должен быть определен в контроллере экрана с модификатором `public` и иметь один параметр типа `com.haulmont.cuba.gui.components.Timer`. 

Пример использования таймера для периодического обновления содержимого таблицы:

[source, xml]
----
include::{sourcesdir}/gui_vcl/timer_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_2.java[]
----

Таймер можно инжектировать в поле контроллера, либо получить методом `Window.getTimer()`. Управлять активностью таймера можно с помощью его методов `start()` и `stop()`. Для уже активного таймера вызов `start()` игнорируется. После остановки таймера методом `stop()` его можно снова запустить методом `start()`.

Пример определения таймера в XML дескрипторе и использования листенеров в контроллере:

[source, xml]
----
include::{sourcesdir}/gui_vcl/timer_3.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_4.java[]
----

Таймер можно также создавать в коде контроллера следующим образом:

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_5.java[]
----

[[gui_validator]]
====== Validator

Валидатор предназначен для проверки значения, введенного в визуальном компоненте.

[WARNING]
====
Следует отличать валидацию от проверки типа данных. Если для некоторого компонента, например <<gui_TextField,TextField>>, задан тип, отличный от строкового (это происходит при связывании с атрибутом сущности или назначении `datatype`), то компонент не позволяет ввести значение, не удовлетворяющее этому типу - при потере фокуса или нажатии *Enter* компонент отобразит предыдущее значение.

Валидация же срабатывает не сразу при вводе или потере компонентом фокуса, а только при вызове у компонента метода `validate()`. Это означает, что компонент (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации. Это не является проблемой, так как обычно компоненты ввода с валидацией располагаются в <<screen_edit,экране редактирования>>, а он автоматически вызывает валидацию всех своих компонентов перед коммитом. Если же компонент находится не в экране редактирования, то необходимо вызывать его метод `validate()` в контроллере явно.
====

В XML-дескрипторе экрана валидатор для компонента может быть задан во вложенном элементе `validator`. Возможные атрибуты элемента `validator`:

* `script` − путь к скрипту Groovy, осуществляющему валидацию.

* `class` − имя класса Java, реализующего интерфейс `Field.Validator`.

Groovy-валидатор и стандартные классы Java-валидаторов, расположенные в пакете `com.haulmont.cuba.gui.components.validators` поддерживают атрибут `message` − сообщение, выводимое пользователю в случае ошибки валидации. Атрибут должен содержать сообщение или ключ в пакете сообщений экрана, например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/validator_1.xml[]
----

[source, properties]
----
include::{sourcesdir}/gui_vcl/validator_1.properties[]
---- 

Выбор механизма валидации осуществляется следующим образом:

* Если не указано значение атрибута `script`, и сам элемент `validator` не содержит текста выражения Groovy, то в качестве валидатора используется класс, указанный в атрибуте `class`.

* Если элемент `validator` содержит текст, то он будет использован как выражение Groovy и выполнен с помощью <<scripting,Scripting>>.

* В противном случае с помощью <<scripting,Scripting>> будет выполнен скрипт Groovy, указанный в атрибуте `script`.

В выражение или скрипт Groovy будет передана одна переменная `value`, содержащая значение, введенное в визуальном компоненте. Выражение или скрипт должны вернуть `boolean` значение: `true` − valid, `false` − not valid.

Если в качестве валидатора используется класс Java, то он должен иметь либо дефолтный конструктор без параметров, либо конструктор со следующим набором параметров: 

* `org.dom4j.Element`, `String` - в этот конструктор будут переданы XML-элемент валидатора и имя пакета сообщений экрана.

* `org.dom4j.Element` - в этот конструктор будет передан XML-элемент валидатора.

[TIP]
====
Если валидатор реализован внутренним классом, то он должен быть объявлен с модификатором `static`, а его имя для загрузки отделяется символом "$", например:

[source, xml]
----
<validator class="com.sample.sales.gui.AddressEdit$ZipValidator"/>
----
====

Платформа уже содержит несколько реализаций наиболее часто используемых валидаторов (см. пакет `com.haulmont.cuba.gui.components.validators`), которые можно применять в проектах:

* `DateValidator`

* `DoubleValidator`

* `EmailValidator`

* `IntegerValidator`

* `LongValidator`

* `PatternValidator`

* `RangeValidator`

* `ScriptValidator`

* `StringValidator`

Валидатор-класс можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр валидатора в метод `addValidator()` компонента.

Пример создания класса валидатора почтового индекса: 

[source, java]
----
include::{sourcesdir}/gui_vcl/validator_2.java[]
---- 

Использование валидатора почтового индекса и стандартного валидатора по шаблону в полях компонента <<gui_FieldGroup,FieldGroup>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/validator_3.xml[]
---- 

Пример программного задания валидатора: 

[source, java]
----
include::{sourcesdir}/gui_vcl/validator_4.java[]
---- 

[[gui_api]]
===== API компонентов

Доступно для всех визуальных компонентов::
+
--
[[gui_api_unwrap]]
* `unwrap()` - возвращает экземпляр компонента для текущего типа клиента (компонент Vaadin или Swing). Можно использовать в клиентском модуле для доступа к API базового компонента, см. раздел <<webComponentsHelper>>.
+
[source, java]
----
com.vaadin.ui.TextField vTextField = textField.unwrap(com.vaadin.ui.TextField.class);
----

* `unwrapComposition()` - возвращает экземпляр самого внешнего контейнера для текущего типа клиента. Можно использовать в клиентском модуле для доступа к API базового компонента.

--

Component.Buffered::
+
--
[[gui_api_commit]]
* `commit()` - обновляет источник данных, сохраняя все изменения, внесённые после последнего коммита.

[[gui_api_discard]]
* `discard()` - отменяет все изменения, внесённые после последнего коммита. Значение компонента обновляется из источника данных.

[[gui_api_isModified]]
* `isModified()` - возвращает `true`, если значение компонента изменилось с момента последнего обновления из источника данных.

[source, java]
----
if (textArea.isModified()) {
    textArea.commit();
}
----

Доступно для компонентов:

<<gui_CheckBox,CheckBox>> -
<<gui_DateField,DateField>> -
<<gui_FileUploadField,FileUploadField>> -
<<gui_LookupField,LookupField>> -
<<gui_LookupPickerField,LookupPickerField>> -
<<gui_PickerField,PickerField>> -
<<gui_TextArea,TextArea>> -
<<gui_TextField,TextField>> -
<<gui_TimeField,TimeField>>
--

Component.Collapsable::
+
--
[[gui_api_expanded]]
* `addExpandedStateChangeListener()` - добавляет слушатель, реализующий интерфейс `ExpandedStateChangeListener`, для отслеживания событий сворачивания/разворачивания компонента.
+
[source, java]
----
groupBox.addExpandedStateChangeListener(e ->
        showNotification("Expanded: " + groupBox.isExpanded()));
----

Доступно для компонентов:

<<gui_Filter,Filter>> -
<<gui_GroupBoxLayout,GroupBoxLayout>>
--

Component.Container::
+
--
[[gui_api_add]]
* `add()` - добавляет дочерний компонент в контейнер.

[[gui_api_remove]]
* `remove()` - удаляет дочерний компонент из контейнера.

[[gui_api_removeAll]]
* `removeAll()` - удаляет все дочерние компоненты из контейнера.

[[gui_api_getOwnComponent]]
* `getOwnComponent()` - возвращает компонент, вложенный непосредственно в этот контейнер.

[[gui_api_getComponent]]
* `getComponent()` - возвращает компонент, находящийся где-либо внутри дерева компонентов в этом контейнере.

[[gui_api_getComponentNN]]
* `getComponentNN()` - возвращает компонент, находящийся где-либо внутри дерева компонентов в этом контейнере, и выбрасывает исключение, если компонент не найден.

[[gui_api_getOwnComponents]]
* `getOwnComponents()` - возвращает список всех компонентов, вложенных непосредственно в этот контейнер.

[[gui_api_getComponents]]
* `getComponents()` - возвращает список всех компонентов, находящихся где-либо внутри дерева компонентов в этом контейнере.

Доступно для компонентов:

<<gui_Accordion,Accordion>> -
<<gui_BoxLayout,BoxLayout>> -
<<gui_CssLayout,CssLayout>> -
<<gui_Frame,Frame>> -
<<gui_GridLayout,GridLayout>> -
<<gui_GroupBoxLayout,GroupBoxLayout>> -
<<gui_HtmlBoxLayout,HtmlBoxLayout>> -
<<gui_ScrollBoxLayout,ScrollBoxLayout>> -
<<gui_SplitPanel,SplitPanel>> -
<<gui_TabSheet,TabSheet>>
--

Component.OrderedContainer::
+
--
[[gui_api_indexOf]]
* `indexOf()` - вовзращает индекс компонента внутри упорядоченного контейнера.

Доступно для компонентов:

<<gui_BoxLayout,BoxLayout>> -
<<gui_CssLayout,CssLayout>> -
<<gui_Frame,Frame>> -
<<gui_GroupBoxLayout,GroupBoxLayout>> -
<<gui_ScrollBoxLayout,ScrollBoxLayout>> -
--

Component.HasSettings::
+
--
[[gui_api_settings]]
* `applySettings()` - восстанавливает последние пользовательские настройки для этого компонента.

* `saveSettings()` - сохраняет текущие пользовательские настройки для этого компонента.

Доступно для компонентов:

<<gui_DataGrid,DataGrid>> -
<<gui_Filter,Filter>> -
<<gui_GroupBoxLayout,GroupBoxLayout>> -
<<gui_SplitPanel,SplitPanel>> -
<<gui_Table,Table>> -
<<gui_TextArea,TextArea>>
--

Component.HasValue::
+
--
[[gui_api_addValueChangeListener]]
* `addValueChangeListener()` - добавляет слушатель, реализующий интерфейс `ValueChangeListener`, для отслеживания изменения значения компонента.
+
[source, java]
----
textField.addValueChangeListener(e ->
        showNotification("Before: " + e.getPrevValue() + ". After: " + e.getValue()));
----

Доступно для компонентов:

<<gui_CheckBox,CheckBox>> -
<<gui_ColorPicker,ColorPicker>> -
<<gui_DateField,DateField>> -
<<gui_DatePicker,DatePicker>> -
<<gui_FileUploadField,FileUploadField>> -
<<gui_Label,Label>> -
<<gui_LookupField,LookupField>> -
<<gui_LookupPickerField,LookupPickerField>> -
<<gui_MaskedField,MaskedField>> -
<<gui_OptionsGroup,OptionsGroup>> -
<<gui_OptionsList,OptionsList>> -
<<gui_PasswordField,PasswordField>> -
<<gui_PickerField,PickerField>> -
<<gui_ProgressBar,ProgressBar>> -
<<gui_RichTextArea,RichTextArea>> -
<<gui_SearchPickerField,SearchPickerField>> -
<<gui_SourceCodeEditor,SourceCodeEditor>> -
<<gui_SuggestionPickerField,SuggestionPickerField>> -
<<gui_TextArea,TextArea>> -
<<gui_TextField,TextField>> -
<<gui_TimeField,TimeField>> -
<<gui_TokenList,TokenList>> -
<<gui_TwinColumn,TwinColumn>>
--

Component.LayoutClickNotifier::
+
--
[[gui_api_addLayoutClickListener]]
* `addLayoutClickListener()` - добавляет слушатель, реализующий интерфейс `LayoutClickListener`, для отслеживания кликов по области компонента.
+
[source, java]
----
vbox.addLayoutClickListener(event ->
                showNotification("Clicked"));
----

Доступно для компонентов:

<<gui_ButtonsPanel,ButtonsPanel>> -
<<gui_BoxLayout,BoxLayout>> -
<<gui_CssLayout,CssLayout>> -
<<gui_GridLayout,GridLayout>>
--

Component.Margin::
+
--
[[gui_api_margin]]
* `setMargin()` - устанавливает компоненту внешние поля.
+
** Добавление внешних полей со всех сторон компонента:
+
[source, java]
----
vbox.setMargin(true);
----
+
** Добавление внешних полей только в верхней и нижней части компонента:
+
[source, java]
----
vbox.setMargin(true, false, true, false);
----
+
** Создание объекта конфигурации `MarginInfo`:
+
[source, java]
----
vbox.setMargin(new MarginInfo(true, false, false, true));
----

* `getMargin()` - возвращает конфигурацию внешних полей в виде экземпляра `MarginInfo`.

Доступно для компонентов:

<<gui_BoxLayout,BoxLayout>> -
<<gui_Filter,Filter>> -
<<gui_Frame,Frame>> -
<<gui_GridLayout,GridLayout>> -
<<gui_ScrollBoxLayout,ScrollBoxLayout>>
--

Component.ShortcutNotifier::
+
--
[[gui_api_shortcut]]
* `addShortcutAction()` - добавляет действие, вызываемое при нажатии определённого сочетания клавиш.
+
[source, java]
----
include::{sourcesdir}/gui_vcl/cssLayout.java[]
----

Доступно для компонентов:

<<gui_BoxLayout,BoxLayout>> -
<<gui_ButtonsPanel,ButtonsPanel>> -
<<gui_CssLayout,CssLayout>> -
<<gui_GridLayout,GridLayout>> -
<<gui_GroupBoxLayout,GroupBoxLayout>> -
<<gui_ScrollBoxLayout,ScrollBoxLayout>>
--

Component.Spacing::
+
--
[[gui_api_spacing]]
* `setSpacing()` - добавляет внутренние поля между компонентом и вложенными в него компонентами.
+
[source, java]
----
vbox.setSpacing(true);
----

Доступно для компонентов:

<<gui_BoxLayout,BoxLayout>> -
<<gui_ButtonsPanel,ButtonsPanel>> -
<<gui_Frame,Frame>> -
<<gui_GridLayout,GridLayout>>
<<gui_GroupBoxLayout,GroupBoxLayout>> -
<<gui_ScrollBoxLayout,ScrollBoxLayout>>
--

[[gui_attributes]]
===== XML-атрибуты компонентов

[[gui_attr_align]]
align:: 
+
--
Атрибут, задающий расположение компонента относительно вышестоящего контейнера.

Возможные значения:

* `++TOP_RIGHT++`

* `++TOP_LEFT++`

* `++TOP_CENTER++`

* `++MIDDLE_RIGHT++`

* `++MIDDLE_LEFT++`

* `++MIDDLE_CENTER++`

* `++BOTTOM_RIGHT++`

* `++BOTTOM_LEFT++`

* `++BOTTOM_CENTER++`

--

[[gui_attr_caption]]
caption:: 
+
--
Атрибут, устанавливающий заголовок для визуального компонента.

Значением атрибута должна быть либо строка сообщения, либо ключ в <<message_packs,пакете сообщений>>. В случае ключа значение должно начинаться с префикса `msg://`

Способы задания ключа:

* Короткий ключ − при этом сообщение ищется в пакете, заданном для данного экрана:
+
[source, plain]
----
caption="msg://infoFieldCaption"
----

* Полный ключ, с заданием пакета:
+
[source, plain]
----
caption="msg://com.company.sample.gui.screen/infoFieldCaption"
----

--

[[gui_attr_captionProperty]]
captionProperty:: 
+
--
Задает имя атрибута сущности, отображаемого компонентом. Используется только для сущностей, находящихся в источнике данных (например заданном для <<gui_LookupField,LookupField>> свойством <<gui_attr_optionsDatasource,optionsDatasource>>).

Если `captionProperty` не задан, будет отображаться <<namePattern_annotation,имя экземпляра>>.
--

[[gui_attr_colspan]]
colspan:: 
+
--
Указывает, сколько колонок сетки должен занять компонент (по умолчанию 1).

Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <<gui_GridLayout,GridLayout>>.
--

[[gui_attr_datasource]]
datasource:: 
+
--
Предназначен для задания <<datasources,источника данных>>, описанного в секции `dsContext` XML-дескриптора экрана.

При указании атрибута `datasource` для компонента, реализующего интерфейс `DatasourceComponent`, необходимо также задать атрибут <<gui_attr_property,property>>.
--

[[gui_attr_description]]
description:: 
Атрибут, задающий текст подсказки для компонента.

[[gui_attr_editable]]
editable:: 
+
--
Атрибут, указывающий на возможность редактирования содержимого компонента (не путать с <<gui_attr_enable,enable>>).

Возможные значения − `true`, `false`. По умолчанию `true`.

На возможность редактирования содержимого для компонента, связанного с данными (наследника `DatasourceComponent` или `ListComponent`), влияет также подсистема безопасности. Если по данным <<security_subsystem,подсистемы безопасности>> данный компонент должен быть недоступен для редактирования, значение атрибута `editable` не принимается во внимание.
--

[[gui_attr_enable]]
enable:: 
+
--
Атрибут компонента, устанавливающий его состояние: доступен, недоступен.

Если компонент недоступен, то он не принимает фокус ввода. Недоступность контейнера приводит к тому, что все его компоненты также становятся недоступными. Возможные значения − `true`, `false`. По умолчанию все компоненты доступны.
--

[[gui_attr_expand]]
expand:: 
+
--
Атрибут контейнера для управления его внутренней компоновкой.

Задает компонент внутри контейнера, который необходимо расширить на все доступное пространство в направлении размещения компонентов. Для контейнера с вертикальным размещением устанавливает компоненту 100% высоту, для контейнера с горизонтальным размещением - 100% ширину. Кроме того, при изменении размера контейнера изменять размер будет именно этот компонент.
--

[[gui_attr_height]]
height:: 
+
--
Атрибут, устанавливающий высоту компонента.

Может быть задана в пикселях либо в процентах от высоты вышестоящего контейнера. Например: `100px`, `100%`, `50`. Если единица измерения не указана, подразумевается высота в пикселях.

Установка значения в `%` означает, что компонент по высоте займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.

При выборе значения `AUTO` или `-1px` для компонента устанавливается высота по умолчанию, для контейнера высота определяется по содержимому, то есть суммарной высотой вложенных компонентов.
--

[[gui_attr_icon]]
icon:: 
+
--
Атрибут, устанавливающий пиктограмму для визуального компонента.

Значением атрибута должен быть путь к файлу пиктограммы относительно каталога <<gui_themes,темы>>. Например:

[source, xml]
----
icon="icons/create.png"
----

Если пиктограмма должна быть выбрана в зависимости от языка пользователя, можно указать путь к ней в пакете сообщений, а в атрибуте `icon` − ключ сообщения, например: 

[source, xml]
----
icon="msg://addIcon"
---- 

В веб клиенте с <<web_theme,темой>> Halo (или производной от нее) вместо файлов можно использовать элементы шрифта Font Awesome. Для этого достаточно указать константу из класса `com.vaadin.server.FontAwesome` с префиксом `font-icon:` например: 

[source, xml]
----
icon="font-icon:BOOK"
----
--

[[gui_attr_id]]
id:: 
+
--
Идентификатор компонента.

Рекомендуется формировать значение по правилам Java-идентификаторов и использовать camelСase, например, `userGrid`, `filterPanel`.Может быть указан для любого компонента и должен быть уникальным в пределах экрана.
--

[[gui_attr_inputPrompt]]
inputPrompt:: 
+
--
Атрибут `inputPrompt` задает строку, отображаемую в поле, если его значение равно `null`.

Атрибут используется для компонентов <<gui_TextField,TextField>>, <<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>> только в веб клиенте.
--

[[gui_attr_margin]]
margin:: 
+
--
Атрибут `margin` устанавливает наличие отступа между внешними границами и содержимым контейнера.

Может иметь два вида значений:

* `margin="true"` − установить отступ со всех сторон сразу

* `margin="true,false,true,false"` − установить отступ только сверху и снизу (формат значения "сверху,справа,снизу,слева")

По умолчанию отступы отсутствуют.
--

[[gui_attr_nullName]]
nullName:: 
+
--
Идентификатор опции, выбор которой будет равносилен установке значения в `null`.

Атрибут используется для компонентов <<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>.

Пример для компонента <<gui_LookupField,LookupField>>, установка значения атрибута в <<screen_xml_glossentry,XML-дескрипторе>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/nullname_1.xml[]
----

Пример для компонента <<gui_LookupField,LookupField>>, установка значения атрибута в <<screen_controller_glossentry,контроллере>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/nullname_2.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/nullname_3.java[]
----
--

[[gui_attr_openType]]
openType::
+
--
Задает режим открытия связанного экрана. Соответствует перечислению `WindowManager.OpenType` со значениями `NEW_TAB`, `THIS_TAB`, `NEW_WINDOW`, `DIALOG`.  По умолчанию `THIS_TAB`.
--

[[gui_attr_optionsDatasource]]
optionsDatasource:: 
+
--
Задает имя <<datasources,источника данных>>, используемого для формирования списка опций.

Совместно с `optionsDatasource` может использоваться атрибут <<gui_attr_captionProperty,captionProperty>>.
--

[[gui_attr_property]]
property:: 
+
--
Атрибут компонента, реализующего интерфейс `DatasourceComponent`.

Предназначен для задания имени атрибута сущности, значение которого будет отображаться или редактироваться данным визуальным компонентом.

Используется всегда совместно с атрибутом <<gui_attr_datasource,datasource>>.
--

[[gui_attr_required]]
required:: 
+
--
Атрибут визуального компонента, реализующего интерфейс `Field`. Указывает, что в данное поле обязательно должно быть введено значение.

Возможные значения атрибута − `true`, `false`. По умолчанию `false`.

Совместно с `required` может использоваться атрибут <<gui_attr_requiredMessage,requiredMessage>>.
--

[[gui_attr_requiredMessage]]
requiredMessage:: 
+
--
XML-атрибут, используемый совместно с атрибутом <<gui_attr_required,required>>. Позволяет установить сообщение, выводимое пользователю в случае нарушения требования <<gui_attr_required,required>>.

Атрибут может содержать сообщение или ключ в пакете сообщений, например: `requiredMessage="msg://infoTextField.requiredMessage"`
--

[[gui_attr_responsive]]
responsive::
+
--
Определяет, должен ли компонент реагировать на изменения размеров доступной области. Реакцию можно задать с помощью <<web_theme_extension,стилей>>.

Возможные значения атрибута − `true`, `false`. По умолчанию `false`.
--

[[gui_attr_rowspan]]
rowspan:: 
+
--
Указывает, сколько строк сетки должен занять компонент (по умолчанию 1).

Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <<gui_GridLayout,GridLayout>>.
--

[[gui_attr_settingsEnabled]]
settingsEnabled::
+
--
Определяет, нужно ли сохранять пользовательские настройки отображения компонента. Настройки сохраняются только для компонентов, имеющих <<gui_attr_id,id>>.

Возможные значения атрибута − `true`, `false`. По умолчанию `true`.
--

[[gui_attr_spacing]]
spacing:: 
+
--
Атрибут `spacing` устанавливает наличие отступов между компонентами внутри контейнера.

Возможные значения − `true`, `false`.

По умолчанию отступы отсутствуют.
--

[[gui_attr_stylename]]
stylename:: 
Атрибут, задающий имя стиля компонента. Подробнее см. <<gui_themes>>.
+
--
В теме `halo` определено несколько стандартных стилей для компонентов:

[[gui_attr_stylename_huge]]
* `huge` - устанавливает размер поля 160% от его размера по умолчанию.

[[gui_attr_stylename_large]]
* `large` - устанавливает размер поля 120% от его размера по умолчанию.

[[gui_attr_stylename_small]]
* `small` - устанавливает размер поля 85% от его размера по умолчанию.

[[gui_attr_stylename_tiny]]
* `tiny` - устанавливает размер поля 75% от его размера по умолчанию.
--

[[gui_attr_tabCaptionsAsHtml]]
tabCaptionsAsHtml::
+
--
Определяет, разрешена ли HTML-разметка в заголовках вкладок. Если выбрано значение `true`, заголовки отображаются в браузере как HTML, при этом ответственность за безопасность используемого HTML-кода несёт сам разработчик. Если выбрано значение `false`, содержимое заголовка отображается как обычный текст.

Возможные значения − `true`, `false`. По умолчанию `false`.
--

[[gui_attr_tabIndex]]
tabIndex::
+
--
Определяет, может ли компонент принимать фокус, и задаёт относительный порядок перехода фокуса между компонентами экрана.

Может принимать положительное или отрицательное целочисленное значение:

* `отрицательное значение` означает, что компонент может принимать фокус, но будет пропущен при последовательном перемещении фокуса с клавиатуры;

* `0` означает, что компонент может принимать фокус, в том числе и при его перемещении с клавиатуры, но его относительный порядковый номер будет совпадать с его расположением на экране относительно других компонентов.

* `положительное значение` означает, что компонент может принимать фокус, в том числе и при его перемещении с клавиатуры. Относительный порядковый номер компонента будет совпадать со значением атрибута: фокус будет перемещаться от меньшего значения `tabIndex` к большему. Если для нескольких компонентов установлено одинаковое значение `tabIndex`, порядок их фокуса будет будет совпадать с их расположением на экране относительно друг друга.
--

[[gui_attr_tabsVisible]]
tabsVisible::
+
--
Определяет, должна ли область выбора вкладок отображаться в UI.

Возможные значения − `true`, `false`. По умолчанию `true`.
--

[[gui_attr_textSelectionEnabled]]
textSelectionEnabled::
+
--
Определяет, разрешено ли выделение текста в ячейках таблицы.

Возможные значения атрибута − `true`, `false`. По умолчанию `false`.
--

[[gui_attr_visible]]
visible:: 
+
--
Атрибут, устанавливающий видимость компонента. Возможные значения − `true`, `false`. 

Если контейнер невидим, не видны и все его компоненты. По умолчанию все компоненты видимы.
--

[[gui_attr_width]]
width:: 
+
--
Атрибут, устанавливающий ширину компонента.

Значение может быть задано в пикселях или в процентах от ширины вышестоящего контейнера. Например: `100px`, `100%`, `50`. Если единица измерения не указана, подразумевается ширина в пикселях. Простановка значения в `%` означает, что компонент по ширине займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.

При выборе значения `AUTO` или `-1px` для компонента устанавливается ширина по умолчанию, для контейнера ширина определяется по содержимому, то есть суммарной шириной вложенных компонентов.
--

[[security_subsystem]]
== Подсистема безопасности

Платформа CUBA включает в себя следующие средства разграничения прав доступа пользователей к информации: 

* Система назначения пользователям <<permissions,разрешений>>, основанная на <<roles,ролях>>; при этом набор ролей и разрешений настраивается администратором системы на этапе внедрения.

* Иерархическая структура <<groups,групп доступа>> с наследованием <<constraints,ограничений>>.

* Контроль доступа на следующих уровнях: 

** Операции над сущностями предметной области (чтение, создание, изменение, удаление): например, пользователь `*Иванов*` может просматривать документы, но не может создавать, изменять и удалять их.

** Атрибуты сущностей (изменение, чтение, запрет): пользователь `*Иванов*` видит все атрибуты документов, кроме суммы.

** Доступ к определенным экземплярам сущностей (контроль доступа на уровне строк): пользователь `*Иванов*` видит только те документы, которые были созданы в его отделе.

* Интеграция с <<ldap,LDAP>> с возможностью реализации технологии единого входа (Single Sign-On) для пользователей *Windows*. 

[[security_web]]
=== Безопасность веб-приложения

*Защищены ли CUBA приложения?*

Фреймворк CUBA Platform следует лучшим практикам безопасности и предоставляет автоматическую защиту от большинства самых распространённых уязвимостей веб-приложений. Архитектура платформы реализует безопасную модель программирования, позволяя вам сконцентрироваться на бизнес задачах и логике приложений.

1. *Состояние и валидация данных UI*
+
<<gui_web,Web Client>> - серверное приложение, в котором всё состояние вашего приложения, бизнес- и UI-логика расположены на сервере. В отличие от фронт-енд фреймворков, исполняющих код UI в веб-браузере, веб-клиент никогда не открывает серверные структуры данных для клиентской части, где уязвимости могут быть использованы злонамеренным кодом. Валидация данных всегда выполняется на сервере, гарантируя, что злонамеренные пользователи не смогут её обойти, то же самое применимо и к валидации данных в универсальном <<rest_api_v2,REST API>>.

2. *Межсайтовый скриптинг (Cross-Site Scripting / XSS)*
+
Веб-клиент имеет встроенную защиту от атак межсайтового скриптинга (XSS). Все выводимые данные автоматически преобразуются в HTML формат перед тем как они будут показаны в веб-браузере.

3. *Межсайтовая подделка запроса (Cross-Site Request Forgery / CSRF)*
+
Все запросы между сервером и клиентом включают CSRF токен, специфичный для пользовательской сесси. Фреймворк https://vaadin.com/framework/[Vaadin] обеспечивает всё взаимодействие между сервером и клиентом, поэтому вам не потребуется добавлять CSRF токен к каждому запросу вручную.

4. *Веб-сервисы*
+
Все сетевые вызовы в веб-клиенте проходят через один веб-сервис, используемый для вызова удалённых процедур (RPC) из клиентской части UI компонентов. Приложения не открывают доступ к своей бизнес-логике в виде веб-сервисов, поэтому пользователям доступно меньшее количество точек входа для возможных атак.
+
Универсальный REST API автоматически применяет разрешения ролей и все ограничения (constraints) как для пользователей системы, выполнивших вход, так и при анонимном доступе.

5. *SQL Инъекции*
+
Платформа использует слой <<orm,ORM>> на базе EclipseLink, реализующую защиту от SQL инъекций. Параметры SQL запросов всегда передаются в JDBC в виде массива параметров и не подставляются в SQL запросы в виде строк.

[[security_components]]
=== Компоненты подсистемы безопасности

Основные компоненты подсистемы безопасности CUBA приведены на следующей диаграмме. 

.Диаграмма компонентов подсистемы безопасности
image::Security.png[align="center"]

Рассмотрим их более подробно. 

_Security management screens_ - имеющиеся в платформе экраны, с помощью которых администратором системы осуществляется настройка прав доступа <<users,пользователей>>.

_Login screen_ − <<login_screen,окно входа>> в систему. В этом окне производится аутентификация пользователя по имени учетной записи и паролю. В базе данных вместо пароля, в целях его безопасности, хранится хэш.

После входа пользователя в систему создается объект <<userSession,UserSession>> − пользовательская сессия. Это центральный элемент обеспечения безопасности, объект, ассоциированный с аутентифицированным в данный момент в системе пользователем и содержащий информацию о правах доступа пользователя к данным.

Процесс входа пользователя в систему подробно описан в разделе <<login,>>.

_Roles_ − роли пользователей. <<roles,Роль>> - это объект системы, которому с одной стороны сопоставляется набор <<permissions,разрешений>>, необходимых для выполнения конкретных функций, а с другой стороны − подмножество пользователей, которые должны иметь эти разрешения. 

Разрешения бывают следующих типов:

* _Screen Permissions_ - возможность открытия некоторого экрана.

* _Entity Operation Permissions_ - возможность совершения операции с некоторой сущностью: чтение, создание,модификация, удаление. 

* _Entity Attribute Permissions_ - доступ к произвольному атрибуту некоторой сущности: модификация, только чтение, нет доступа.

* _Specific Permissions_ - разрешение на некоторую именованную функциональность.

* _UI Permissions_ - управление доступом к элементам некоторого экрана. 

_Access Groups_ - группы доступа пользователей. <<groups,Группы>> представляют собой иерархическую структуру, каждый элемент которой задает набор <<constraints,ограничений>> (_Constraints_), позволяющих контролировать доступ на уровне отдельных экземпляров (строк таблицы) некоторой сущности. Например, пользователь видит только те документы, которые были созданы в его отделе.

[[login_screen]]
==== Окно входа в систему

Окно входа в систему (Login screen) предназначено для регистрации пользователя путем ввода логина и пароля. Логин не чувствителен к регистру вводимых символов.

Управлять отображением флажка *Remember Me* в веб клиенте можно с помощью свойства приложения <<cuba.web.rememberMeEnabled,cuba.web.rememberMeEnabled>>. Стандартное окно входа содержит также выпадающий список поддерживаемых системой языков. Отображение списка и его содержимое определяются комбинацией свойств приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>> и <<cuba.availableLocales,cuba.availableLocales>>.

См. также свойства приложения <<cuba.web.loginDialogDefaultUser,cuba.web.loginDialogDefaultUser>>, <<cuba.web.loginDialogDefaultPassword,cuba.web.loginDialogDefaultPassword>> и <<cuba.web.loginDialogPoweredByLinkVisible,cuba.web.loginDialogPoweredByLinkVisible>>.

В веб-клиенте стандартное окно логина можно кастомизировать или полностью заменить в проекте, используя ссылку *Generic UI > New > Login Window* в Studio. См. также <<gui_web,>>.

В платформе имеется механизм защиты от взлома пароля методом перебора, см. свойство приложения <<cuba.bruteForceProtection.enabled,cuba.bruteForceProtection.enabled>>.

Для более глубокой кастомизации процесса аутентификации, см. разделы <<login>> и <<web_login>>.

[[users]]
==== Пользователи

Для каждого пользователя системы создается соответствующий экземпляр сущности `sec$User`. Он содержит уникальный логин, хэш пароля, ссылку на группу доступа, список ролей и другие атрибуты. Управление пользователями осуществляется с помощью экрана *Administration* → *Users*:

image::security_user_browser.png[align="center"]

Помимо стандартных действий создания, изменения и удаления записей имеются следующие:

* *Copy* - быстрое создание нового пользователя на основе выбранного. Новый пользователь будет иметь такую же группу доступа и набор ролей. И то и другое можно изменить в появляющемся экране редактирования нового пользователя.

* *Copy settings* - позволяет скопировать выбранным пользователям настройки интерфейса, сделанные каким-либо другим пользователем. Настройки интерфейса включают в себя <<gui_Table_presentations,представления таблиц>>, положение разделителей контейнеров <<gui_SplitPanel,SplitPanel>>, наборы <<gui_Filter,фильтров>> и <<folders_pane,папок поиска>>.

* *Change password* - позволяет администратору системы задать новый пароль выбранному пользователю.

* *Reset passwords* - позволяет произвести следующие действия над выбранными пользователями:

** Если в появляющемся окне *Reset passwords for selected users* не включать флажок *Generate new passwords*, то пользователям будет установлен признак *Change password at next logon*. При следующем успешном логине пользователя ему будет предложено сменить свой пароль.
+
[TIP]
====
Для того, чтобы пользователь мог сменить себе пароль, у него должно быть право на экран `sec$User.changePassword`. Имейте это в виду при конфигурировании <<roles,ролей>>, особенно если вы назначаете всем пользователям *Denying* роль. Данный экран можно найти внутри элемента *Other screens* в редакторе роли.
====

** Если в окне *Reset passwords for selected users* включить флажок *Generate new passwords*, то для выбранных пользователей будут сгенерированы и показаны новые случайные пароли. Список новых паролей можно выгрузить в формат XLS, и например, разослать пользователям. Кроме того, для каждого пользователя будет установлен признак *Change password at next logon*, что делает сгенерированный пароль одноразовым.

** Если в дополнение к *Generate new passwords* включить флажок *Send emails with generated passwords*, то новые одноразовые пароли не будут показаны администратору, а автоматически разосланы соответствующим пользователям на их адреса email. Отправка осуществляется асинхронно, поэтому требуется настройка назначенного задания, упомянутая в разделе <<email_sending_methods>>.
+
--
Шаблоны этих email можно отредактировать. Для этого необходимо создать в модуле *core* шаблоны по аналогии с https://github.com/cuba-platform/cuba/blob/master/modules/core/src/com/haulmont/cuba/security/app/email/reset-password-subject.gsp[reset-password-subject.gsp] и https://github.com/cuba-platform/cuba/blob/master/modules/core/src/com/haulmont/cuba/security/app/email/reset-password-body.gsp[reset-password-body.gsp]. Для локализации можно добавить соответствующие файлы шаблонов с суффиксами локалей, как это сделано в https://github.com/cuba-platform/cuba/tree/master/modules/core/src/com/haulmont/cuba/security/app/email[платформе].

В шаблонах используется синтаксис Groovy `SimpleTemplateEngine`, что позволяет использовать блоки кода Groovy прямо в тексте шаблона. Например:

[source, plain]
----
include::{sourcesdir}/security/reset-password-body.gsp[]
----

В шаблонах доступны следующие переменные: `user`, `password` и `persistence`. Вы также можете использовать бины Spring среднего слоя, для этого импортируйте класс `AppBeans` и получите нужный бин с помощью метода `AppBeans.get()`.

После переопределения шаблонов в `app.properties` модуля *core* необходимо задать следующие свойства:

[source, xml]
----
cuba.security.resetPasswordTemplateBody = <relative path to your file>
cuba.security.resetPasswordTemplateSubject = <relative path to your file>
----
Для удобства настройки в production, шаблоны можно разместить или переопределить в <<conf_dir,конфигурационном каталоге>> и задать свойства в `local.app.properties`.
--

Рассмотрим экран редактирования пользователя:

image::security_user_editor.png[align="center"]

* *Login* - обязательный к заполнению уникальный логин пользователя.

* *Group* - <<groups,группа доступа>>.

* *Last name*, *First name*, *Middle name* - части полного имени пользователя.

* *Name* - полное имя пользователя. Автоматически формируется на основе вводимых частей (Last, First, Middle) и правила, заданного свойством приложения <<cuba.user.fullNamePattern,cuba.user.fullNamePattern>>. Может быть произвольно изменено вручную.

* *Position* - должность.

* *Language* - язык интерфейса, устанавливаемый для пользователя, если возможность выбирать язык при входе в систему отключена при помощи свойства приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>>.

* *Time Zone* – <<timeZone,часовой пояс>>, в соответствии с которым будут отображаться и вводиться значения типа timestamp.

* *Email* - адрес email.

* *Active* - если данный флаг не установлен, то пользователь не может войти в систему.

* *Permitted IP Mask* - маска разрешенных IP-адресов, с которых возможен вход в систему.
+
Маска представляет собой список адресов через запятую. Поддерживаются как адреса формата IPv4, так и адреса формата IPv6. В первом случае адрес должен состоять из четырех чисел, разделенных точками, при этом любая часть вместо числа может содержать знак "++*++", что означает "любое число". Адрес в формате IPv6 представляет собой восемь групп по четыре шестнадцатеричные цифры, разделенных двоеточием. Любая группа также может быть заменена знаком "++*++".
+
Маска может содержать адреса только одного формата. Наличие адресов формата IPv4 и IPv6 одновременно недопустимо.
+
Пример: `++192.168.*.*++`

* *Roles* - список <<roles,ролей>> пользователя.

* *Substituted Users* - список <<user_substitution,замещаемых>> пользователей.

[[user_substitution]]
===== Замещение пользователей

Администратор системы может дать возможность пользователю _замещать_ другого пользователя. При этом у замещающего пользователя <<userSession,сессия>> не меняется, а подменяется набор <<roles,ролей>>, <<constraints,ограничений>> и <<session_attr,атрибутов>>. Все эти параметры текущий пользователь получает от замещаемого пользователя. 

[TIP]
====
В прикладном коде для получения текущего пользователя рекомендуется использовать метод `UserSession.getCurrentOrSubstitutedUser()` возвращающий либо замещаемого пользователя, либо пользователя, выполнившего логин (если замещения в данный момент нет).

В то же время механизмы аудита платформы (атрибуты `createdBy` и `updatedBy`, <<entity_log,журнал изменений>> и <<entity_snapshots,снимки>> сущностей) всегда регистрируют пользователя, который произвел логин, а не замещаемого пользователя.
====

Если пользователь имеет замещаемых пользователей, то в правом верхнем углу главного окна приложения вместо простой надписи с именем текущего пользователя отображается выпадающий список:

image::user_subst_select.png[align="center"]

При выборе другого пользователя в этом списке все открытые экраны будут закрыты, и произойдет замещение. После этого метод `UserSession.getUser()` по-прежнему будет возвращать пользователя, выполнившего логин в систему, а метод `UserSession.getSubstitutedUser()` - замещенного пользователя. Если замещения нет, метод `UserSession.getSubstitutedUser()` возвращает `null`.

Управление замещаемыми пользователями производится с помощью таблицы *Substituted Users* экрана редактирования пользователя. Рассмотрим экран добавления замещаемого пользователя:

image::user_subst_edit.png[align="center"]

* *User* - текущий редактируемый пользователь. Он будет замещать другого пользователя.

* *Substituted user* - замещаемый пользователь.

* *Start date*, *End date* - необязательный период замещения. Вне периода замещение будет недоступным. Если период не указан, замещение доступно, пока не удалена данная запись таблицы.

[[timeZone]]
==== Часовой пояс

Все значения даты и времени по умолчанию отображаются в соответствии с часовым поясом сервера. Часовой пояс сервера возвращается методом `TimeZone.getDefault()` <<app_tiers,блока>> приложения. По умолчанию, платформа получает часовой пояс из операционной системы, однако его можно явно задать системным свойством Java `user.timezone`. Например, чтобы задать часовой пояс по Гринвичу для веб-клиента и Middleware, работающих на сервере Tomcat под Unix, нужно добавить в файл `tomcat/bin/setenv.sh` следующее свойство: 

[source, bash]
----
CATALINA_OPTS="$CATALINA_OPTS -Duser.timezone=GMT"
---- 

Пользователь может просматривать и редактировать значения типа timestamp в часовых поясах, отличных от часового пояса сервера. Существует два способа управления часовыми поясами пользователя: 

* Администратор может задать часовой пояс в экране редактирования пользователя.

* Пользователь может задать свой часовой пояс в окне *Help → Settings*.

В обоих случаях, часовой пояс настраивается при помощи двух полей: 

* Выпадающий список с названиями часовых поясов позволяет явно выбрать часовой пояс.

* Флажок *Auto* указывает, что часовой пояс будет получен из текущего окружения (для веб-клиента - из веб-браузера, для для десктоп-клиента - из операционной системы). 

Если оба поля пусты, часовые пояса для пользователя не конвертируются. В противном случае, платформа сохраняет часовой пояс в объекте <<userSession,UserSession>> при логине и использует его для ввода и отображения значений типа timestamp. Значение, возвращаемое методом `UserSession.getTimeZone()` может также использоваться и в прикладном коде.

Если часовой пояс используется для текущей сессии, его краткое имя и отклонение от времени по Гринвичу отображаются в главном окне приложения рядом с именем текущего пользователя.

[TIP]
====
Преобразование часовых поясов выполняется только для атрибутов типа <<datatype,DateTimeDatatype>>, то есть, содержащих timestamp. Атрибуты, хранящие только дату (`DateDatatype`) или время (`TimeDatatype`) по отдельности, не конвертируются. Вы можете запретить преобразование отдельных timestamp-атрибутов, установив для них аннотацию <<ignoreUserTimeZone,@IgnoreUserTimeZone>>.
====

[[permissions]]
==== Разрешения

_Разрешение_ определяет право пользователя на какой-либо объект или функциональность системы: экран, операцию над сущностью и так далее. Разрешение в зависимости от своего значения может как дать пользователю право на объект, так и отобрать его (то есть по сути являться _запрещением_).

[TIP]
====
Если явного разрешения на объект не установлено, пользователь имеет право на этот объект.
====

Разрешения представляются экземплярами сущности `sec$Permission` и содержат следующие атрибуты:

* `type` - тип разрешения: определяет, на какой тип объектов накладывается разрешение.

* `target` - конкретный объект разрешения. Формат представления объекта зависит от типа разрешения.

* `value` - значение разрешения. Диапазон значений зависит от типа разрешения.

Рассмотрим типы разрешений:

* `PermissionType.SCREEN` - разрешение на экран системы.
+
В атрибуте `target` указывается идентификатор экрана, атрибут `value` может иметь значения 0 или 1 (экран запрещен или разрешен соответственно).
+
Права на экраны проверяются при построении главного меню системы и при каждом вызове методов `openWindow()`, `openEditor()`, `openLookup()` интерфейса <<abstractFrame,Frame>>.
+
Для проверки права на экран в прикладном коде используйте метод `isScreenPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_OP++` - разрешение на операцию c сущностью.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя операции: `create`, `read`, `update`, `delete`. Например: `library$Book:delete`. Атрибут `value` может иметь значения 0 или 1 (операция запрещена или разрешена соответственно).
+
Права на операции с сущностью проверяются при работе с данными через <<dataManager,DataManager>>, а также в связанных с данными <<gui_components,визуальных компонентах>> и <<standard_actions,стандартных действиях>> со списками сущностей. В результате права на операции оказывают влияние на поведение клиентских блоков и <<rest_api_v2,REST API>>. При работе с данными непосредственно на Middleware через <<entityManager,EntityManager>> права не проверяются.
+
Для проверки права на операцию c сущностью в прикладном коде используйте метод `isEntityOpPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_ATTR++` - разрешение на атрибут сущности.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя атрибута, например: `library$Book:name`. Атрибут `value` может иметь значения 0, 1 или 2 (атрибут скрыт, только для чтения, или полностью разрешен соответственно).
+
Права на атрибуты сущностей проверяются только в связанных с данными <<gui_components,визуальных компонентах>> и <<rest_api_v2,REST API>>.
+
Для проверки права на атрибут сущности в прикладном коде используйте метод `isEntityAttrPermitted()` интерфейса <<security,Security>>.

* `PermissionType.SPECIFIC` - разрешение на произвольную именованную функциональность. Такие разрешения удобно использовать вместо ролей, когда нужно бинарное запрещение/разрешение определённой функциональности конкретного проекта, так как роли - это агрегаторы разрешений.
+
В атрибуте `target` указывается код функциональности, атрибут `value` может иметь значения 0 или 1 (запрещено или разрешено соответственно).
+
Набор специфических разрешений для данного проекта задается в конфигурационном файле <<permissions.xml,permissions.xml>>.
+
Пример использования:
+
[source, java]
----
@Inject
private Security security;

private void calculateBalance() {
    if (!security.isSpecificPermitted("myapp.calculateBalance"))
        return;
    ...
}
----

* `PermissionType.UI` - разрешение на произвольный компонент экрана.
+
В атрибуте `target` указывается идентификатор экрана и через символ ":" путь к компоненту. Описание формата пути см. в следующем разделе.

[TIP]
====
Для проверки разрешений вместо непосредственного использования методов класса `UserSession` рекомендуется использовать аналогичные методы интерфейса <<security,Security>>, принимающие во внимание возможное <<entity_extension,расширение>> сущностей.
====

[[roles]]
==== Роли

Роль объединяет набор <<permissions,разрешений>>, которые могут быть предоставлены пользователю.

Пользователь может иметь несколько ролей. При этом он получает логическую сумму (ИЛИ) прав на некоторый объект от всех ролей, которые у него есть. Например, если пользователю назначены роли A, B и C, роль A запрещает X, роль B разрешает X, роль C не устанавливает явных разрешений на X, то в итоге X будет разрешен.

Если ни одна роль пользователя не определяет явно разрешения на объект, то пользователь имеет право на данный объект. Таким образом, пользователь имеет права на все объекты, на которые либо ни одна роль явно не определяет разрешения, либо хотя бы одна роль определяет, что право есть.

[WARNING]
====
Если пользователю дать единственную роль без явно установленных разрешений, или не давать никаких ролей вообще, то у него будут все права на все объекты. 
====

Список ролей отображается экраном *Administration* → *Roles*. Здесь помимо стандартных действий создания, изменения и удаления записей имеется кнопка *Assign to users*, позволяющая назначить выбранную роль сразу нескольким пользователям.

Рассмотрим экран редактирования роли. В верхней его части отображаются атрибуты роли: 

image::role_attributes.png[align="center"]

* *Name* - обязательное уникальное имя (или код) роли. Не может быть изменено после создания.

* *Localized name* - понятное пользователю название роли.

* *Description* - произвольное описание роли.

* *Type* - тип роли, может быть следующим:

** *Standard* - в роли данного типа действуют только явно назначенные разрешения.

** *Super* - роль данного типа автоматически дает все разрешения. Это удобно для назначения администраторов системы, так как она отменяет все запрещения, установленные другими ролями. 

** *Read-only* - роль данного типа автоматически отнимает разрешения на следующие операции с сущностями: CREATE, UPDATE, DELETE. Таким образом, пользователь с такой ролью может только читать данные, и не может их изменять (если какая-либо другая роль этого пользователя не разрешает явно эти операции).

**  *Denying* - запрещающая роль. Роль данного типа автоматически отнимает разрешения на все объекты, кроме атрибутов сущностей. Чтобы пользователь с данной ролью мог что-то увидеть или изменить в системе, ему нужно назначить дополнительно другую роль, явно дающую нужные права. 
+
Роли всех типов могут иметь явно установленные разрешения, например в *Read-only* роль можно добавить разрешения на модификацию некоторых сущностей. Однако для роли *Super* явная установка каких-либо запрещений не имеет смысла, так как наличие роли данного типа в любом случае отменяет все запрещения.

* *Default role* - признак роли по умолчанию. Все роли с данным признаком автоматически назначаются вновь создаваемым пользователям.

Ниже представлены вкладки управления разрешениями:

* Вкладка *Screens* - разрешения на экраны системы:
+
image::role_screen_permissions.png[align="center"]
+
Дерево в левой части вкладки отражает структуру главного меню системы. Последним элементом дерева является *Other screens*, внутри которого сосредоточены экраны, не включенные в главное меню (например, экраны редактирования сущностей).

* Вкладка *Entities* - разрешения на операции с сущностями:
+
image::role_entity_permissions.png[align="center"]
+
При переходе на данную вкладку изначально включен флажок *Assigned only*, поэтому в таблице отображаются только сущности, для которых в данной роли уже есть явные разрешения. Поэтому для новой роли таблица пуста. Для установки разрешений снимите флажок *Assigned only* и нажмите *Apply*. Список сущностей можно фильтровать, вводя в поле *Entity* любую часть имени сущности и нажимая *Apply*.
+
Установив флажок *System level*, можно выбрать системную сущность, помеченную аннотацией `@SystemLevel`. По умолчанию такие сущности не показываются в таблице.
+
При нарушении ограничений на операции с сущностями пользователю будет показано сообщение об ошибке. Для <<localization,локализации>> таких сообщений нужно переопределить ключи для обработчика <<dialogs_showExceptionDialog,RowLevelSecurityExceptionHandler>> в <<main_message_pack,главном пакете сообщений>>.

* Вкладка *Attributes* - разрешения на атрибуты сущностей:
+
image::role_attr_permissions.png[align="center"]
+
В таблице сущностей в колонке *Permissions* отображается список атрибутов, для которых явно указаны разрешения. Зеленым цветом обозначено разрешение *modify* (полный доступ), синим цветом - *read-only* (только чтение), красным - *hide* (атрибут скрыт).
+
Управление списком сущностей аналогично описанному для вкладки *Entities*.

* Вкладка *Specific* - разрешения на именованную функциональность:
+
image::role_specific_permissions.png[align="center"]
+
Имена объектов, на которые могут быть назначены специфические разрешения, определяются в конфигурационном файле <<permissions.xml,permissions.xml>> проекта.

* Вкладка *UI* - разрешения на UI-компоненты экранов:
+
image::role_ui_permissions.png[align="center"]
+
Разрешения данного типа дают возможность ограничить доступ к любому компоненту экрана, в том числе не связанному с данными (например, к контейнеру). Для создания таких разрешений необходимо знать идентификаторы компонентов, а значит, иметь доступ к исходному коду экранов.
+
Для создания ограничения выберите нужный экран в выпадающем списке *Screen*, задайте путь к компоненту в поле *Component*, и нажмите *Add*. После этого установите режим доступа к выбранному компоненту в панели *Permissions*.
+
Правила формирования пути к компоненту:

** Если компонент принадлежит экрану, указывается просто идентификатор компонента `id`.

** Если компонент принадлежит фрейму, вложенному в экран, то сначала указывается идентификатор фрейма, а затем через точку идентификатор компонента внутри фрейма.

** Если необходимо установить разрешение для вкладки <<gui_TabSheet,TabSheet>> или поля <<gui_FieldGroup,FieldGroup>>, то сначала указывается идентификатор компонента, а затем в квадратных скобках идентификатор соответственно вкладки или поля.

** Чтобы установить разрешение на <<gui_Action,действие>>, необходимо указать идентификатор компонента, содержащего действие, а затем идентификатор действия в угловых скобках. Например: `customersTable<changeGrade>`.

[[groups]]
==== Группы доступа

Группы доступа позволяют организовывать пользователей в иерархическую структуру для установки <<constraints,ограничений>> и для присвоения произвольных <<session_attr,атрибутов сессии>>.

Пользователь может быть причислен только к одной группе, однако он получит список ограничений и атрибутов сессии от всех групп вверх по иерархии.

Управление группами доступа осуществляется в экране *Administration* → *Access Groups*:

image::group_users.png[align="center"]

[[constraints]]
===== Ограничения

Ограничения (Constraints) можно наложить на различные действия с экземплярами сущностей. В отличие от разрешений, которые накладываются на _класс_ сущностей, ограничения накладываются на _конкретные экземпляры_, не соответствующие заданным условиям. Ограничения можно накладывать на чтение, создание, модификацию и удаление сущностей. Кроме того, можно задать специальные ограничения, не привязанные к этим четырем действиям.

[TIP]
====
Пользователь получает список ограничений от всех групп начиная со своей и вверх по иерархии. Тем самым реализуется принцип: чем ниже пользователь в иерархии групп, тем больше у него ограничений.
====

Следует отметить, что все ограничения проверяются при операциях с данными, осуществляемых клиентом через стандартный <<dataManager,DataManager>>. В случае несоответствия проверяемой сущности условиям ограничений при создании, модификации или удалении, выбрасывается исключение `RowLevelSecurityException`.

Существует несколько типов проверки ограничений: проверка в базе данных, проверка в памяти, проверка в базе данных и памяти.

. Для ограничений с проверкой в базе данных условия задаются с помощью фрагментов выражений на языке <<jpql,JPQL>>. Эти фрагменты подставляются в каждый запрос, выбирающий экземпляры данной сущности. Таким образом, сущности, не соответствующие условиям ограничения, отфильтровываются на уровне базы данных. Ограничение с проверкой в базе данных можно задать только на чтение сущностей.

. Для ограничений с проверкой в памяти условия задаются с помощью выражений на языке Groovy. Эти выражения выполняются для каждой сущности проверяемого графа объектов, и если какая-либо сущность не соответствует условиям - она отфильтровывается из графа объектов.

. Ограничения с проверкой в базе данных и памяти являются комбинацией первых двух вариантов.

Для создания ограничения в экране *Access Groups* выберите группу, на которую нужно наложить ограничение, перейдите на вкладку *Constraints* и нажмите *Create*:

image::constraint_edit.png[align="center"]

Далее выберите сущность в выпадающем списке *Entity Name*, тип операции в выпадающем списке *Operation Type*, и тип проверки в выпадающем списке *Check Type*. В зависимости от выбранного тип проверки вам нужно будет задать JPQL условия в полях *Join Clause* и *Where Clause* и/или Groovy условие в поле *Groovy Script*. Кроме того вы можете воспользоваться мастером созданий ограничений доступа (*Constraint Wizard*). Мастер позволяет визуально задавать Groovy и JPQL условия.
Если вы выбрали тип операции "Специальные операции", появляется обязательное поле *Код*, где нужно указать строку, по которой будет идентифицироваться данное ограничение.  

[TIP]
====
Редактор JPQL в полях *Join Clause* и *Where Clause* поддерживает автодополнение имен сущностей и их атрибутов. Для вызова автодополнения нажмите *Ctrl+Space*. Если вызов произведен после точки, будет выведен список атрибутов сущности, соответствующей контексту, иначе - список всех сущностей модели данных.
====

Правила формирования ограничения:

* В качестве алиаса извлекаемой сущности необходимо использовать строку `{E}`. При выполнении запросов она будет заменена на реальный алиас, заданный в запросе.

* В параметрах JPQL можно использовать следующие предопределенные константы:

** `session$userLogin` − имя учетной записи текущего пользователя (в случае <<user_substitution,замещения>> − имя учетной записи замещаемого пользователя).

** `session$userId` − ID текущего пользователя (в случае замещения − ID замещаемого пользователя).

** `session$userGroupId` − ID группы текущего пользователя (в случае замещения − ID группы замещаемого пользователя).

** `session$XYZ` − произвольный атрибут текущей <<userSession,пользовательской сессии>>, где XYZ − имя атрибута.

* Содержимое поля *Where Clause* добавляется в выражение `where` запроса по условию `and` (И). Само слово `where` писать не нужно, оно будет добавлено автоматически, даже если исходный запрос его не содержал.

* Содержимое поля *Join Clause* добавляется в выражение `from` запроса. Оно должно начинаться с запятой или слов `join` или `left join`.

Простейший пример ограничения приведен на рисунке выше: пользователи с данным ограничением будут видеть только те экземпляры сущности `ref$Car`, у которых поле VIN начинается с '00'.

Ещё один классический пример: некая сущность связана с сущностью `User` в отношении many-to-many, и необходимо, чтобы пользователю были доступны только те экземпляры сущности, в которых есть ссылка непосредственно на него. В этом случае можно использовать оператор `member of` в поле *Where Clause*:

[source, java]
----
(select u from sec$User u where u.id = :session$userId) member of {E}.users
----

Для ограничений с проверкой в памяти в Groovy скрипт передается переменная `userSession` типа `UserSession`. Ее можно использовать для получения атрибутов текущей пользовательской сессии, например:

[source, java]
----
include::{sourcesdir}/security/constraints_2.groovy[]
----

Разработчик может проверить условия ограничений для конкретной сущности с помощью методов интерфейса `Security`:

* `isPermitted(Entity, ConstraintOperationType)` - для проверки ограничений по типу операции.

* `isPermitted(Entity, String)` - для проверки ограничений по коду.

Кроме того, существует возможность связать любое действие, унаследованное от класса `ItemTrackingAction`, c проверкой ограничений. Для этого в XML-элементе `action` следует задать атрибут `constraintOperationType`, либо использовать метод `setConstraintOperationType()` в контроллере экрана.

Пример:
[source, xml]
----
include::{sourcesdir}/security/constraints_1.xml[]
----

[TIP]
====
При нарушении ограничения пользователю показывается <<notifications,уведомление>>. Заголовок и текст уведомления для каждого ограничения можно переопределить прямо в приложении. Для этого необходимо выбрать ограничение на вкладке *Constraints* экрана *Access Groups*, нажать на кнопку *Localization* и в появившемся окне задать свой заголовок и текст сообщения.
====

[[session_attr]]
===== Атрибуты сессии

Группа доступа может определять список атрибутов <<userSession,сессии>> для пользователей, входящих в данную группу. Эти атрибуты можно использовать при настройке <<constraints,ограничений>>. Кроме того, на этапе разработки в прикладной код системы можно заложить анализ наличия некоторых атрибутов сессии, и тем самым управлять поведением готовой системы для конкретных групп пользователей на этапе эксплуатации. 

В пользовательскую сессию при входе в систему будут помещены все атрибуты, заданные для группы, в которой находится пользователь, и для всех родительских групп вверх по иерархии. При этом если атрибут встречается в иерархии групп несколько раз, значение он получит от самой верхней группы, то есть переопределение значений атрибутов на нижнем уровне невозможно. При попытке переопределения в <<logging_setup_tomcat,журнал>> сервера будет выведено сообщение с уровнем `WARN`. 

Для создания атрибута в экране *Access Groups* выберите группу, перейдите на вкладку *Session Attributes* и нажмите *Create*:

image::session_attr_edit.png[align="center"]

В данном экране необходимо задать уникальное имя атрибута, тип данных и значение.

Получить атрибут <<userSession,сессии>> в коде приложения можно следующим способом:

[source, java]
----
@Inject
private UserSessionSource userSessionSource;
...
Integer accessLevel = userSessionSource.getUserSession().getAttribute("accessLevel");
----

Использовать атрибут в <<constraints,ограничениях>> можно, указав его в параметре JPQL с префиксом `session$`:

[source, java]
----
{E}.accessLevel = :session$accessLevel
----

[[security_examples]]
=== Примеры управления доступом

В данном разделе приведены практические рекомендации по настройке доступа пользователей к данным.

[[roles_example]]
==== Настройка ролей

Рекомендованный способ настройки <<roles,ролей>> и <<permissions,разрешений>>:

. Создать роль `*Default*`, отбирающую все права в системе. Проще всего это сделать, установив тип роли *Denying*. Включить флажок *Default role*, чтобы эта роль автоматически назначалась всем новым пользователям.

. Создать набор ролей, дающих нужные права различным категориям пользователей. Можно предложить две стратегии создания таких ролей:

* Крупнозернистые (coarse-grained) роли - каждая роль содержит набор разрешений для всего круга обязанностей пользователя в системе. Например `*Sales Manager*`, `*Accountant*`. В этом случае пользователям в дополнение к запрещающей `*Default*` роли необходимо назначить как правило только одну разрешающую роль.

* Мелкозернистые (fine-grained) роли - каждая роль содержит небольшой набор разрешений для выполнения пользователем некоторой функции в системе. Например `*Task Creator*`, `*References Editor*`. В этом случае пользователям в дополнение к запрещающей `*Default*` роли необходимо назначить несколько разрешающих ролей в соответствии с кругом их обязанностей.
+
Разумеется, ничто не мешает совмещать обе стратегии.

. Администратору системы можно просто не назначать никаких ролей вообще, тогда у него будут все права на все объекты системы. Пользователя с запрещающими ролями можно сделать администратором, добавив ему роль типа *Super*.

[[local_admins_example]]
==== Создание локальных администраторов

Иерархическая структура <<groups,групп доступа>> с наследованием <<constraints,ограничений>> позволяет создавать _локальных администраторов_ и делегировать им создание пользователей и настройку их прав в рамках подразделений организации. 

Локальному администратору доступны экраны подсистемы безопасности, однако он видит только пользователей и группы в своей группе доступа и ниже. Он может создавать подгруппы и пользователей и назначать им имеющиеся в системе <<roles,роли>>. При этом все создаваемые им пользователи будут иметь как минимум те же ограничения, что и он сам.

Глобальный администратор, находящийся в корневой группе доступа, лишенной ограничений, должен создать роли, которые будут доступны локальным администраторам для назначения пользователям. Сами локальные администраторы не должны иметь прав на создание и изменение ролей.

Рассмотрим следующую структуру групп доступа:

image::local_admins_groups.png[align="center"]

Задача:

* Пользователи внутри группы `*Departments*` должны видеть только пользователей своей группы и ниже.

* В каждой из групп `*Dept 1*`, `*Dept 2*`, и т.д. должен быть свой локальный администратор, который может создавать пользователей и назначать им имеющиеся роли.

Способ решения задачи:

* Задать для группы `*Departments*` следующие ограничения:
+
image::local_admins_constraints.png[align="center"]

** Для сущности `sec$Group`:
+
[source, jpql]
----
{E}.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
Это ограничение не позволяет пользователям видеть группы выше своей собственной.

** Для сущности `sec$User`:
+
[source, jpql]
----
{E}.group.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
Это ограничение не позволяет пользователям видеть других пользователей, входящих в группы выше своей собственной.

** Для сущности `sec$Role`:
+
[source, jpql]
----
({E}.description is null or {E}.description not like '[hide]')
----
+
Данное ограничение не позволяет пользователям видеть роли, в атрибуте `description` которых записана строка `*[hide]*`.

* Создать роль, которая запретит редактирование ролей и разрешений:
+
image::local_admins_role.png[align="center"]

** Установите флажок *Default role*.

** В поле *Description* добавьте строку `*[hide]*`.

** На вкладке *Entities* запретите операции *create*, *update*, *delete* для сущностей `sec$Role` и `sec$Permission` (для добавления разрешений на объект `sec$Permission` установите флажок *System level*).
+
Все создаваемые пользователи, включая локальных администраторов, будут получать роль `*local_user*`. Эта роль невидима для пользователей группы `*Departments*`, поэтому даже локальные администраторы не смогут ее с себя снять. В результате они смогут оперировать только существующими ролями, созданными для них глобальным администратором. Разумеется, эти роли не должны отменять запрещений, введенных ролью `*local_user*`.

[[ldap]]
=== Интеграция с LDAP

Интеграция CUBA-приложения c LDAP позволяет решить две задачи:

. Хранить пароли пользователей и управлять ими централизованно в базе данных LDAP.

. Для пользователей компьютеров, входящих в домен Windows, выполнять логин в приложение без ввода имени и пароля (то есть организовывать Single Sign-On).

В режиме интеграции с LDAP пользователи по-прежнему должны иметь учетную запись в приложении. Все разрешения и параметры пользователя (кроме пароля) хранятся в БД приложения, LDAP используется только для аутентификации, т.е. проверки имени и пароля. Пароль в приложении для большинства пользователей, за исключением тех, кому требуется стандартная аутентификация (см. ниже), рекомендуется не задавать вообще. Поле пароля в экране редактирования пользователя не является обязательным к заполнению если свойство <<cuba.web.externalAuthentication,cuba.web.externalAuthentication>> установлено в `true`.

Если логин пользователя перечислен в свойстве приложения <<cuba.web.standardAuthenticationUsers,cuba.web.standardAuthenticationUsers>>, то он всегда аутентифицируется обычным способом через хранимый в базе данных приложения хэш пароля. Поэтому если для некоторого пользователя из данного списка пароль в приложении задан, он сможет войти в систему с этим паролем, если в LDAP такого пользователя нет.

Взаимодействие CUBA-приложения с LDAP осуществляется через бин `LdapLoginProvider`.

Для расширенной интеграции с Active Directory и обеспечения Single Sign-On для пользователей домена Windows можно использовать библиотеку *Jespa* и соответствующую имплементацию `CubaAuthProvider`, которая описана в <<jespa,>>.

Вы можете реализовать свой механизм входа при помощи интерфейсов `LoginProvider`, `HttpRequestFilter` и обработчиков событий, как это описано в разделе <<web_login, Специфика процесса входа в Web Client>>.

Также вы можете включить LDAP аутентификацию для клиентов REST API: <<rest_api_v2_ldap,LDAP аутентификация для REST API>>.

[[ldap_basic]]
==== Базовая интеграция с LDAP

Класс `LdapAuthProvider` используется по умолчанию при включенном свойстве приложения <<cuba.web.ldap.enabled,cuba
.web.ldap.enabled>>. В этом случае для аутентификации пользователей используется библиотека *Spring LDAP*.

Для настройки интеграции используются следующие свойства приложения блока Web Client:

* <<cuba.web.ldap.enabled,cuba.web.ldap.enabled>>.

* <<cuba.web.ldap.urls,cuba.web.ldap.urls>>.

* <<cuba.web.ldap.base,cuba.web.ldap.base>>.

* <<cuba.web.ldap.user,cuba.web.ldap.user>>.

* <<cuba.web.ldap.password,cuba.web.ldap.password>>.

* <<cuba.web.ldap.userLoginField,cuba.web.ldap.userLoginField>>.

Пример содержимого файла <<app_properties_files,local.app.properties>> блока Web Client:

[source, properties]
----
cuba.web.ldap.enabled = true
cuba.web.ldap.urls = ldap://192.168.1.1:389
cuba.web.ldap.base = ou=Employees,dc=mycompany,dc=com
cuba.web.ldap.user = cn=System User,ou=Employees,dc=mycompany,dc=com
cuba.web.ldap.password = system_user_password
----

См. также <<cuba.web.requirePasswordForNewUsers, cuba.web.requirePasswordForNewUsers>>.

В случае интеграции с Active Directory, при создании пользователей в приложении указывайте в качестве логина их `sAMAccountName` без имени домена.

[[jespa]]
==== Интеграция с Active Directory с использованием Jespa

*Jespa* − библиотека для *Java*, обеспечивающая расширенную интеграцию между службой каталогов *Active Directory* и Java-приложениями по протоколу link:$$https://en.wikipedia.org/wiki/NTLMv2#NTLMv2$$[NTLMv2]. Подробно о библиотеке см. link:$$http://www.ioplex.com$$[http://www.ioplex.com].

[[jespa_lib]]
===== Подключение библиотеки

Загрузите библиотеку с сайта link:$$http://www.ioplex.com$$[http://www.ioplex.com] и разместите JAR в каком-либо <<artifact_repository,репозитории>>, зарегистрированном в вашем скрипте сборки <<build.gradle,build.gradle>>. Это может быть `mavenLocal()` или репозиторий вашей организации.

В файле `build.gradle` в секции конфигурации модуля *web* добавьте зависимости:

[source, java]
----
include::{sourcesdir}/security/ldap_jespa_2.groovy[]
----

Создайте в модуле *web* класс реализации интерфейса `CubaAuthProvider`:

[source, java]
----
include::{sourcesdir}/security/ldap_jespa_1.java[]
----

[[jespa_conf]]
===== Настройка конфигурации

* Выполнить настройки, описанные в разделе *Installation* → *Step 1: Create the Computer Account for NETLOGON Communication* руководства *Jespa Operator's Manual*, которое можно загрузить по адресу link:$$http://www.ioplex.com/support.html$$[http://www.ioplex.com/support.html].

* Задать параметры доменов в <<app_properties_files,local.app.properties>> в свойстве приложения `cuba.web.activeDirectoryDomains`. Каждый описатель домена имеет формат `++domain_name|full_domain_name|service_account_name|service_account_password++`. Описатели доменов отделяются друг от друга точкой с запятой.
+
Например:
+
[source, properties]
----
cuba.web.activeDirectoryDomains = MYCOMPANY|mycompany.com|JESPA$@MYCOMPANY.COM|password1;TEST|test.com|JESPA$@TEST.COM|password2
----

* Разрешить интеграцию с Active Directory, установив в `local.app.properties` свойство приложения `cuba.web.externalAuthentication`:
+
[source, properties]
----
cuba.web.externalAuthentication = true
----

* Задать в `local.app.properties` свойство `cuba.web.externalAuthenticationProviderClass`, указав полное имя класса `JespaAuthProvider`:
+
[source, properties]
----
cuba.web.externalAuthenticationProviderClass = com.company.sample.web.JespaAuthProvider
----

* Задать в `local.app.properties` дополнительные свойства для библиотеки (см. *Jespa Operator's Manual*). Например:
+
[source, properties]
----
jespa.log.level=3
----
+
Если приложение развернуто на Tomcat, лог-файл Jespa находится в `tomcat/logs`.

* Добавить адрес сервера в местную интрасеть в настройках браузера:

** Для *Internet Explorer* и *Chrome*: *Свойства обозревателя* > *Безопасность* > *Местная интрасеть* > *Узлы* > *Дополнительно*.

** Для *Firefox*: `about:config` > `network.automatic-ntlm-auth.trusted-uris=http://myapp.mycompany.com`.

[[sso]]
=== Single-Sign-On для приложений CUBA

Single-Sign-On (единый вход, SSO) для приложений CUBA позволяет пользователям входить в несколько запущенных приложений введя единые имя и пароль один раз в течение сессии веб-браузера.

При использовании SSO существуют два типа приложений:

* Identity Provider (IDP) - приложение, обеспечивающее аутентификацию пользователей. Оно содержит форму для ввода логина/пароля и выполняет их проверку в соответствии со списком зарегистрированных пользователей. Identity Provider в некоторой SSO-системе может быть только один.

* Service Provider (SP) - обычное приложение, которое перенаправляет к IDP для аутентификации пользователей. SP должен содержать тот же список пользователей, что и IDP (пароли при этом не важны, так как они проверяются на IDP). SP обеспечивает проверку прав пользователей в соответствии с их ролями и группами доступа. Количество SP в SSO-системе не ограничено.

Приложение может одновременно выполнять функции IDP и SP, то есть установка отдельного IDP не требуется. Функциональность SSO предоставляется модулем *cuba-idp*, входящим в состав <<app_tiers,блока>> Web Client. Приложение можно разрабатывать как обычно, а SSO настроить уже на этапе деплоймента, если требуется.

[WARNING]
====
CUBA SSO использует собственный протокол, основанный на HTTP, и на данный момент не поддерживает интеграции с системами, использующими стандартные протоколы аутентификации, такие как SAML или OIDC.
====

При использовании SSO, когда пользователь заходит на адрес SP, он перенаправляется на страницу IDP для ввода имени и пароля. После успешной аутентификации, IDP перенаправляет пользователя обратно в приложение SP, где пользователь входит автоматически.

Для настройки SSO необходимо выполнить следующее:

* На Identity Provider:

** Добавьте следующую конфигурацию в файл `web.xml` модуля *web* (если вы выполняете настройку на этапе деплоймента, данный файл находится здесь: `tomcat/webapps/app/WEB-INF/web.xml`):
+
[source, xml]
----
include::{sourcesdir}/security/sso_1.xml[]
----

** Установите свойства приложения:

*** <<cuba.idp.serviceProviderUrls,cuba.idp.serviceProviderUrls>> - разделенный запятой список URL приложений SP (символ `/` в конце URL обязателен). Например:
+
[source]
----
cuba.idp.serviceProviderUrls = http://foo:8081/app/,http://bar:8082/app/
----

*** <<cuba.idp.serviceProviderLogoutUrls,cuba.idp.serviceProviderLogoutUrls>> - разделенный запятой список URL, которые используются для уведомления SP о логауте или истечении сессии пользователей. Стандартные приложения CUBA принимают такие запросы на адресе `/dispatch/idpc/logout`. Например:
+
[source]
----
cuba.idp.serviceProviderLogoutUrls = http://foo:8081/app/dispatch/idpc/logout,http://bar:8082/app/dispatch/idpc/logout
----

*** <<cuba.idp.trustedServicePassword,cuba.idp.trustedServicePassword>> - пароль, используемый в коммуникации server-to-server между SP и IDP.

*** Опциональные свойства: <<cuba.idp.sessionExpirationTimeoutSec,cuba.idp.sessionExpirationTimeoutSec>>, <<cuba.idp.ticketExpirationTimeoutSec,cuba.idp.ticketExpirationTimeoutSec>>, <<cuba.idp.sessionExpirationCheckIntervalMs,cuba.idp.sessionExpirationCheckIntervalMs>>, <<cuba.idp.cookieMaxAgeSec,cuba.idp.cookieMaxAgeSec>>, <<cuba.idp.cookieHttpOnly,cuba.idp.cookieHttpOnly>>.

* На Service Providers:

** Установите свойства приложения:

*** <<cuba.webAppUrl,cuba.webAppUrl>> - URL приложения (символ `/` в конце обязателен). Данный URL должен быть в списке URL, определенном свойством IDP <<cuba.idp.serviceProviderUrls,cuba.idp.serviceProviderUrls>>. Например:
+
[source]
----
cuba.webAppUrl = http://foo:8081/app/
----

*** <<cuba.web.idp.enabled,cuba.web.idp.enabled>> должно быть установлено в `true`.

*** <<cuba.web.idp.baseUrl,cuba.web.idp.baseUrl>> - на данном URL IDP принимает запросы на аутентификацию. Стандартный CUBA IDP использует адрес `idp/` (символ `/` в конце обязателен). Например:
+
[source]
----
cuba.web.idp.baseUrl = http://main:8080/app/idp/
----

*** <<cuba.web.idp.trustedServicePassword,cuba.web.idp.trustedServicePassword>> - должен быть таким же как заданный для IDP в свойстве <<cuba.idp.trustedServicePassword,cuba.idp.trustedServicePassword>>.

[[sso_customization]]
==== Кастомизация IDP

Форма логина IDP::
+
--
Файлы формы логина располагаются в каталоге `idp` веб-приложения. В случае деплоймента в Tomcat это каталог `tomcat/webapps/app/idp`. Стандартные файлы можно заменить, создав файлы с такими же именами в каталоге `web/idp` модуля *web* проекта.

По умолчанию форма логина IDP использует механизм локализации на основе JavaScript-библиотеки https://github.com/fabi1cazenave/webL10n[webL10n], и содержит сообщения для английской и русской локали. Чтобы создать сообщения на других языках, создайте файл `modules/web/web/idp/l10n/locales.ini` и задайте в нем список файлов сообщений:

[source]
----
[*]
@import url(messages.properties)

[ru]
@import url(messages_ru.properties)

[es]
@import url(messages_es.properties)
----

Дополнительные файлы сообщений должны располагаться в этом же каталоге(`modules/web/web/idp/l10n`). В качестве шаблона для файлов сообщений используйте файлы из модуля *cuba-idp*, который доступен в виде JAR-зависимости в вашем проекте.

Можно также полностью заменить форму логина путем создания собственных файлов `login.html` и `js/login.js`, либо изменить стили в файле `css/login.css`.
--

Реализация IDP::
+
--
Точки входа в IDP находятся в контроллерах Spring MVC `cuba_IdpController` и `cuba_IdpServiceController`. Для реализации собственного поведения можно создать свои контроллеры и зарегистрировать их под этими же именами в файле `idp-dispatcher-spring.xml` модуля *web*.

Стандартная реализация хранит сессии IDP на среднем слое и реплицирует их в кластере. Эта функциональность обеспечивается бином `cuba_IdpSessionStore`. Механизм хранения сессий может быть кастомизирован путем создания бина с таким же именем в модуле *core* проекта и регистрации его в соответствующем файле `spring.xml`. Подробнее см. <<bean_extension,>>.
--

[[sso_example]]
==== Пример настройки SSO

В данном разделе рассмотрен пример настройки <<sso,SSO>> для двух приложений: Foo и Bar. Foo будет одновременно выполнять роль Identity Provider и Service Provider, Bar будет являться Service Provider.

. Оба приложения будут запущены на localhost, поэтому создайте алиасы в файле `hosts`:
+
[source]
----
127.0.0.1    foo
127.0.0.1    bar
----

. Создайте поочередно два проекта в Studio и назначьте разные порты Tomcat.
+
|===
| Проект | HTTP port | AJP port | Shutdown port

| Foo
| 8081
| 8011
| 8051

| Bar
| 8082
| 8012
| 8052
|===

. В проекте Foo отредактируйте файл `modules/web/web/WEB-INF/web.xml` добавив следующую конфигурацию IDP:
+
[source,xml]
----
include::{sourcesdir}/security/sso_1.xml[]
----

. В проекте Foo отредактируйте файл `web-app.properties` модуля *web*, добавив следующие свойства:
+
[source,properties]
----
include::{sourcesdir}/security/sso_2.properties[]
----

. В проекте Bar отредактируйте файл `web-app.properties` модуля *web*, добавив следующие свойства:
+
[source,properties]
----
include::{sourcesdir}/security/sso_3.properties[]
----

. Запустите сервер Foo с помощью скрипта `tomcat/bin/startup.*`.

. Перейдите по адресу `++http://foo:8081/app++` в веб-браузере. Вы будете перенаправлены на страницу логина IDP. Войдите с именем и паролем `admin` / `admin`. Создайте нового пользователя, например `u1`.

. Запустите сервер Bar с помощью скрипта `tomcat/bin/startup.*`.

. Перейдите по адресу `++http://bar:8082/app++` в том же веб-браузере. Если вы по-прежнему аутентифицированы в приложении Foo, то вы автоматически войдете как `admin` и в приложение Bar. Создайте пользователя `u1` (пароль не важен) в приложении Bar.

. Теперь вы сможете входить как `admin` или `u1` в оба приложения через единую форму логина, и если вы аутентифицированы в одном приложении, то вход во второе будет автоматическим, минуя форму.

[[social_login]]
=== Social Login

Вход через социальные сети, или social login, это разновидность <<sso,single sign-on>>, которая позволяет использовать данные для входа в социальные сети, такие как Facebook, Twitter или Google+, для входа в приложения CUBA вместо того, чтобы создавать пользователя в приложении напрямую.

В этом примере мы рассмотрим, как можно войти в приложение, используя аккаунт на Facebook. В Facebook используется механизм авторизации OAuth2, более подробно о его использовании вы можете узнать из документации по Facebook API и Facebook Login Flow: https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow.

Исходный код проекта из этого примера доступен на https://github.com/cuba-platform/sample-social-login[GitHub], ниже приведены ключевые моменты реализации social login.

. Чтобы подключить приложение к Facebook, необходимо создать для него *App ID* (уникальный идентификатор приложения) и *App Secret* (своего рода пароль для аутентификации запросов, поступающих от приложения на серверы Facebook). Следуя https://developers.facebook.com/docs/apps/register[инструкции], создайте эти значения и затем зарегистрируйте их в файле `app.properties` в модуле *core* в свойствах приложения `facebook.appId` и `facebook.appSecret` соответственно, например:
+
--
[source, properties]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/core/src/com/company/demo/app.properties[app.properties]
----
facebook.appId = 123456789101112
facebook.appSecret = 123456789101112abcde131415fghi16
----

Также необходимо зарегистрировать URL, который вы указали при регистрации приложения на Facebook, в свойстве приложения <<cuba.webAppUrl,cuba.webAppUrl>> в модулях *core* и *web*, к примеру:

[source, properties]
----
cuba.webAppUrl = http://cuba-fb.test:8080/app
----
--

. Расширьте https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/web/login/ext-loginWindow.xml[окно входа в систему] и добавьте кнопку для входа через социальную сеть. По нажатию этой кнопки будет вызываться метод `loginFacebook()` - наша точка входа в процедуру social login.

. Чтобы использовать учётные записи пользователей Facebook в своём приложении, необходимо добавить новое поле к стандартной учётной записи пользователя CUBA. Расширьте сущность `User` и добавьте строковый атрибут `facebookId`:
+
[source, java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/global/src/com/company/demo/entity/SocialUser.java[SocialUser.java]
----
@Column(name = "FACEBOOK_ID")
protected String facebookId;
----

. Создайте сервис, который будет искать пользователя приложения в базе данных по переданному `facebookId`, и если таковой не найден, то создавать его на лету:
+
[source, java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/global/src/com/company/demo/service/SocialRegistrationService.java[SocialRegistrationService.java]
----
include::{sourcesdir}/security/security_SocialRegistrationService.java[]
----
+
[source, java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/core/src/com/company/demo/service/SocialRegistrationServiceBean.java[SocialRegistrationServiceBean.java]
----
include::{sourcesdir}/security/security_SocialRegistrationServiceBean.java[]
----

. Создайте сервис для реализации логики входа. В данном примере это сервис https://github.com/cuba-platform/sample-social-login/blob/master/modules/global/src/com/company/demo/service/FacebookService.java[FacebookService], содержащий два метода: `getLoginUrl()` и `getUserData()`.
+
--
* `getLoginUrl()` генерирует URL для входа на основании URL приложения и типа ответа OAuth2 (code, access token или оба; более подробно о параметре `response_type` см. в документации https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow[Facebook API]). Исходный код этого метода можно посмотреть в файле https://github.com/cuba-platform/sample-social-login/blob/master/modules/core/src/com/company/demo/service/FacebookServiceBean.java[FacebookServiceBean.java].

* `getUserData()` будет искать пользователя Facebook по параметрам, переданным в URL и в коде, и вернёт данные существующего пользователя или создаст нового. В этом примере из пользовательских данных нам нужны id, name и email, id будет соответствовать атрибуту `facebookId`, который мы создали ранее.
--

. Определите свойства приложения `facebook.fields` и `facebook.scope` в файле `app.properties` модуля *core*:
+
[source, properties]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/core/src/com/company/demo/app.properties[app.properties]
----
facebook.fields = id,name,email
facebook.scope = email
----

. Вернёмся к методу `loginFacebook()` в контроллере расширенного окна входа. Код контроллера целиком вы можете найти в файле https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/web/login/ExtAppLoginWindow.java[ExtAppLoginWindow.java].
+
--
В этом методе мы добавим к текущей сессии обработчик запроса, затем сохраним текущий URL и перенаправим пользователя на экран авторизации Facebook в браузере:

[source,java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/web/login/ExtAppLoginWindow.java[ExtAppLoginWindow.java]
----
include::{sourcesdir}/security/security_loginFacebook.java[]
----

В методе `handleFacebookCallBackRequest()` будет обработан обратный вызов после формы авторизации Facebook. Во-первых, используем экземпляр `UIAccessor`, чтобы зафиксировать состояние UI, пока будет обрабатываться запрос на вход.

Затем с помощью `FacebookService` получим email и id учётной записи Facebook. После этого найдём соответствующего пользователя CUBA по его `facebookId` или создадим нового на лету.

Далее будет совершен вход в приложение, будет создана новая сессия от лица этого пользователя и обновлен UI. Теперь мы можем удалить обработчик обратного вызова Facebook, так как процедура аутентификации закончена.

[source,java]
.https://github.com/cuba-platform/sample-social-login/blob/master/modules/web/src/com/company/demo/web/login/ExtAppLoginWindow.java[ExtAppLoginWindow.java]
----
include::{sourcesdir}/security/security_handleFacebookCallBackRequest.java[]
----
--

Теперь при нажатии кнопки *Facebook* на экране входа приложение запросит разрешение на использование учётных данных пользователя Facebook, и если разрешение будет получено, пользователь после логина будет перенаправлен на главную страницу приложения.

Вы можете реализовать свой механизм входа при помощи интерфейсов `LoginProvider`, `HttpRequestFilter` и обработчиков событий, как это описано в разделе <<web_login>>.
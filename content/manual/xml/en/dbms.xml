<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section id="dbms">
  <title>Database Components</title>
  <para>This section provides information on all possible types of DBMS supported by CUBA platform. Furthermore, a script-based mechanism, which allows creating a new database and keeping it up-to-date throughout the entire cycle of the development and operation of the application, is described. </para>
  <para>Database components belong to the Middleware <link linkend="app_tiers">block</link>; other blocks of the application do not have direct access to the database. </para>
  <para>Some additional information on working with the database is provided in  <xref linkend="db_dev"/> and <xref linkend="db_update_in_prod"/>.</para>
  <section id="dbms_types">
    <title>DBMS Types</title>
    <para>The type of the DBMS used is defined by the <link linkend="cuba.dbmsType">cuba.dbmsType</link> and (optionally)  <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link> application properties and the configuration of <code>javax.sql.DataSource</code> datasource, which the database access is made through. The instance of the datasource is extracted from the JNDI by name specified in the <link linkend="cuba.dataSourceJndiName">cuba.dataSourceJndiName</link> application property. The configuration file for Tomcat, which defines the datasource, is described in  <xref linkend="context.xml"/></para>
    <para>The platform supports the following DBMS "out of the box":<informaltable frame="all">
        <tgroup cols="3">
          <colspec colname="c1"/>
          <colspec colname="c2"/>
          <colspec colname="c3"/>
          <thead>
            <row>
              <entry/>
              <entry>cuba.dbmsType</entry>
              <entry>cuba.dbmsVersion</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>HSQLDB</entry>
              <entry>hsql</entry>
              <entry/>
            </row>
            <row>
              <entry>PostgreSQL 8.4+</entry>
              <entry>postgres</entry>
              <entry/>
            </row>
            <row>
              <entry>Microsoft SQL Server 2005, 2008</entry>
              <entry>mssql</entry>
              <entry/>
            </row>
            <row>
              <entry>Microsoft SQL Server 2012+</entry>
              <entry>mssql</entry>
              <entry>2012</entry>
            </row>
            <row>
              <entry>Oracle Database 11g</entry>
              <entry>oracle</entry>
              <entry/>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>
    <para>The table below describes the recommended mapping of data types between entity attributes in Java and table columns in different DBMS. These types are automatically chosen by <application>CUBA Studio</application> when generating scripts to create and update the database. The operation of all platform mechanisms is guaranteed when using these types.</para>
    <informaltable frame="all">
      <tgroup cols="5">
        <colspec colnum="1" colname="c0"/>
        <colspec colnum="2" colname="cgen2"/>
        <colspec colnum="3" colname="c1"/>
        <colspec colnum="4" colname="c2"/>
        <colspec colnum="5" colname="cgen1"/>
        <thead>
          <row>
            <entry>Java</entry>
            <entry>HSQL</entry>
            <entry>PostgreSQL</entry>
            <entry>MS SQL Server</entry>
            <entry>Oracle</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>UUID</entry>
            <entry>varchar(36)</entry>
            <entry>uuid</entry>
            <entry>uniqueidentifier</entry>
            <entry>varchar2(32)</entry>
          </row>
          <row>
            <entry>Date</entry>
            <entry>timestamp</entry>
            <entry>timestamp</entry>
            <entry>datetime</entry>
            <entry>timestamp</entry>
          </row>
          <row>
            <entry>java.sql.Date</entry>
            <entry>timestamp</entry>
            <entry>date</entry>
            <entry>datetime</entry>
            <entry>date</entry>
          </row>
          <row>
            <entry>java.sql.Time</entry>
            <entry>timestamp</entry>
            <entry>time</entry>
            <entry>datetime</entry>
            <entry>timestamp</entry>
          </row>
          <row>
            <entry>BigDecimal</entry>
            <entry>decimal(p, s)</entry>
            <entry>decimal(p, s)</entry>
            <entry>decimal(p, s)</entry>
            <entry>number(p, s)</entry>
          </row>
          <row>
            <entry>Double</entry>
            <entry>double precision</entry>
            <entry>double precision</entry>
            <entry>double precision</entry>
            <entry>float</entry>
          </row>
          <row>
            <entry>Long</entry>
            <entry>bigint</entry>
            <entry>bigint</entry>
            <entry>bigint</entry>
            <entry>number(19)</entry>
          </row>
          <row>
            <entry>Integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
          </row>
          <row>
            <entry>Boolean</entry>
            <entry>boolean</entry>
            <entry>boolean</entry>
            <entry>tinyint</entry>
            <entry>char(1)</entry>
          </row>
          <row>
            <entry>String (limited)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar2(n)</entry>
          </row>
          <row>
            <entry>String (unlimited)</entry>
            <entry>longvarchar</entry>
            <entry>text</entry>
            <entry>varchar(max)</entry>
            <entry>clob</entry>
          </row>
          <row>
            <entry>byte[]</entry>
            <entry>longvarbinary</entry>
            <entry>bytea</entry>
            <entry>image</entry>
            <entry>blob</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>As a rule, the whole work to convert the data between the database and the Java code is performed by the <link linkend="orm">ORM layer</link> in conjunction with the appropriate JDBC driver.  This means that no manual conversion is required when working with the data using the  <link linkend="entityManager">EntityManager</link> methods and  <link linkend="query">JPQL queries</link> you should simply use Java types listed in the left column of the table.</para>
    <para>When using native SQL through  <link linkend="nativeQuery">EntityManager.createNativeQuery()</link> or through  <link linkend="queryRunner">QueryRunner</link> some types in the Java code will be different from those mentioned above, depending on DBMS used. In particular, this applies to attributes of the  <code>UUID</code> - type – only the PostgreSQL driver returns values of corresponding columns using this type; other servers return  <code>String</code>.  To abstract application code from the DBMS used, it is recommended to convert parameter types and query results using the <link linkend="dbTypeConverter">DbTypeConverter</link> interface.</para>
    <section id="arbitrary_dbms">
      <title>Support for Other DBMSs</title>
      <para>In the application project, you can use any DBMS supported by the
        <link linkend="orm">ORM</link> framework (OpenJPA). Follow the steps below:
        <itemizedlist>
          <listitem>
            <para>Specify the type of database in the form of an arbitrary code in the
              <link linkend="cuba.dbmsType">cuba.dbmsType</link>
              property. The code must be different from those used in the platform: <code>hsql</code>, <code>postgres</code>,
              <code>mssql</code>, <code>oracle</code>.</para>
          </listitem>
          <listitem>
            <para>Implement the <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code>
              interfaces by classes with the following names: <code>TypeDbmsFeatures</code>, <code>TypeSequenceSupport</code>,
              and <code>TypeDbTypeConverter</code>, respectively, where <code>Type</code>
              is the DBMS type code. The package of the implementation class must be the same as of the interface.</para>
          </listitem>
          <listitem>
            <para>If the project includes the <structname>workflow</structname> base project, override the
              <code>CubaJbpmSpringHelper</code> bean and its <code>getHibernateDialectName()</code>
              method to select the Hibernate dialect that will be used in jBPM.</para>
          </listitem>
          <listitem>
            <para>Create database init and update scripts in the directories marked with the DBMS type code. Init
              scripts must create all database objects required by the platform entities (you can copy them
              from the existing <code>10-cuba</code>, etc. directories and modify for your database).</para>
          </listitem>
          <listitem>
            <para>To create and update the database by Gradle tasks, you need to specify the additional parameters for these tasks in <code>build.gradle</code>:
              <programlisting language="java">task createDb(dependsOn: assemble, type: CubaDbCreation) {
  dbms = &apos;my&apos;                                            // DBMS code
  driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
  dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
  masterUrl = &apos;jdbc:my:myserver://192.168.47.45/master&apos;  // URL of a master DB to connect to for creating the application DB
  dropDbSql = &apos;drop database mydb;&apos;                      // Drop database statement
  createDbSql = &apos;create database mydb;&apos;                  // Create database statement
  timeStampType = &apos;datetime&apos;                             // Date and time datatype - needed for SYS_DB_CHANGELOG table creation
  dbUser = &apos;sa&apos;
  dbPassword = &apos;saPass1&apos;
}

task updateDb(dependsOn: assemble, type: CubaDbUpdate) {
  dbms = &apos;my&apos;                                            // DBMS code
  driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
  dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
  dbUser = &apos;sa&apos;
  dbPassword = &apos;saPass1&apos;
}</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="dbms_version">
      <title>DBMS Version</title>
      <para>In addition to  <link linkend="cuba.dbmsType">cuba.dbmsType</link> application property, there is an optional <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link> property. It affects the choice of interface implementations for <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code>, and the search for database init and update scripts. </para>
      <para>The name of the implementation class of the integration interface is constructed as follows:  <code>TypeVersionName</code>. Here,  <code>Type</code> is the value of the  <code>cuba.dbmsType</code> property (capitalized), <code>Version</code> is the value of  <code>cuba.dbmsVersion</code>, and <code>Name</code> is the interface name. The package of the class must correspond to that of the interface. If a class with the same name is not available, an attempt is made to find a class with the name without version:  <code>TypeName</code>. If such class does not exist either, an exception is thrown. </para>
      <para>For example, the <code>com.haulmont.cuba.core.sys.persistence.Mssql2012SequenceSupport</code> class is defined in the platform. This class will take effect if the following properties are specified in the project: <programlisting>cuba.dbmsType = mssql
cuba.dbmsVersion = 2012</programlisting></para>
      <para>The search for  <link linkend="db_scripts">database init and update scripts</link> prioritizes the  <code>type-version</code> directory over the <code>type</code> directory. This means that the scripts in the  <code>type-version</code> directory replace the scripts with the same name in the  <code>type</code> directory. The  <code>type-version</code> directory can also contain some scripts with unique names; they will be added to the common set of scripts for execution, too. Script sorting is performed by path, starting with the first subdirectory of the  <code>type</code> or  <code>type-version</code> directory, i.e. regardless of the directory where the script is located  (versioned or not).</para>
      <para>For example, the init script for Microsoft SQL Server versions below and above 2012 should look as follows:<programlisting>modules/core/db/init/
   mssql/
       10.create-db.sql
       20.create-db.sql
       30.create-db.sql
   mssql-2012/
       10.create-db.sql </programlisting></para>
    </section>
  </section>
  <section id="db_scripts">
    <title>Scripts to Create and Update the Database</title>
    <para>A CUBA-application project always contains two sets of scripts:<itemizedlist>
        <listitem>
          <para>Scripts to  <emphasis>create</emphasis> the database, intended for the creation of the database from scratch. They contain a set of the DDL and DML operators, which create an empty database schema that is fully consistent with the current state of the  <link linkend="data_model">data model</link> of the application. These scripts can also fill the database with the necessary initialization data.</para>
        </listitem>
        <listitem>
          <para>Scripts to  <emphasis>update</emphasis> the database, intended for bringing the database structure to the current state of the data model from any of the previous states.</para>
        </listitem>
      </itemizedlist></para>
    <para>When changing the data model, it is necessary to reproduce the corresponding change of the database schema in create and update scripts. For example, when adding the  <code>address</code> attribute to the  <code>Customer</code> entity, it is necessary to:<orderedlist>
        <listitem>
          <para>Change the table creation script:<programlisting>create table SALES_CUSTOMER (
  ID varchar(36) not null ,
  CREATE_TS timestamp,
  CREATED_BY varchar(50),
  --
  NAME varchar(100),
  ADDRESS varchar(200), -- added column
  --
  primary key (ID)
)</programlisting></para>
        </listitem>
        <listitem>
          <para>Add an update script, which modifies the same table:<programlisting>alter table SALES_CUSTOMER add ADDRESS varchar(200)</programlisting></para>
        </listitem>
      </orderedlist></para>
    <para>The create scripts are located in the <filename>/db/init</filename> directory of the <structname>core</structname> module. For each type of DBMS supported by the application, a separate set of scripts is created and located in the subdirectory specified in <link linkend="cuba.dbmsType">cuba.dbmsType</link> application property, for example  <filename>/db/init/postgres</filename>. Create scripts names should have the following format <filename>{optional_prefix}create-db.sql</filename>.</para>
    <para>The update scripts are located in the <filename>/db/update</filename> directory of the <structname>core</structname> module. For each type of DBMS supported by the application, a separate set of scripts is created and located in the subdirectory specified in <link linkend="cuba.dbmsType">cuba.dbmsType</link> application property, for example, <filename>/db/update/postgres</filename>. </para>
    <para>The update scripts can be of two types: with the  <filename>*.sql</filename> or  <filename>*.groovy</filename> extension. The primary way to update the database is with SQL scripts. Groovy scripts are only executed by  <link linkend="db_update_server">the server mechanism to launch database scripts</link>, Therefore they are mainly used at the production stage, in cases when migration or import of the data that cannot be implemented in pure SQL. </para>
    <para>The update scripts should have names, which form the correct sequence of their execution when sorted in the alphabetical order (usually, it is a chronological sequence of their creation). Therefore, when creating such scripts manually, it is recommended to specify the name of the update scripts in the following format: <filename>{yymmdd}-{description}.sql</filename>, where  <literal>yy</literal> is a year,  <literal>mm</literal> is a month,  <literal>dd</literal> is a day, and  <literal>description</literal> is a short description of the script. For example, <filename>121003-addCodeToCategoryAttribute.sql</filename>. Studio also adheres to this format when generating scripts automatically.</para>
    <para>It is possible to group update scripts into subdirectories, however the path to the script with the subdirectory should not break the chronological sequence. For example, subdirectories can be created by using year, or by year and month.</para>
    <para>In a deployed application, the scripts to create and update the database are located in a special  <link linkend="db_dir">database script directory</link>, that is set by the <link linkend="cuba.dbDir">cuba.dbDir</link> application property.</para>
    <section id="db_scripts_sql">
      <title>The Structure of SQL Scripts</title>
      <para>Create and update SQL scripts are text files with a set of DDL and DML commands separated by the &quot;^&quot; character. The &quot;^&quot; character is used, so that the &quot;;&quot; separator can be applied as part of complex commands; for example, when creating functions or triggers. The script execution mechanism splits the input file into separate commands using the &quot;^&quot; separator and executes each command in a separate transaction. This means that, if necessary, it is possible to group several single statements (e.g.,  <literal>insert</literal>), separated by semicolons and ensure that they execute in a single transaction.</para>
      <para>An example of the update SQL script:<programlisting>create table LIBRARY_COUNTRY (
  ID varchar(36) not null,
  CREATE_TS time,
  CREATED_BY varchar(50),
  --
  NAME varchar(100) not null,
  --
  primary key (ID)
)^

alter table LIBRARY_TOWN add column COUNTRY_ID varchar(36) ^
alter table LIBRARY_TOWN add constraint FK_LIBRARY_TOWN_COUNTRY_ID foreign key (COUNTRY_ID) references LIBRARY_COUNTRY(ID)^
create index IDX_LIBRARY_TOWN_COUNTRY on LIBRARY_TOWN (COUNTRY_ID)^</programlisting></para>
    </section>
    <section id="db_scripts_groovy">
      <title>The Structure of Groovy scripts</title>
      <para>Groovy update scripts have the following structure:<itemizedlist>
          <listitem>
            <para>The <emphasis>main</emphasis> part, which contains the code executed before the start of the  <link linkend="appContext">application context</link>. In this section, you can use any Java, Groovy and the Middleware application block classes. However, it should be kept in mind that no beans, infrastructure interfaces and other application objects have yet been instantiated and it is impossible to use them.</para>
            <para>The main part is primarily designed to update the database schema, as usually done with ordinary SQL scripts.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>PostUpdate</emphasis> part – a set of closures, which will be executed after the start of the application context  and once the update process is finished. Inside these closures, it is possible to use any Middleware objects.</para>
            <para>In this part of the script, it is convenient to perform data import as it is possible to use the  <link linkend="persistence">Persistence</link> interface and data model objects.</para>
          </listitem>
        </itemizedlist></para>
      <para>The execution mechanism passes the following variables to the Groovy scripts:<itemizedlist>
          <listitem>
            <para><code>ds</code> – instance of <code>javax.sql.DataSource</code> for the application database;</para>
          </listitem>
          <listitem>
            <para><code>log</code> – instance of  <code>org.apache.commons.logging.Log</code> to output messages in the server log;</para>
          </listitem>
          <listitem>
            <para><code>postUpdate</code> – object that contains the  <code>add(Closure closure)</code> method to add PostUpdate closures described above.</para>
          </listitem>
        </itemizedlist></para>
      <warning>
        <para>Groovy scripts are executed only by <link linkend="db_update_server">the server mechanism to launch database scripts</link>.</para>
      </warning>
      <para>An example of the Groovy update script:<programlisting language="java">import com.haulmont.cuba.core.Persistence
import com.haulmont.cuba.core.global.AppBeans
import com.haulmont.refapp.core.entity.Colour
import groovy.sql.Sql

log.info(&apos;Executing actions in update phase&apos;)

Sql sql = new Sql(ds)
sql.execute &quot;&quot;&quot;
alter table MY_COLOR add DESCRIPTION varchar(100);
&quot;&quot;&quot;

// Add post update action
postUpdate.add({
  log.info(&apos;Executing post update action using fully functioning server&apos;)

  def p = AppBeans.get(Persistence.class)
  def tr = p.createTransaction()
  try {
      def em = p.getEntityManager()

      Colour c = new Color()
      c.name = &apos;yellow&apos;
      c.description = &apos;a description&apos;

      em.persist(c)
      tr.commit()
  } finally {
      tr.end()
  }
})</programlisting></para>
    </section>
  </section>
  <section id="db_update_gradle">
    <title>The Execution of Database Scripts by Gradle Tasks</title>
    <para>This mechanism is generally used by application developers for updating their own database instance. The execution of scripts essentially comes down to running a special Gradle task from <link linkend="build.gradle">build.gradle</link> build script. This can be done from the command line or via the Studio interface.</para>
    <para>To run scripts to <emphasis>create</emphasis> the database, the <code>createDb</code> task is used. In Studio, it corresponds to the   <guimenu>Run</guimenu> -&gt; <guimenu>Create database</guimenu> command in main menu. When this task is started, the following occurs:<orderedlist>
        <listitem>
          <para>Platform’s  <link linkend="base_projects">base projects</link> scripts and  <filename>db/**/*.sql</filename> scripts of the <structname>core</structname> module of the current project are built in the  <filename>modules/core/build/db</filename> directory. Sets of scripts for base projects are located in subdirectories with numeric prefixes starting from 10. Scripts of the current project are located in a subdirectory with prefix 50. The numeric prefixes are used to provide the alphabetical order of the execution of scripts – first,  <structname>cuba</structname> scripts are executed, then base projects scripts, then current project scripts.</para>
        </listitem>
        <listitem>
          <para>If the database exists, it is completely erased. A new empty database is created.</para>
        </listitem>
        <listitem>
          <para>All creation scripts from <filename>modules/core/build/db/init/**/*create-db.sql</filename> subdirectory are executed sequentially in the alphabetical order, and their names along with the path relative to the db directory are registered in the <database>SYS_DB_CHANGELOG</database> table.</para>
        </listitem>
        <listitem>
          <para>Similarly, in the <database>SYS_DB_CHANGELOG</database> table, all currently available  <filename>modules/core/build/db/update/**/*.sql</filename> update scripts are registered. This is required for applying the future incremental updates to the database. </para>
        </listitem>
      </orderedlist></para>
    <para>To run scripts to  <emphasis>update</emphasis> the database, the <code>updateDb</code> task is used. In Studio, it corresponds to the <guimenu>Run</guimenu> -&gt; <guimenu>Update database</guimenu> command in main menu. When this task is started, the following occurs:<orderedlist>
        <listitem>
          <para>The scripts are built in similar way to <code>createDb</code> command described above.</para>
        </listitem>
        <listitem>
            <para>The execution mechanism checks, whether all base projects have required tables in the database. If
                the database is not initialized for use of some base project, its creation scripts are executed.</para>
        </listitem>
        <listitem>
          <para>A search is performed in  <filename>modules/core/build/db/update/**</filename> directories, for update scripts, which are not registered in the <database>SYS_DB_CHANGELOG</database> table, i.e., not previously executed.</para>
        </listitem>
        <listitem>
          <para>All scripts found in the previous step are executed sequentially in the alphabetical order, and their names along with the path relative to the <filename>db</filename> directory are registered in the  <database>SYS_DB_CHANGELOG</database> table. </para>
        </listitem>
      </orderedlist></para>
  </section>
  <section id="db_update_server">
    <title>The Execution of Database Scripts by the Server</title>
    <para>The mechanism to execute database scripts by the server is used for bringing the DB up to date at the start of the application server and is activated during the initialization of the Middleware block. Obviously, the application should have been built and deployed on the server – production or developer’s Tomcat instance.</para>
    <para>Depending on the conditions described below, this mechanism either executes  create or update scripts, i.e., it can initialize the DB from scratch and update it. However, unlike the Gradle  <code>createDb</code> task described in the previous section, the database must exist to be initialized – the server does not create the DB automatically but only executes scripts on it.</para>
    <para>The mechanism to execute scripts by the server works as follows:<itemizedlist>
        <listitem>
          <para>The scripts are extracted from the <link linkend="db_dir">database scripts directory</link>, defined by the <link linkend="cuba.dbDir">cuba.dbDir</link> application property, which by default is set to <filename>tomcat/webapps/app-core/WEB-INF/db</filename>.</para>
        </listitem>
        <listitem>
          <para>If the DB does not have the  <database>SEC_USER</database> table, the database is considered empty and the full initialization is run using the create scripts. After executing the initialization scripts, their names are stored in the <database>SYS_DB_CHANGELOG</database> table. The names of all available update scripts are stored in the same table,  <emphasis>without their execution</emphasis>.</para>
        </listitem>
        <listitem>
          <para>If the DB has the <database>SEC_USER</database> table but does not have the  <database>SYS_DB_CHANGELOG</database> table (this is the case when the described mechanism is launched for the first time on the existing production DB),<emphasis> no scripts are executed</emphasis>. Instead, the <database>SYS_DB_CHANGELOG</database> table is created and the names of all currently available create and update scripts are stored. </para>
        </listitem>
        <listitem>
          <para>If the DB has both the <database>SEC_USER</database> and  <database>SYS_DB_CHANGELOG</database> tables,
              the update scripts whose names were not previously stored in the <database>SYS_DB_CHANGELOG</database>
              table are executed and their names are stored in the <database>SYS_DB_CHANGELOG</database> table.
              The sequence of scripts execution is determined by two factors: the priority of the base project
              (see <link linkend="db_dir">database scripts directory</link>: <filename>10-cuba</filename>,
              <filename>20-workflow</filename>, ...) and the name of the script file (taking into account the
              subdirectories of the <filename>update</filename> directory) in the alphabetical order.</para>
            <para>Before the execution of update scripts, the check is performed, whether all base projects have required
                tables in the database. If the database is not initialized for use of some base project, its creation
                scripts are executed.</para>
        </listitem>
      </itemizedlist></para>
    <para>The mechanism to execute the scripts on server startup is enabled  by the <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link> application property.</para>
    <para>In already running application, the script execution mechanism can be launched using the <code>app-core.cuba:type=PersistenceManager</code> JMX bean by calling its  <code>updateDatabase()</code> method with the <userinput>update</userinput> parameter.  Obviously it is only possible to update already existing DB as it is impossible to log in to the system to run a method of the JMX bean with an empty DB. Please note, that an unrecoverable error will occur, if part of the data model no longer corresponding to the outdated DB schema is initialized during Middleware startup or user login. That is why the automatic update of the DB on the server startup before initializing the data model is only universal. </para>
    <para>The JMX  <code>app-core.cuba:type=PersistenceManager</code> bean has one more method related to the DB update mechanism: <code>findUpdateDatabaseScripts()</code>. It returns a list of new update scripts available in the directory and not registered in the DB (not yet executed).</para>
    <para>Recommendations for usage of the server DB update mechanism can be found in  <xref linkend="db_update_in_prod"/>.</para>
  </section>
</section>

[[creation]]
== Creating Reports

Creating a report in the system involves two dependent elements: visual presentation template and description of the data extracted for the report. The template is created in XLS(X), DOC(X), HTML formats using external tools, and the description of report data is created in the report designer screen.

Depending on the template and report parameters, the generated report can be in PDF, XLS(X), DOC(X) or HTML.

The report data structure can either be described in the report designer by creating bands, queries and other elements, or programmed in a Java class that implements a special interface. The report can take parameters from the user or from the calling code. You can specify users who will have access to the report, and system screens where it should appear.

The main components of the report generator are shown in the following diagram:

.Report Generator Components
image::reporting.png[align="center"]

* `YARG` - framework, which is the core of the report generator.
* `Report Engine` integrates YARG into CUBA platform and provides additional functionality such as access rights to reports and integration with screens.
* `Report Designer` is a tool for describing and storing reports. It includes the infrastructure for storing report descriptions and templates, as well as screens to create and manage reports.
* `Report` - report data structure descriptor, including _Bands_ (report bands) and _Datasets_ (datasets which are being output in the bands).
* `Report Template` - report visual presentation template.

[[structure]]
=== Report Data Structure

The *Report structure* tab of the report editor is described below:

.Report Data Structure
image::report_structure.png[align="center"]

The top part contains fields to enter general report properties:

* *Name* - report name. The name can be localized in the *Localization* tab.
* *Group* - report group, which is used for grouping in the standard report browser.
* *Default template* - report output <<template,template>>.
* *System code* - optional code, which you may use to identify the report in the application code.

The main element of the report data structure is the band hierarchy - *Report bands*.

A report band has the following parameters:

* *Band name* - unique band name within the report. It must contain only Latin letters, numbers and underscores. Moreover, if the band name starts with *header*, its data will not be printed in the <<table_output,table output>>.
* *Orientation* - band orientation: *Horizontal*, *Vertical* or <<crosstab_xls,Crosstab>>. Horizontal bands are copied downwards, vertical - to the right, crosstab - to the right and downwards as a matrix. Horizontal bands may contain sub-bands.
* *Parent band* - parent band.

Each band includes one or more datasets. At the moment when a report is run, datasets are transformed into lists of rows, where each row contains a map of name-value pairs. A band appears in the report as many times as there are rows in its longest dataset. Field names are specified in the report template and are replaced with corresponding values from the dataset when the report is produced. When describing datasets, you can use <<parameters,external parameters>> of the report as well as fields from other bands - this allows creating linked bands.

Each report has the *Root* band. You can create datasets in it and refer to their fields from other bands, but you cannot use the *Root* band in the report template.

The *Dataset name* column value is used for user convenience only.

The *Link field* is used to merge data from multiple datasets inside one band. It can be used when the whole data for the report row could not be received by a single query or a Groovy script.

Supported dataset types are described below.

[[structure_sql]]
==== SQL Dataset

*SQL* dataset is produced as result of SQL query execution. It is recommended to use aliases for query result fields with the help of the `as` operator. It is also recommended to enclose the aliases in double quotes to prevent possible case conversion by the DBMS:

[source, sql]
----
select u.name as "userName", u.login as "userLogin" 
from sec_user u
----

You can use report input parameters and parent bands fields in the query. Parameters should be addressed by name enclosed in `${}`, for example, `${dateFrom}`. Parent band fields should be addressed similarly, by adding the band name in front of the field name: `${band1.field1}`.

Below is an example of an SQL query with a `groupId` parameter, obtained from the `group` parent band and an external  `active` parameter:

[source, sql]
----
select u.name as "userName", u.login as "userLogin" 
from sec_user u
where u.group_id = ${group.groupId} 
    and u.active = ${active}
    and u.delete_ts is null
----

[WARNING]
====
You should manually include conditions to filter soft deleted records for SQL queries.
====

By default, SQL queries are executed on the main database. If you want to query an additional data store (see Developer's Manual), set its name in the *Data store* field.

[[query_preprocessing]]
Query preprocessing in bands::
+
--
If you need to modify the SQL/JPQL query dynamically depending on the report input parameters, or the parameter values from the parent band, you can use the SQL preprocessing. The template engine enables you to modify SQL/JPQL queries using Groovy. In order to activate it, check the *Preprocess query as Groovy template* checkbox below the band editor. The resulting query will be processed by `GStringTemplateEngine` that will have access to:

* the report parameters: `${<parameter_name>}`,

* values from parent bands: `${<band_name>.<parameter_name>}`.

Let's consider the following example: depending on whether the `createTs2` report parameter is passed you need to select one of the query conditions: `e.create_ts < ${createTs2}` or `e.create_ts < current_timestamp`.

In this case the query should look like:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
<% out << (createTs2 != null  ? 'e.create_ts < ${createTs2}' : 'e.create_ts < current_timestamp')%>
----

Thus, if the `createTs2` parameter is not passed, the initial query will be transformed into the following resulting query:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < current_timestamp
----

If `createTs2` is passed, the following resulting query will be used for the band:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < ${createTs2}
----
--

[[structure_jpql]]
==== JPQL Dataset

*JPQL* dataset is produced as result of JPQL query execution. The resulted query fields must have aliases provided using the `as` operator. You can use report input parameters and parent bands fields in the JPQL query, similar to SQL query.

Below is an example of a JPQL query with a `groupId` parameter, obtained from the `group` parent band and an external `active` parameter:

[source, jpql]
----
select u.name as userName, u.login as userLogin
from sec$User u
where u.group.id = ${group.groupId}
    and u.active = ${active}
----

JPQL queries automatically support soft deletion and return only records which are not deleted.

You can also activate <<query_preprocessing,query preprocessing>> by checking the *Preprocess query as Groovy template* checkbox below the band editor.

By default, JPQL queries use entities mapped to the the main database. If you want to query entities from an additional data store (see Developer's Manual), set its name in the *Data store* field.

[[structure_groovy]]
==== Groovy Dataset

*Groovy* dataset is produced as result of a Groovy script execution. The script must return an object of the `List<Map<String, Object>>` type. Each element of this list - an object of the `Map<String, Object>` type - corresponds to one dataset record.

The following objects are passed into the script:

* `dataManager` - an object of the `com.haulmont.cuba.core.global.DataManager` type that provides CRUD functionality. For example:
+
[source, groovy]
----
def book = dataManager.load(Book.class).id(bookId).view("book.edit").one;
----

* `metadata` - an object of the `com.haulmont.cuba.core.global.Metadata` type, providing access the application metadata. For example:
+
[source, groovy]
----
def metaClass = metadata.getClassNN('sec$User')
----

* `params` - external report parameters map. Below is an example to get a parameter value:
+
[source, groovy]
----
def active = params['active']
----

* `parentBand` - parent band as an object of the `com.haulmont.yarg.structure.BandData` type. This object allows you to get a parent band field value by invoking the `getParameterValue()` method, for example:
+
[source, groovy]
----
def groupId = parentBand.getParameterValue('groupId')
----

* `persistence` - an object of the `com.haulmont.cuba.core.Persistence` type that allows you to get datasources.
+
By default, the main data store is used. For working with an additional data store, pass its name as a parameter to `getDataSource()` method:
+
[source, groovy]
----
def sql = new Sql(persistence.getDataSource('myStore'))
def rows = sql.rows('select e.name from SEC_GROUP e')
----

* `security` -  an object of the `com.haulmont.cuba.core.global.Security` type used to check user access rights to different objects in the system. For example:
+
[source, groovy]
----
if (security.isEntityOpPermitted(Book.class, EntityOp.READ) {
    ...
}
----

* `timeSource` - an object of the `com.haulmont.cuba.core.global.TimeSource` type used to obtain the current time. For example:
+
[source, groovy]
----
def currentDate = timeSource.currentTimestamp()
----

* `transactional` - a method that takes a closure, which should be executed in a new transaction, as parameter. The current `EntityManager` becomes the closure parameter. For example:
+
[source, groovy]
----
transactional { em ->
    def query = em.createQuery('select g from sec$Group g')
    ...
}
----
+
Below is an example of the Groovy script which extracts users by the group which is output in the parent band and by the `active` external parameter:
+
[source, groovy]
----
def result = []
transactional { em ->
    def query = em.createQuery('select u from sec$User u where u.group.id = ?1 and u.active = ?2')
    query.setParameter(1, parentBand.getParameterValue('groupId'))
    query.setParameter(2, params['active'])
    query.resultList.each { user ->
        result.add(['userLogin': user.login, 'userName': user.name])
    }
}
return result
----

* `userSession` - an object of the `com.haulmont.cuba.security.global.UserSession` type associated with the currently authenticated user. For example:
+
[source, groovy]
----
def user = userSession.currentOrSubstitutedUser
----

* `userSessionSource` - an object of the `com.haulmont.cuba.core.global.UserSessionSource` type which is used to obtain current user session object. For example:
+
[source, groovy]
----
def locale = userSessionSource.locale
----

[TIP]
====
You can use static methods of the `AppBeans` class to access any Spring beans of the middleware tier, for example:

[source, groovy]
----
def myService = com.haulmont.cuba.core.global.AppBeans.get('sample_MyService')
----
====

[[structure_entity]]
==== Entity Dataset

*Entity* dataset consists of a single row and is produced using attributes of a single entity instance and the entities related to it.

The data source is produced from an external parameter of the *Entity* type, which must be described in the *Parameters and Formats* tab. The value in the *Entity parameter name* field must match the parameter name.

The report template must contain fields with entity attribute names. Attributes used in the template should be listed in the special window, which is invoked by the *Select entity attributes* button.

[[structure_list]]
==== List of Entities Dataset

*List of entities* dataset is produced using a list of entity instances.

The data source is produced using an external parameter being a *List of entities*, which must be described in the *Parameters and Formats* tab. The value in the *Entity parameter name* field must match the parameter alias.

The report template must contain fields with entity attribute names. Attributes used in the template should be listed in the special window, which is invoked by the *Entity attributes* button.

[[structure_json]]
==== JSON Dataset

*JSON* dataset is generated from JSON data. This data can be received from the following sources:

. *Groovy script*
+
--
The script provided by the user is supposed to return JSON data as a string.

For example:

[source, json]
----
include::{sourcesdir}/json.groovy[]
----
--

. *URL*
+
--
The report engine will perform a GET HTTP query against the URL.

For example:

[source, plain]
----
https://jsonplaceholder.typicode.com/users
----
--

. *Parameter of a String type*
+
--
The report external parameter of String type which contains the JSON data must be described in the *Parameters and Formats* tab.
--

The received JSON tree is queried using the JsonPath query. For example, you can use the `$.store.book[*]` JsonPath to return all books from the following JSON tree:

[source, json]
----
include::{sourcesdir}/json.json[]
----

For more details on JsonPath expressions see http://goessner.net/articles/JsonPath/.

[[template]]
=== Report Template

You can create several templates for a single report in the *Templates* tab of the report editor. One of them must be selected as the default template in the *Report structure* tab.

Below is the form to add a template:

.Template Editor
image::report_template.png[align="center"]

* *Template code* - template code for its identification.

* *Template file* - template file, which is loaded from the file system and saved to the database along with the report structure description.

* *Output type* - report output type. It should be consistent with the template file type according to the rules described in <<template_to_output>>.

* *Output name pattern* - optional file name pattern, which will be used for the produced report download.
It can either be a constant string or contain report parameter as a variable, e.g. `${header.authorName}.xlsx`. More sophisticated patterns with several parameters and string concatenation can also be created as a script in any band of report structure, e.g. `${Root.title}.xlsx`, where `title` is a result of the script:
+
[source, groovy]
----
[['title' : ('Report for '+params['author'].firstName+' '+params['author'].lastName)]]
----

* *Is custom* - flag to use custom formatting logic not covered by any provided formatter.

* *Defined by* - the way the custom template is defined: by a <<template_custom,class>>, script or URL.

* *Custom definition* - the fully qualified name of the Java class, the path to the Groovy script in the *core* module, or the URL used to create the template.

* *Is alterable output* - flag to let the user choose the output type of a report at runtime in a dialog window.
+
--
If the flag is on, a dialog with output type selection will be shown when running a report. If the report has more than one template, the template selection dropdown will be shown as well.

.Alterable Output
image::report_template_alterable.png[align="center"]
--

[[template_xls]]
==== XLSX and XLS Templates

You can create XLSX and XLS templates using Microsoft Office or LibreOffice.

[[template_xls_regions]]
Each report band must have a corresponding region in the template, which is named as the band. For instance, a report has two bands - Header and Data. This means that template should also have Header and Data named ranges. To create named regions, select the desired cell ranges and enter the name in the field in the application top left corner. To edit existing named regions, use the *Formulas* -> *Name Manager* menu command in Microsoft Office, and the *Insert* -> *Names* -> *Manage* command in OpenOffice.
Vice versa, each part of the sheet you want to show should be a band in report (at least an empty band).

The bands are output in the order specified in the <<structure,report structure>>.

Bands can be horizontally and vertically oriented. If the band is horizontal, suitable named region will grow downward, vertical will grow rightward. Horizontal bands may be organized in tree-like structure and contain sub-bands (nested or children bands). Therefore, for sub-bands, you need to create named regions directly under the regions that correspond to the parent bands.
XLSX formatter render children bands using the following algorithm:

* Write the first row of parent band ->
* Write all first row's children rows ->
* Write the next row of parent band.

The band dataset fields are placed in the template using strings having `++${field_name}++` format, where `++field_name++` is the corresponding band field name. For example:

.XLS File Template
image::report_template_xls.png[align="center"]

You can add variables to the reporting template. Variables should be inserted into sheet names or the header/footer of XLSX template having `++${<BandName>.<variableName>}++` format.

Cells may contain formatting as well as multiple fields inside. To output images or formulas, you need to place them entirely into the corresponding named region linked with the band.

Formulas can reference the cells of the same band or another band. To be processed by formatter, the formulas should use either range of cells in the band, or direct cells coordinates, e.g. `(A1*B1)` or `($B:$B)`.

To process the data as an Excel chart, create an empty band in the report structure and a named region with the same name in the template. Then create a chart inside this named region and make a reference to related bands using *Select data* button in the chart context menu. If your chart data is in a continuous range of cells, select any cell in that range. Your chart will include all the data in the range. If your data isn't in a continuous range, select nonadjacent cells or ranges.

Converting XLSX to PDF and CSV::
+
--
XLSX reports can be automatically converted to CSV and PDF format. <<open_office,OpenOffice/LibreOffice>> should be installed for the PDF conversion.

.CSV Output
image::csv_output.png[align="center"]
--

[[template_csv]]
==== CSV Templates

You can create CSV templates using Microsoft Office or LibreOffice.

Bands in CSV template should be horizontally oriented, so the suitable named region will grow downward. Also, bands should belong to the first level of data, i.e. be the children of the Root band. In all other respects, the same principles as for <<template_xls,XLS/XLSX templates>> should be used.

.CSV Template Example
image::csv_template.png[align="center"]

.CSV Output
image::csv_report.png[align="center"]

*Inline editor*

CSV templates support inline editing. You can edit the template directly in the *Template editor* window and see the changes without having to re-upload the template file.

.CSV Inline Editor
image::csv_report_editor.png[align="center"]

[[template_doc]]
==== DOCX and DOC Templates

You can create DOC and DOCX templates using Microsoft Office or OpenOffice / LibreOffice.

A template of these types can include document text and optionally one or more tables. The document text outputs the data from the first rows of arbitrary bands. In a table, you can output an arbitrary number of band rows.

To place a field in the document text, you should use a string having `++${band_name.field_name}++` format, where `++band_name++` is the band name, `++field_name++` - name of a band's field.

In order to output data into a table, you should link it to a band. This is done by specifying `++##band=band_name++` in the table's first cell, where `++band_name++` is the band name. The table fields are placed using `++${field_name}++` format, where `++field_name++` is the field name of the band associated with the table. You can use band name prefix to access fields of other bands, same as in the document text fields. You can output several fields in a single table cell.

Horizontal bands in DOCX and DOC cannot contain sub-bands. If you need sub-bands, use XLS(X) format.
[WARNING]
====
The table must contain either one or two rows. If the table has two rows, then the corresponding band fields must be in the second row. The first row should contain the marker with the corresponding band name and, if necessary, a static text or other band fields.
====

Below is an example of a template which outputs a report consisting of two bands, `Book` and `Authors`. The first band outputs a book name and genre, and the second outputs a list of authors of this book.

.DOCX Template
image::report_template_doc.png[align="center"]

[WARNING]
====
Cells data format is not supported in DOCX and DOC templates. To avoid numbers or dates formatting problems due to user's locale, such as unnecessary numeric separators, try to cast your data to string.
For example, wrap
[source, sql]
----
select e.year as "year"
----
into
[source, sql]
----
select cast(e.year as varchar(4)) as "year"
----
====

[[template_html]]
==== HTML Template

An HTML template is defined in an `.html` file (`UTF-8` encoding without `BOM`). You can use HTML/CSS features of https://github.com/flyingsaucerproject/flyingsaucer[Flying Saucer] library, its main guide is available at http://flyingsaucerproject.github.io/flyingsaucer/r8/guide/users-guide-R8.html

To control page size, page headers and footers, use special CSS rules and properties. You can find an example of a report with repeatable header and footer blocks in the <<example_html,Sample Reports>> section.

FreeMarker tags are used to place data (FreeMarker documentation is available at https://freemarker.apache.org/docs/).

The FreeMarker document model has the following structure:

[source, groovy]
----
Band { 
      bands [ bandName : [ band, .. ], .. ]
      fields [ fieldName : fieldValue, .. ] 
}
----

For example, you should use the following expression to access the `name` field in a row having index 0 of the `band` band:

[source, groovy]
----
Root.bands.band[0].fields.name
----

You may use variables for convenience, e.g.:

[source, html]
----
<#assign headerRow = Root.bands.Header[0]>
<p>Date: ${headerRow.fields.reportDate}</p>
----

Below is an example of a template which outputs a report consisting of two bands, `Book` and `Authors`. The first band outputs a book name and genre, and the second outputs a list of authors of this book.

[source, html]
----
include::{sourcesdir}/examples_html_6.html[]
----

Below is a more complex example. Let us assume we have the following bands structure:

[source, groovy]
----
Root {
    HeaderBand {
        query = return [[ "name" : "Column1" ],[ "name" : "Column2" ]]
    }
    Band1 {
        query = return [
                ["field1" : "Value 11", "field2" : "Value 12"],
                ["field1" : "Value 21" , "field2" : "Value 22"]
        ]
    }
    Band2 {
        query = return [[ "header" : "Header1" ], [ "header" : "Header2" ]]
        SubBand1 {
            query = return [["header" : 'SubHeader1'] , [ "header" : 'SubHeader2' ]]
        }
    }
}
----

* Inserting a field:

[source, html]
----
include::{sourcesdir}/examples_html_8.html[]
----

* Inserting a list:

[source, html]
----
include::{sourcesdir}/examples_html_9.html[]
----

* Inserting a table:

[source, html]
----
include::{sourcesdir}/examples_html_10.html[]
----

* Inserting a multi-level list:

[source, html]
----
include::{sourcesdir}/examples_html_11.html[]
----

*Embedded pictures*

At the moment, CUBA Reporting add-on does not provide means of inserting images into HTML-reports similarly to DOCX/XLSX reports. Images still can be embedded with the `img` tag and the link to the picture in the `src` attribute. There are two ways to add images to the HTML-report:

* by URL
+
An image can be hosted on the Tomcat server or any external hosting up to the local file reference. For example, the image hosted in the `deploy\tomcat\webapps\ROOT\images` folder can be inserted like:
[source, html]
----
<img src="http://localhost:8080/images/SomeImage.jpg" height="68" width="199" border="0" align="right"/>
----

* by Bitmap
+
An image is added as a byte array within the `src` attribute. This approach allows you to use variables for the `FileDescriptor` attributes of the entities. The byte array can even be added directly to the template, even though this approach is not recommended:
[source, html]
----
<img alt="SomePicture.png" src="data:image/png;base64,iVBORw0K ..... AcEP9PwxD0hNKK1FCAAAAAElFTkSuQmCC"/>
----

*Inline editor*

HTML templates support inline editing. You can edit the template directly in the *Template editor* window and see the changes without having to re-upload the template file.

.HTML Inline Editor
image::html_report_editor.png[align="center"]

[[html_to_pdf]]
===== Converting HTML to PDF

Reports which have a template in HTML format and the PDF output format do not always properly display fonts. To resolve this, add `cuba/fonts` subdirectory with required `.ttf` fonts to the Middleware configuration directory (`tomcat/conf/app-core` in default deployment configuration). Additionally, you can use existing operating system fonts by specifying their path in the <<reporting.fontsDir,reporting.fontsDir>> application property.

In order to resolve the fonts issue on a Ubuntu server, you should do the following:

* Install the `ttf-mscorefonts-installer` package:
+
----
$ sudo apt-get install ttf-mscorefonts-installer
----

* Set the <<reporting.fontsDir,reporting.fontsDir>> application property:
+
----
reporting.fontsDir = /usr/share/fonts/truetype/msttcorefonts
----

* Explicitly specify fonts in HTML templates, for example:

[source, html]
----
<html>
<head>
    <style type="text/css">
        * {
            font-family: Times New Roman;
        }
    </style>
----

Another thing to mention is parsing of special characters. To avoid errors when converting HTML to PDF, it is recommended to wrap your fields in `<![CDATA[ ]]>` construction in your HTML template file:
[source, html]
----
<tr>
	<td> <![CDATA[${(row.fields('book_name'))!?string!}]]> </td>
	<td> <![CDATA[${(row.fields('author'))!?string!}]]> </td>
</tr>
----

[[template_jasper]]
==== JasperReports Template

JasperReports formatter allows you to use JasperReports templates to output the information extracted by CUBA reporting. The template will be processed by the report engine, providing an output of defined type, see <<template_to_output>>.

You can create JRXML templates using JasperReports tools (for example, Jaspersoft Studio) or in a simple text editor. Each report band defined in the report structure must have a corresponding `band` element in the template which is, in turn, placed within one of the standard JasperReports report sections (which are also named as the bands in JasperReports terms): `title`, `pageHeader`, `columnHeader`, `detail`, etc.

The report engine puts all report band data in one datasource: `JRBandDataDataSource`, which contains data as a tree with the `Root` band as the root, and passes the `CubaJRFunction` instance to the template as the main data source that can be addressed using the `REPORTING` parameter. Declaring this parameter in the report template is not mandatory, it will be added automatically if omitted, but if you want to compile the template in JasperReports IDE, you need to declare this parameter explicitly.

The `REPORTING` parameter supports two functions:

* `dataset` -  gets the sub-datasource from the main data source that can be used, for example, in tables or in subreports as subDataset. This method searches among the children of the root band for the band with specified name and creates a new data source with this band data as a new root. For example:
+
[source, xml]
----
<subDataset name="Product">
	<field name="name" class="java.lang.String"/>
	<field name="price" class="java.lang.Long"/>
</subDataset>
...
<dataSourceExpression><![CDATA[$P{REPORTING}.dataset("Product")]]></dataSourceExpression>
----

* `bitmap` - transforms the given byte array into `ByteArrayInputStream` and can be used for embedding images into the report. For example:

[source, xml]
----
<field name="Main.image" class="java.lang.Object"/> //image from DB as byte array
...
<imageExpression><![CDATA[$P{REPORTING}.bitmap($F{Main.image})]]></imageExpression>
----

Each report band can be used in the template only once, so if you need to represent the same data in different forms within one report (for example, as a table and a chart), you need to create as many bands as the `band` elements in the template. Nested bands are not supported, all bands should be direct children of the *Root* band.

The data can be retrieved from the datasource using the following syntax: `$F{<field name>}`. For example:

[source, xml]
----
<textField>
    <textFieldExpression><![CDATA[$F{library_department_name}]]></textFieldExpression>
</textField>
----

You can find an example of a report with JasperReports template in the <<example_jasper,Sample Reports>> section.

[[template_jasper_uberJar]]
[TIP]
====
If your application uses the https://doc.cuba-platform.com/manual-latest/uberjar_deployment.html[UberJAR] deployment option, do the following to run JasperReports with the UberJAR:

* Copy `jasperreports-.jar` and `yarg-.jar` to uber JAR directory,

* Create a file `jasperreports.properties` in the uber JAR directory,

* Add the `net.sf.jasperreports.compiler.classpath` property in this file with the names of the copied JARs as the property value, for example:

[source, plain]
----
net.sf.jasperreports.compiler.classpath = jasperreports-6.4.1.jar;yarg-2.0-SNAPSHOT.jar
----
====

[[template_custom]]
==== Class-Defined Template

Class-defined templates are used when it is too difficult or impossible to select data using SQL, JPQL or Groovy. They are used, for example, when the report is a result of combining several other reports. 

The class defining the template must be placed in the *core* module and implement the `com.haulmont.yarg.formatters.CustomReport` interface. In the class, you need to define the `createReport()` method, which returns an array of bytes and takes the following input parameters:

* `report` - report descriptor of the `com.haulmont.yarg.structure.Report` type.
* `rootBand` - root band data of the `com.haulmont.yarg.structure.BandData` type.
* `params` - map of external report parameters.

Below is an example of a simple class-defined template. It creates an HTML document showing the name of a book selected as report parameter: 

[source, java]
----
package com.sample.library.report;

import com.haulmont.yarg.formatters.CustomReport;
import com.haulmont.yarg.structure.BandData;
import com.haulmont.yarg.structure.Report;
import com.sample.library.entity.Book;
import java.util.Map;

public class BookReport implements CustomReport {
    @Override
    public byte[] createReport(Report report, BandData rootBand, Map<String, Object> params) {
        Book book = (Book) params.get("book");
        String html = "<html><body>";
        html += "<p>Name: " + book.getName() + "</p>";
        html += "</body></html>";
        return html.getBytes();
    }
}
----

In the template editor check the *Is custom* checkbox, select *Class* in the *Defined by* field and set the fully qualified name of the Java class as the custom definition:

.Class-Defined Template
image::class_defined_template.png[align="center"]

[[template_chart]]
==== Chart Template

Chart output type is available if the application project includes the https://doc.cuba-platform.com/charts-latest/[*charts* component]. Resulting chart is displayed in the *Reports* -> *Show Charts* screen of your web application.

Two types of diagrams are supported: Pie chart and Serial chart. Each type has its own set of parameters.

Pie chart:

.Pie Chart Template
image::chart_template_pie.png[align="center"]

* *Band name* - a band providing data for the chart.
* *Title field* - a field from which segment names will be taken.
* *Value field* - a field from which segment values will be taken.
* *Color field* - a field from which segment colors will be taken. The color value should be specified in the https://en.wikipedia.org/wiki/Web_colors[web] format. If not defined, colours will be chosen automatically.
* *Units* - this text will be added to legend values.

Serial chart:

.Serial Chart Template
image::chart_template_serial.png[align="center"]

* *Band name* - a band providing data for the chart.
* *Category field* - a field from which category names will be taken.
* *Category axis caption* - a caption for the horizontal axis.
* *Value axis caption* - a caption for the vertical axis.
* *Value axis units* - this text will be added to values.

At least one row definition must be added for the serial chart:

* *Value field* - a field from which row values will be taken.
* *Type* - row display type.
* *Color field* - a field from which segment colors will be taken. The color value should be specified in the https://en.wikipedia.org/wiki/Web_colors[web] format. If not defined, colours will be chosen automatically.

[[pivotTable_output]]
==== Pivot Table Formatter

Pivot Table output type is available if the application project includes the *charts* component. For more information on Pivot Table see the https://doc.cuba-platform.com/charts-latest/pivotTable.html[*Charts* manual].

To use the pivot table formatter, select Pivot Table as the output type in the report template editor. The resulting table is displayed in the *Reports* -> *Show Pivot Tables* screen of your web application.

.Pivot Table Formatter
image::pivot_template_result.png[align="center"]

The report generator will get the band data and draw a table with drag-and-drop functionality, aggregation, and summary. Only one band can be used in the pivot report, nested bands are not supported.

Renderer options::

This tab enables defining the collection of rendering functions that should be displayed in the list of available renderers in the UI and setting the default one.

.Renderer Options
image::pivot_template_renderer.png[align="center"]

Aggregation options::

The *Aggregation options* tab allows you to define the list of table aggregators. Aggregation attributes:

* *Mode* enables setting one of the predefined aggregation functions,
* *Caption* is a localized value to be displayed in the UI,
* *Custom function* - if not empty, the mode value is ignored in favor of the custom JavaScript code.

.Aggregation Options
image::pivot_template_aggregation.png[align="center"]

Properties options::

The pivot table displays all properties for all types of <<structure,datasets>>. To be processed correctly, the aliases of reference attributes in SQL, JPQL and Groovy datasets should not contain periods, for example, `select u.name as "userName"`. The selected properties should be set as the pivot table's properties on the *Properties options* tab of the template editor:

* *Row*, *Column* - a key-value map with the set of properties to be used in the pivot table columns and rows, where the key is the name of a dataset property and the value is its localized caption.
* *Aggregation* - the properties that will be aggregated in each cell,
* *Derived property* - can be used to add new attributes to the original data set, derived from the existing ones. This element is a key-value map, where the key is the name of a generated attribute, and the value is a JavaScript function that generates this attribute.

.Properties Options
image::pivot_template_properties.png[align="center"]

Custom options::

* *Filter function* - JavaScript function that will be used for filtering.
* *Sorters function* - JavaScript function that will be used for rows and columns captions sorting.
* Renderer options, depending on the selected renderer, enable setting a JavaScript function that will be used to customize the renderer's appearance. Actually, only two renderer types can be customized:
+
** all kinds of `heatmap`: the cell colors can be set by the Javascript code,
+
** all kinds of charts: options can be used to set the chart’s size.

.Custom Options
image::pivot_template_custom_properties.png[align="center"]

[[table_output]]
==== Table Formatter

Table output does not require the report template, as the data will be displayed on a special screen of the application.

To use table formatter, select *Table* as the output type in the report template editor.

.Table Formatter
image::report_table_output.png[align="center"]

The report generator will get the band data and draw a sortable table for each band from first level of the hierarchy.

The table displays columns for all properties for SQL, JPQL datasets. If the Entity/List of Entities dataset is used, the table will display only the columns for selected attributes.

Resulting table is displayed in the *Reports > Show Report Table* screen of your web application. The *Excel* button enables you to download the displayed table as an Excel file.

.Show Report Table
image::show_report_table.png[align="center"]

[[template_to_output]]
==== Output format compliance matrix

[options="header"]
|===============
|Template / Output|XLSX|XLS|CSV|DOCX|DOC|PDF  |HTML |Chart
|XLSX             |+   |   |+  |    |   |+ ^1^|+ ^1^|
|XLS              |    |+  |   |    |   |+ ^1^|     |
|CSV              |    |   |+  |    |   |     |     |
|DOCX             |    |   |   |+   |   |+ ^2^|+ ^2^|
|DOC              |    |   |   |    |  +|+ ^1^|     |
|HTML             |    |   |   |    |   |+    |+    |
|Chart            |    |   |   |    |   |     |     |+
|JRXML            |+   |+  |+  |+   |+  |+    |+    |
|===============

^1^ - OpenOffice/LibreOffice must be <<open_office,installed>> for output.

^2^ - depending on the <<reporting.openoffice.docx.useOfficeForDocumentConversion,reporting.openoffice.docx.useOfficeForDocumentConversion>> application property, the output can be performed with or without OpenOffice/LibreOffice. In the latter case, you need to provide required fonts, as described in <<html_to_pdf>>.

[[parameters]]
=== External Report Parameters

External parameters are passed from the outside when running a report and can be used as conditions in datasets. All external parameters become fields for each report band, so you can use them directly in the template as dataset fields. If any dataset contains field with the same name, it overrides the external parameter in the corresponding band and the report uses the dataset field value.

You can describe the external parameters in the *Parameters and Formats* tab of the report editor. The form for adding parameters is provided below:

.External Report Parameters
image::report_parameter.png[align="center"]

*Properties* tab:

* *Caption* - parameter name, as it will appear in the parameter input form when running the report.
* *Parameter alias* - parameter alias used to access it in datasets.
* *Parameter type* - parameter type.
* *Hidden* - flag that defines whether the request for parameter should be hidden from users.
* *Required parameter?* - flag determining if the parameter is mandatory.
* *Entity* - if the *Entity* or *List of entities* of entities parameter type is selected, then you need to select the entity type in this field.
* *Entity selection screen* - optional screen identifier, which will be used to select entity instances. If the screen is not specified, selection will be made from a special screen generic for all entities.
* *Enumeration* - if the *Enumeration* parameter type is specified, then you need to select the enumeration type in this field.
* *Default value* - defines the parameter value that will be used by default if no other value is selected by the user.
* *Default date(time) is current* - if the temporal parameter type is specified (`Date`, `Time` or `Date and time`), this flag defines whether the current timestamp will be used as the default parameter value.

In the *Localization* tab, you can define the parameter name for different locales. In order to do this, you should enter the `++locale_name = parameter_name++` pairs, for example:

[source, properties]
----
ru = Книга
----

[[report_parameter_transformation]]
Input parameters transformation::
+
--
The *Transformation* tab allows you to apply a Groovy script on the parameter before using it in the report.

A Groovy script should return new parameter value. Current parameter value is available in the script by the `paramValue` alias, the parameters map is available by alias `params`. For example:

[source, plain]
----
return "%" + paramValue + "%"
----

You can also use one predefined transformations that add wildcards for text (String) parameters:

* `Starts with`,

* `Ends with`,

* `Contains`.

.Input parameters transformation
image::report_parameter_transformation.png[align="center"]
--

In the *Validation* tab, you can define a Groovy scripts with some condition for the parameter validation, see the details below.

[[report_parameter_validation]]
Input parameters validation::
+
--
You can validate an input parameter and/or define the cross-parameter validation.

. You can enable validation of each parameter in the *Validation* tab of parameter editor by checking the *Validate* checkbox. The validation logic is specified by a Groovy script. The script should check the parameter value and call the `invalid()` method if the value is not valid. This method will show the user an alert with the given message about the report validation errors.
+
The following variables are passed into the script:
+
* `value` - the parameter value entered by the user.
+
* `dataManager` - an object of the `DataManager` type that provides CRUD functionality.
+
* `metadata` - an object of the `Metadata` type that provides access to the application metadata.
+
* `security` - an object of the `Security` type used to check user access rights to different objects in the system.
+
* `userSession` - an object of the `UserSession` type associated with the currently authenticated user.
+
.Input parameters validation
image::report_parameter_validation.png[align="center"]

. Cross-parameter validation can be enabled by checking the *Validate* checkbox in the *Cross parameters validation* section of the *Parameters and Formats* tab. The validation logic is specified by a Groovy script. The script should check whether or not parameter values make sense in relation to each other and call the `invalid()` method if they do not. This method will show the user an alert with the given message about the report validation errors.
+
In addition to the variables listed above, the `params` variable is passed into the script to access the external report parameters map.
+
.Cross-parameter validation
image::cross_parameter_validation.png[align="center"]
--

[[formatters]]
=== Field Value Formats

You can specify the formatting for any field output by the report in the *Parameters and Formats* tab of the report editor. Below is the form to add a format:

.Field Value Formats
image::report_formatter.png[align="center"]

* *Value name* - report field name with the band prefix, for example `Book.name`.
* *Format string* - field format. For number values, you must specify the format according to the `java.text.DecimalFormat` rules, for dates - `java.text.SimpleDateFormat`.

With the help of formats, it is possible to insert images and HTML blocks into the document.

* In order to insert an image, you must specify the image URL as the field value and the format string must be as follows: `${image:<Width>x<Height>}`, for example `${image:200x300}`.
+
To work with the the `FileDescriptor`, you can use the `${imageFileId:WxH}` value formatter that accepts both the `FileDescriptor` `id` and the link to the `FileDecriptor` instance itself.

* In order to insert an HTML block, you should return an HTML markup in the field, and select `${html}` as the format string. In the output value, you may omit top-level tags up to `<body>` inclusive. If necessary, all missing top-level tags will be added automatically. All blocks should be encoded with `UTF-8`. CSS and the `style` attribute are not supported.

You can specify your own custom formats as well. To do this, type the new value in the field without opening the dropdown and press Enter. You can also choose any format from the dropdown, edit its name in the field and press Enter. Custom format will be saved in both cases.
[[permissions]]
=== Report Access Rights

You can define user rights to access the report as well as report availability in certain application screens in the *Roles and Screens* tab of the report editor.

If the report roles list contains at least one role, the report will be available only to users with this role. If no roles are specified, the report is available to everyone.

The screens list allows to specify, which screens the report will be available in when invoking `RunReportAction`, `TablePrintFormAction` or `EditorPrintFormAction` <<run_actions, actions>>. If no screen is specified, the report won't be available from any screen.

[[localization]]
=== Report Name Localization

You can localize the report name - show the name in the language, which the user is logged in with, in the report list. In order to do this, you need to go to the *Localization* tab and enter pairs, `++locale_name = report_name++`, as separate lines in the text field, for example:

[source, properties]
----
en = Books by author
ru = Книги по автору
----
[[creation]]
== Создание отчетов

Создание отчета в системе заключается в создании двух взаимосвязанных элементов: шаблона визуального представления и описания извлекаемых для отчета данных. Шаблон создается в формате XLS(X), DOC(X), HTML внешними средствами, а описание данных отчета производится в экране дизайнера отчетов.

Сгенерированный отчет в зависимости от заданных при описании параметров исходного шаблона может быть выдан в форматах PDF, XLS(X), DOC(X), HTML.

Структура данных, выводимых отчетом, может быть либо описана в дизайнере отчета путем создания полос, запросов и других элементов, либо запрограммирована в классе Java, реализующем специальный интерфейс. Отчет может принимать параметры от пользователя, либо из вызывающего кода. Для отчета можно задать, каким пользователям он доступен и в каких экранах системы он должен появляться.

Основные компоненты генератора отчетов приведены на следующей диаграмме:

image::reporting.png[align="center"]

* `YARG` - фреймворк, являющийся ядром генератора отчетов.

* `Report Engine` интегрирует фреймворк YARG в платформу CUBA и предоставляет дополнительную функциональность, такую как права доступа к отчетам и связь с экранами.

* `Report Designer` - средство описания и хранения отчетов. Включает в себя инфраструктуру хранения описаний и шаблонов отчетов, экраны создания и управления отчетами.

* `Report` - описатель структуры данных отчета, включающий в себя Bands - полосы отчета, и Datasets - наборы данных, выводимые в полосах.

* `Report Template` - шаблон визуального представления отчета.

[[structure]]
=== Структура данных отчета

Рассмотрим вкладку *Report structure* редактора отчета.

image::report_structure.png[align="center"]

В верхней части находятся поля ввода общих свойств отчета:

* *Name* - имя отчета. Имя может быть локализовано на вкладке *Localization*.

* *Group* - группа отчетов, применяется для группировки в общем списке браузера отчетов.

* *Default template* - <<template,шаблон>>, по которому будет выводиться отчет.

* *System code* - необязательный код отчета, по которому его можно при необходимости идентифицировать в программном коде системы.

Основным элементом структуры данных отчета является иерархия полос - *Report bands*.

Полоса отчета характеризуется следующими параметрами:

* *Band name* - уникальное в рамках отчета имя полосы. Должно содержать только латинские буквы, цифры или символ подчеркивания.

* *Orientation* - ориентация полосы: *Horizontal* или *Vertical*. Горизонтальные полосы в выводимом отчете копируются вниз, вертикальные - вправо. Горизонтальные полосы могут содержать вложенные полосы.

* *Parent band* - родительская полоса.

Каждая полоса включает в себя один или несколько наборов данных - Datasets. Наборы данных при выполнении отчета представляют собой списки строк, а каждая строка - набор пар имя-значение. Полоса выводится в отчет столько раз, сколько строк в ее самом длинном наборе данных. Имена полей указываются в шаблоне отчета, и при выводе полосы имена заменяются на соответствующие значения. При описании наборов данных можно использовать <<parameters,внешние параметры>> отчета, а также поля других полос - это позволяет делать полосы связанными.

В каждом отчете присутствует корневая полоса *Root*. В ней можно создавать наборы данных и ссылаться на их поля из других полос, однако использовать полосу *Root* в шаблоне нельзя.

Имя набора данных в колонке *Dataset name* не имеет значения и служит только для удобства пользователя.

Поле *Link field* позволяет объединять данные из нескольких наборов внутри одной полосы. Его можно использовать, когда невозможно получить полный набор данных в одном запросе или скрипте Groovy.

Далее рассмотрены возможные типы наборов данных.

[[structure_sql]]
==== Набор данных SQL

*SQL* - набор данных формируется выполнением SQL-запроса к базе данных. Поля результирующего набора запроса желательно снабдить алиасами с помощью оператора `as`. Для исключения возможного преобразования базой данных регистра символов алиасы желательно заключить в двойные кавычки:

[source, sql]
----
select u.name as "userName", u.login as "userLogin"
from sec_user u
----

В запросе можно использовать входные параметры отчета и поля родительских полос. К параметрам нужно обращаться по имени, заключенному в конструкцию `${}`, например `${dateFrom}`. К полям родительской полосы нужно обращаться аналогично, добавляя имя полосы перед именем поля: `${band1.field1}`.

Пример SQL-запроса с параметром `groupId`, полученным из родительской полосы `group`, и внешним параметром `active`:

[source, sql]
----
select u.name as "userName", u.login as "userLogin"
from sec_user u
where u.group_id = ${group.groupId}
    and u.active = ${active}
    and u.delete_ts is null
----

[WARNING]
====
В запросы на SQL необходимо вручную включать условия фильтрации мягко удаленных записей.
====

По умолчанию SQL-запросы выполняются в основной базе данных. Если необходимо выполнить запрос в дополнительном хранилище данных (см. Руководство по разработке приложений), в поле *Data store* необходимо указать его имя.

[[query_preprocessing]]
Препроцессор запросов::
+
--
Если вам нужно изменять запросы SQL/JPQL динамически в зависимости от значений параметров отчёта, можно использовать предварительную обработку SQL. Препроцессор позволяет модифицировать SQL/JPQL-запросы с помощью Groovy. Для активации препроцессора установите флажок *Preprocess query as Groovy template* под редактором полосы. Результирующий запрос будет обработан шаблонизатором `GStringTemplateEngine`, в котором доступны:

* параметры отчёта: `${<parameter_name>}`,

* значения из родительских полос: `{<band_name>.<parameter_name>}`.

Например, в зависимости от того, передан параметр запроса `createTs2` или нет, вам необходимо выбирать, какое из условий использовать в запросе: `e.create_ts < ${createTs2}` или `e.create_ts < current_timestamp`.

В этом случае запрос может выглядеть так:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
<% out << (createTs2 != null  ? 'e.create_ts < ${createTs2}' : 'e.create_ts < current_timestamp')%>
----

Теперь, если параметр `createTs2` не передан, исходный запрос будет преобразован в следующий:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < current_timestamp
----

Если же `createTs2` передан, для формирования полосы будет использован следующий результирующий запрос:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < ${createTs2}
----
--

[[structure_jpql]]
==== Набор данных JPQL

*JPQL* - набор данных формируется выполнением JPQL-запроса к базе данных. Поля результирующего набора запроса необходимо снабдить алиасами с помощью оператора `as`. В JPQL-запросе можно использовать входные параметры отчета и поля родительских полос аналогично описанному для SQL-запроса.

Пример JPQL-запроса с параметром `groupId`, полученным из родительской полосы `group`, и внешним параметром `active`:

[source, groovy]
----
select u.name as userName, u.login as userLogin
from sec$User u
where u.group.id = ${group.groupId}
    and u.active = ${active}
----

Запросы на JPQL автоматически поддерживают мягкое удаление и возвращают только неудаленные записи.

Также вы можете использовать <<query_preprocessing,препроцессор запросов>>, установив флажок *Preprocess query as Groovy template* под редактором полосы.

По умолчанию JPQL-запросы выполняются по сущностям основной базы данных. Если необходимо выполнить запрос к сущностям дополнительного хранилища (см. Руководство по разработке приложений), в поле *Data store* необходимо указать его имя.

[[structure_groovy]]
==== Набор данных Groovy

*Groovy* - набор данных формируется выполнением Groovy-скрипта. Скрипт должен возвращать объект типа `List<Map<String, Object>>`. Элемент этого списка, то есть объект типа `Map<String, Object>` соответствует одной записи набора данных.

В скрипт передаются следующие объекты:

* `dataManager` - объект типа `com.haulmont.cuba.core.global.DataManager`, предоставляющий CRUD-функциональность для работы с персистентными хранилищами данных. Например:
+
[source, groovy]
----
LoadContext<Book> loadContext = LoadContext.create(Book.class)
        .setId(bookId)
        .setView("book.edit")
def book = dataManager.load(loadContext)
----

* `metadata` - объект типа `com.haulmont.cuba.core.global.Metadata`, позволяющий обращаться к метаданным приложения, например:
+
[source, groovy]
----
def metaClass = metadata.getClassNN('sec$User')
----

* `params` - мэп внешних параметров отчета. Пример получения значения параметра:
+
[source, groovy]
----
def active = params['active']
----

* `parentBand` - родительская полоса в виде объекта типа `com.haulmont.yarg.structure.BandData`. Через этот объект методом `getParameterValue()` можно получить значение поля родительской полосы, например:
+
[source, groovy]
----
def groupId = parentBand.getParameterValue('groupId')
----

* `persistence` - объект типа `com.haulmont.cuba.core.Persistence`, позволяющий управлять транзакциями и получать ссылку на `EntityManager`. Например:
+
[source, groovy]
----
def tx = persistence.createTransaction()
try {
    def em = persistence.getEntityManager()
    def query = em.createQuery('select g from sec$Group g')
...
    tx.commit()
} finally {
    tx.end()
}
----
+
Для работы с дополнительным хранилищем данных, его имя нужно указать в параметре методов `createTransaction()` и `getEntityManager()`. По умолчанию используется основная база данных.
+
[source, groovy]
----
def tx = persistence.createTransaction('myStore')
try {
    def em = persistence.getEntityManager('myStore')
...
    tx.commit()
} finally {
    tx.end()
}
----

* `security` -  объект типа `com.haulmont.cuba.core.global.Security`, используемый для проверки прав пользователя на доступ к различным объектам системы. Пример использования:
+
[source, groovy]
----
if (security.isEntityOpPermitted(Book.class, EntityOp.READ) {
    ...
}
----

* `timeSource` - объект типа `com.haulmont.cuba.core.global.TimeSource`, используемый для получения текущего времени, например:
+
[source, groovy]
----
def currentDate = timeSource.currentTimestamp()
----

* `transactional` - метод, принимающий на вход замыкание, которое нужно выполнить в новой транзакции. Параметром замыкания становится текущий `EntityManager`. Пример использования:
+
[source, groovy]
----
transactional { em ->
    def query = em.createQuery('select g from sec$Group g')
    ...
}
----
+
Пример Groovy-скрипта извлечения пользователей по группе, выводимой в родительской полосе и по внешнему параметру `active`:
+
[source, groovy]
----
def result = []
transactional { em ->
    def query = em.createQuery('select u from sec$User u where u.group.id = ?1 and u.active = ?2')
    query.setParameter(1, parentBand.getParameterValue('groupId'))
    query.setParameter(2, params['active'])
    query.resultList.each { user ->
        result.add(['userLogin': user.login, 'userName': user.name])
    }
}
return result
----

* `userSession` - объект типа `com.haulmont.cuba.security.global.UserSession`, связанный с текущим пользователем системы, например:
+
[source, groovy]
----
def user = userSession.currentOrSubstitutedUser
----

* `userSessionSource` - объект типа `com.haulmont.cuba.core.global.UserSessionSource`, используемый для получения текущей сессии пользователя. Пример использования:
+
[source, groovy]
----
def locale = userSessionSource.locale
----

[TIP]
====
Для обращения к любым бинам Spring среднего слоя можно использовать статические методы класса `AppBeans`, например:

[source, groovy]
----
def myService = com.haulmont.cuba.core.global.AppBeans.get('sample_MyService')
----
====

[[structure_entity]]
==== Набор данных Entity

*Entity* - набор данных состоит из одной строки и формируется по атрибутам одного экземпляра сущности и связанных с ним сущностей.

Источником данных является внешний параметр типа *Entity*, который должен быть описан на вкладке *Parameters and Formats*. Значение в поле *Entity parameter name* должно соответствовать имени параметра.

Шаблон отчета должен содержать поля с именами атрибутов сущности. Атрибуты, используемые в шаблоне, необходимо указать в специальном окне, вызываемом кнопкой *Entity attributes*.

[[structure_list]]
==== Набор данных List of entities

*List of entities* - набор данных формируется по списку экземпляров сущности.

Источником данных является внешний параметр типа *List of entities*, который должен быть описан на вкладке *Parameters and Formats*. Значение в поле *Entity parameter name* должно соответствовать имени параметра.

Шаблон отчета должен содержать поля с именами атрибутов сущности. Атрибуты, используемые в шаблоне, необходимо указать в специальном окне, вызываемом кнопкой *Select entity attributes*.


[[structure_json]]
==== Набор данных JSON

*JSON* - набор данных формируется из данных в формате JSON, которые могут быть получены из следующих источников:

. *Groovy script*
+
--
Скрипт задаётся пользователем и должен возвращать JSON как строку, например:

[source, plain]
----
include::{sourcesdir}/json.groovy[]
----
--

. *URL*
+
--
Генератор отчётов запрашивает данные через URL с помощью GET HTTP-запроса, например:

[source, plain]
----
https://jsonplaceholder.typicode.com/users
----
--

. *Parameter*
+
--
Внешний параметр отчёта с типом String, содержащий данные JSON, можно создать на вкладке *Parameters and Formats* редактора отчётов.
--

Извлечь необходимые данные из полученного дерева JSON можно запросом JsonPath. К примеру, выражение `$.store.book[*]` вернёт все книги из дерева JSON в следующем примере:

[source, json]
----
include::{sourcesdir}/json.json[]
----

Более подробно о выражениях JsonPath можно посмотреть на http://goessner.net/articles/JsonPath/.

[[template]]
=== Шаблон отчета

Для одного отчета на вкладке *Templates* редактора отчета может быть создано несколько шаблонов, и один из них должен быть выбран как шаблон по умолчанию на вкладке *Report structure*.

Рассмотрим форму добавления шаблона:

image::report_template.png[align="center"]

* *Template code* - код шаблона для его идентификации.

* *Output type* - тип вывода отчета. Должен быть согласован с типом файла шаблона по правилам, описанным в секции <<template_to_output>>.

* *Template file* - файл шаблона, который загружается из файловой системы и сохраняется в базе данных вместе с описанием структуры отчета.

* *Output name pattern* - необязательное имя файла, которое будет использоваться для выгрузки готового отчета.
Паттерн имени файла может быть как постоянной строкой, так и содержать параметры отчёта в качестве переменных, например, `${header.authorName}.xlsx`. Более сложные паттерны с несколькими параметрами и конкатенацией строк можно также создать скриптом в любой полосе в структуре отчёта, например, `${Root.title}.xlsx`, где `title` является результатом следующего скрипта:
+
[source, groovy]
----
[['title' : ('Report for '+params['author'].firstName+' '+params['author'].lastName)]]
----

* *Defined with class* - признак использования шаблона, <<template_custom,определяемого классом>>.

* *Custom class name* - имя класса шаблона, если установлен признак *Defined with class*.

[[template_xls]]
==== Шаблоны XLSX и XLS

Шаблоны XLSX и XLS создаются с помощью *Microsoft Office* или *LibreOffice*.

Для каждой полосы отчета в шаблоне должен быть определен регион с именем полосы. К примеру, если отчёт содержит две полосы - Header и Data, то шаблон отчёта также должен содержать именованные регионы Header и Data.  Именованные регионы создаются путем выделения нужного диапазона ячеек и ввода имени в поле в левом верхнем углу приложения. Для редактирования уже созданных именованных регионов в Microsoft Office используется команда меню *Formulas* -> *Name Manager*, а в OpenOffice команда *Insert* -> *Names* -> *Manage*.
И, напротив, каждый элемент шаблона, который необходимо отобразить, должен быть создан как полоса в структуре отчёта, даже если эта полоса будет пустой.

Полосы выводятся в том порядке, в котором заданы в <<structure,структуре отчета>>.

Полосы могут быть горизонтальными и вертикальными. В горизонтальных полосах именованные регионы будут заполняться вниз, в вертикальных - вправо. Горизонтальные полосы могут быть организованы в древовидную структуру и содержать вложенные (или дочерние) полосы.  Поэтому для вложенных полос необходимо создавать именованные регионы непосредственно под регионами, соответствующими родительским полосам.
Отрисовка полос в XLSX происходит по следующему алгоритму:

* Создание первого ряда родительской полосы ->
* Создание всех дочерних полос первого ряда ->
* Создание следующего ряда родительской полосы.

Поля наборов данных полосы размечаются в шаблоне с помощью строк вида `++${field_name}++`, где `++field_name++` - имя поля. Например:

image::report_template_xls.png[align="center"]

В шаблон отчёта также можно включать переменные. Переменные вставляются в имя листа XLSX или его заголовки/подписи в следующем формате: `++${<BandName>.<variableName>}++`.

Ячейки могут содержать форматирование и сразу несколько полей внутри. Для вывода картинок или формул их нужно целиком поместить в соответствующий именованный регион.

Формулы могут ссылаться на свою полосу или другие полосы в шаблоне. Чтобы формулы обрабатывались генератором отчётов, они должны принимать диапазон ячеек полосы или явные координаты ячеек, например, `(A1*B1)` или `($B:$B)`.

Для создания диаграммы в шаблоне Excel необходимо создать полосу и именованный регион с тем же названием, затем выбрать в контекстном меню диаграммы пункт *"Выбрать данные"*, где указать ссылку на необходимые полосы отчёта. Если данные для диаграммы находятся в непрерывном диапазоне ячеек, можно выбрать любую ячейку в этом диапазоне, так в диаграмму будут включены все данные в диапазоне. Если данные находятся в прерывном диапазоне, выберите несмежные ячейки или диапазоны (при этом область выделения должна быть в виде прямоугольника).

Конвертация XLSX в PDF и CSV::
+
--
Для отчётов в формате XLSX поддерживается автоматическая конвертация в форматы CSV и PDF. Чтобы выбрать выходной тип файла PDF, необходимо установить <<open_office,OpenOffice/LibreOffice>>.

image::csv_output.png[align="center"]
--

[[crosstab_xls]]
===== Перекрёстные отчёты

Перекрёстные, или матричные, отчёты создаются с помощью Microsoft Office или LibreOffice.

Шаблон такого отчёта должен содержать горизонтальную полосу с вертикальной вложенной полосой, и не наоборот, так как вложенные (или дочерние) полосы обрабатываются генератором отчётов только для горизонтальных родительских полос. Результаты в родительской полосе будут использоваться дочерней полосой в качестве параметров запроса.

Ниже приведён пример шаблона, выводящего по вертикали список имён `Operators` и горизонтально количество `Calls` каждого оператора, сгрупированное по датам звонков.

image::crosstab_template.png[align="center"]

Вертикальная полоса `DataHeader` заполняет отчёт датами вправо:

[source, sql]
----
include::{sourcesdir}/crosstab_template_1.jpql[]
----

Горизонтальная полоса `Operators` выводит имена операторов сверху вниз:

[source, sql]
----
include::{sourcesdir}/crosstab_template_2.jpql[]
----

Дочерняя вертикальная полоса `Data` использует `id` операторов из результатов родительской полосы как параметр для заполнения матрицы:

[source, groovy]
----
include::{sourcesdir}/crosstab_template_3.groovy[]
----

В результате, отчёт заполняется как вниз по вертикали, так и вправо по горизонтали:

image::crosstab_report.png[align="center"]

[[template_csv]]
==== Шаблоны CSV

Шаблоны CSV создаются с помощью Microsoft Office или LibreOffice.

Полосы в CSV-шаблоне должны быть горизонтальными, таким образом, именованные регионы будут заполняться вниз. Также полосы должны располагаться на первом уровне данных, то есть быть дочерними для Root. Во всём остальном при создании шаблонов CSV применяются те же принципы, что и для <<template_xls,шаблонов XLS/XLSX>>.

.Пример шаблона CSV
image::csv_template.png[align="center"]

.Результат отчёта CSV
image::csv_report.png[align="center"]

[[template_doc]]
==== Шаблоны DOCX, DOC и ODT

Шаблоны DOC и DOCX создаются с помощью Microsoft Office или OpenOffice / LibreOffice.

Шаблон данного типа включает в себя текст документа и опционально одну или несколько таблиц. В тексте документа выводятся данные из первых строк произвольных полос. В таблицу можно выводить произвольное количество строк некоторой полосы.

Для вывода поля в тексте документа необходимо использовать строку вида `++${band_name.field_name}++`, где `++band_name++` - имя полосы, `++field_name++` - имя поля.

Для вывода данных в таблицу она должна быть привязана к некоторой полосе. Это делается путем указания в первой ячейке таблицы строки вида `++##band=band_name++`, где `++band_name++` - имя полосы. Поля в таблице размечаются строками вида `++${field_name}++`, где `++field_name++` - имя поля связанной с таблицей полосы. Для обращения к полям других полос в таблице можно использовать префикс с именем полосы, как это делается в полях текста документа. В одной ячейке таблицы можно выводить несколько полей.

Вложенные гризонтальные полосы в формате DOCX и DOC не поддерживаются. Если вложенные полосы вам необходимы, предпочтительно использовать XLS(X)-шаблоны.
[WARNING]
====
Таблица должна содержать либо одну, либо две строки. Если строк в таблице две, то поля связанной полосы должны находиться во второй строке. В первую заносится маркер с именем связанной полосы и, при необходимости, статический текст и поля других полос.
====

Например, для вывода отчета, состоящего из двух полос: `Book` и `Authors`, первая из которых выводит название и жанр книги, а вторая список авторов этой книги, шаблон может выглядеть следующим образом:

image::report_template_doc.png[align="center"]

[WARNING]
====
Формат ячеек для шаблонов DOCX и DOC не поддерживается. Рекомендуется приводить данные к строке в запросе. Например, для значения

[source, sql]
----
select e.year as "year"
----

можно выполнить следующее приведение:

[source, sql]
----
select cast(e.year as varchar(4)) as "year"
----
====

[[template_html]]
==== Шаблон HTML

Шаблон HTML задается в файле c расширением .html в кодировке `UTF-8` (без `BOM`). При создании HTML/CSS шаблона вы можете пользоваться библиотекой https://github.com/flyingsaucerproject/flyingsaucer[Flying Saucer], руководство по её использованию находится по адресу http://flyingsaucerproject.github.io/flyingsaucer/r8/guide/users-guide-R8.html

Размер страницы, наличие и расположение хэдеров и футеров можно настроить с помощью CSS. Пример отчёта с повторяющимися блоками хэдера и футера доступен в разделе <<example_html,Примеры отчётов>>.

Для размещения данных необходимо использовать тэги *FreeMarker* (документация по FreeMarker находится по адресу http://freemarker.org/docs).

Модель документа FreeMarker имеет следующую структуру:

[source, groovy]
----
Band {
      bands [ bandName : [ band, .. ], .. ]
      fields [ fieldName : fieldValue, .. ]
}
----

Например, для доступа к полю `name` в полосе `band` в нулевой строке выборки нужно использовать следующее выражение:

[source, groovy]
----
Root.bands.band[0].fields.name
----

Для удобства можно использовать переменные:

[source, html]
----
<#assign headerRow = Root.bands.Header[0]>
<p>Date: ${headerRow.fields.reportDate}</p>
----

Пример шаблона для вывода отчета, состоящего из двух полос: `Book` и `Authors`, первая из которых выводит название и жанр книги, а вторая список авторов этой книги:

[source, html]
----
include::{sourcesdir}/examples_html_6.html[]
----

Более сложный пример. Имеем структуру полос следующего вида:

[source, groovy]
----
Root {
    HeaderBand {
        query = return [[ "name" : "Column1" ],[ "name" : "Column2" ]]
    }
    Band1 {
        query = return [
            ["field1" : "Value 11", "field2" : "Value 12"],
            ["field1" : "Value 21" , "field2" : "Value 22"]
        ]
    }
    Band2 {
        query = return [[ "header" : "Header1" ], [ "header" : "Header2" ]]
        SubBand1 {
            query = return [["header" : 'SubHeader1'] , [ "header" : 'SubHeader2' ]]
        }
    }
}
----

* Обращение к полю:
+
[source, html]
----
include::{sourcesdir}/examples_html_8.html[]
----

* Список:
+
[source, html]
----
include::{sourcesdir}/examples_html_9.html[]
----

* Таблица:
+
[source, html]
----
include::{sourcesdir}/examples_html_10.html[]
----

* Многоуровневый список:
+
[source, html]
----
include::{sourcesdir}/examples_html_11.html[]
----

*Добавление изображений*

В настоящий момент генератор отчётов CUBA не позволяет вставлять изображения в HTML-отчёты так же, как это реализовано для шаблонов DOCX/XLSX. Тем не менее, изображения можно добавить, используя тег `img` со ссылкой на изображение в атрибуте `src`. Есть два способа вставки изображений в HTML-шаблон:

* по URL
+
Изображения могут храниться на сервере Tomcat или любом другом хостинге. К примеру, для вставки изображения, хранящегося в `deploy\tomcat\webapps\ROOT\images`, используется следующий код:
[source, html]
----
<img src="http://localhost:8080/images/SomeImage.jpg" height="68" width="199" border="0" align="right"/>
----

* с использованием Bitmap
+
Ссылка на изображение в виде байтового массива вставляется в атрибут `src`. В этом случае удобно использовать переменные для атрибутов сущностей, являющихся ссылкой на `FileDescriptor`. Строку `ByteArray` можно вставить в атрибут и напрямую, однако мы не рекомендуем этот подход к использованию:
[source, html]
----
<img alt="SomePicture.png" src="data:image/png;base64,iVBORw0K ..... AcEP9PwxD0hNKK1FCAAAAAElFTkSuQmCC"/>
----

[[html_to_pdf]]
===== Преобразование HTML в PDF

Отчеты, имеющие формат шаблона HTML и формат вывода PDF, не всегда корректно отображают шрифты. Для решения этой проблемы добавьте в конфигурационный каталог блока Middleware (в стандартном варианте развертывания tomcat/conf/app-core) подкаталог cuba/fonts с необходимыми .ttf-шрифтами. Кроме того, можно использовать имеющиеся в операционной системе шрифты путем указания пути к ним в свойстве приложения <<reporting.fontsDir,reporting.fontsDir>>.

Для решения проблемы со шрифтами на сервере Ubuntu необходимо выполнить следующее:

* Установить пакет ttf-mscorefonts-installer:
+
`$ sudo apt-get install ttf-mscorefonts-installer`

* Установить свойство приложения <<reporting.fontsDir,reporting.fontsDir>>:
+
[source, plain]
----
reporting.fontsDir = /usr/share/fonts/truetype/msttcorefonts
----

* В HTML-шаблонах использовать явное указание шрифтов, например так:
+
[source, html]
----
<html>
<head>
    <style type="text/css">
        * {
            font-family: Times New Roman;
        }
    </style>
----

Стоит также позаботиться об экранировании спецсимволов. Чтобы избежать ошибок при конвертации HTML в PDF, рекомендуется обернуть поля в HTML шаблоне в конструкцию `<![CDATA[ ]]>`:
[source, html]
----
<tr>
	<td> <![CDATA[${(row.fields('book_name'))!?string!}]]> </td>
	<td> <![CDATA[${(row.fields('author'))!?string!}]]> </td>
</tr>
----

[[template_custom]]
==== Шаблон, определяемый классом

Шаблоны, определяемые классом используются в тех случаях, когда выбирать данные с помощью SQL, JPQL или Groovy слишком сложно или невозможно. Например, в случаях, когда отчет представляет собой результат объединения нескольких других отчетов.

Класс, определяющий шаблон должен реализовывать интерфейс `com.haulmont.yarg.formatters.CustomReport`. В классе необходимо определить метод `createReport()`, возвращающий массив байтов и принимающий на вход параметры:

* `report` - описатель отчета типа `com.haulmont.yarg.structure.Report`.

* `rootBand` - данные корневой полосы типа `com.haulmont.yarg.structure.BandData`.

* `params` - мэп внешних параметров отчета.

Ниже приведен пример простого шаблона, определяемого классом. Он формирует HTML-документ с названием выбранной в параметре отчета книги:

[source, java]
----
package com.sample.library.report;

import com.haulmont.yarg.formatters.CustomReport;
import com.haulmont.yarg.structure.BandData;
import com.haulmont.yarg.structure.Report;
import com.sample.library.entity.Book;
import java.util.Map;

public class BookReport implements CustomReport {
    @Override
    public byte[] createReport(Report report, BandData rootBand, Map<String, Object> params) {
        Book book = (Book) params.get("book");
        String html = "<html><body>";
        html += "<p>Name: " + book.getName() + "</p>";
        html += "</body></html>";
        return html.getBytes();
    }
}
----

[[template_chart]]
==== Шаблон-диаграмма

Шаблон-диаграмма доступен, если проект приложения включает компонент *charts*. Результирующая диаграмма выводится в экране *Reports* -> *Show Charts* веб-приложения.

Поддерживаются два типа диаграмм: круговая и серийная. Каждый тип имеет свой набор параметров, настраиваемый в экране редактирования шаблона.

Круговая диаграмма:

image::chart_template_pie.png[align="center"]

* *Band name* - полоса, предоставляющая данные для диаграммы.
* *Title field* - поле, из которого будут взяты названия сегментов.
* *Value field* - поле, из которого будут взяты значения сегментов.
* *Color field* - поле, из которого будут взяты коды цветов сегментов. Код цвета должен быть в https://en.wikipedia.org/wiki/Web_colors[web] формате. Если код цвета не предоставлен, он будет выбран автоматически.
* *Units* - данный текст будет добавлен к значениям в легенде.

Серийная диаграмма:

image::chart_template_serial.png[align="center"]

* *Band name* - полоса, предоставляющая данные для диаграммы.
* *Category field* - поле, из которого будут взяты названия категорий.
* *Category axis caption* - заголовок для горизонтальной оси.
* *Value axis caption* - заголовок для вертикальной оси.
* *Value axis units* - данный текст будет добавлен к значениям.

Для серийной диаграммы необходимо задать описание как минимум одного ряда:

* *Value field* - поле, из которого будут взяты значения.
* *Type* - вид отображения ряда.
* *Color field* - поле, из которого будут взяты коды цветов сегментов. Код цвета должен быть в https://en.wikipedia.org/wiki/Web_colors[web] формате. Если код цвета не предоставлен, он будет выбран автоматически.

[[table_output]]
==== Вывод отчёта в виде таблицы

Для всех отчётов доступен вывод в виде таблицы. Для его использования выберите *Table* в поле формата вывода в редакторе шаблона отчёта.

image::report_table_output.png[align="center"]

Генератор отчётов получит данные из полос и создаст для каждой из них, начиная с первого уровня иерархии, сортируемую таблицу.

Если в отчёте использованы наборы данных SQL или JPQL, в таблице будут созданы колонки для всех полей. Для наборов данных Entity/List of Entities в таблице будут отображаться только колонки для выбранных в отчёте атрибутов. Кроме того, в последнем случае имена колонок необходимо локализовать.

Результирующая таблица будет отображаться на экране приложения *Reports > Show Report Table*. Кнопка *Excel* позволяет скачать таблицу с отчётом в формате файла Excel.

image::show_report_table.png[align="center"]

[[template_to_output]]
==== Соответствие типа шаблона типу вывода

[options="header"]
|===============
|Шаблон / Вывод|XLSX|XLS|CSV|DOCX|DOC|PDF  |HTML |Chart
|XLSX          |+   |   |+  |    |   |+ ^1^|+ ^1^|
|XLS           |    |+  |   |    |   |+ ^1^|     |
|CSV           |    |+  |+  |    |   |+ ^1^|     |
|DOCX          |    |   |   |+   |   |+ ^2^|+ ^2^|
|DOC           |    |   |   |    |  +|+ ^1^|     |
|HTML          |    |   |   |    |   |+    |+    |
|Chart         |    |   |   |    |   |     |     |+
|===============

^1^ - для вывода требуется <<open_office,установка>> OpenOffice/LibreOffice.

^2^ - в зависимости от значения свойства приложения <<reporting.openoffice.docx.useOfficeForPdfConversion,reporting.openoffice.docx.useOfficeForPdfConversion>> вывод может осуществляться либо через OpenOffice/LibreOffice, либо без него. В последнем случае необходимо обеспечить наличие нужных шрифтов, как описано в <<html_to_pdf>>.

[[parameters]]
=== Внешние параметры отчета

Внешние параметры передаются извне при запуске отчета и могут использоваться в наборах данных в качестве условий. Все внешние параметры становятся полями каждой полосы отчета, поэтому их можно непосредственно использовать в шаблоне как поля наборов данных. Если какой-либо набор данных выводит одноименное поле, оно маскирует внешний параметр в данной полосе и в отчете используется значение поля набора данных.

Для описания внешних параметров служит вкладка *Parameters and Formats* редактора отчета. Рассмотрим форму добавления параметра:

image::report_parameter.png[align="center"]

Вкладка *Properties*:

* *Caption* - имя параметра, как оно будет отображено в форме ввода параметров при старте отчета.
* *Parameter alias* - алиас параметра, который нужно использовать для обращения к нему в наборах данных.
* *Parameter type* - тип параметра.
* *Hidden* - признак того, что параметр является условием, скрытым от пользователей.
* *Required parameter?* - признак того, что параметр должен быть обязательно передан в отчет.
* *Entity* - если указан тип параметра *Entity* или *List of entities*, то в данном поле необходимо выбрать тип сущности.
* *Entity selection screen* - необязательный идентификатор экрана, который будет использоваться для выбора экземпляров сущности. Если экран не указан, выбор будет осуществляться через специальный общий для всех сущностей экран.
* *Enumeration* - если указан тип параметра *Enumeration*, то в данном поле необходимо выбрать тип перечисления.
* *Default value* - значение параметра, которое будет использовано по умолчанию, если пользователь не указал другого значения.
* *Default date(time) is current* -  если указан временной тип параметра (`Date`, `Time` или `Date and time`), этот флажок позволяет использовать текущее значение времени в качестве значения по умолчанию.

На вкладке *Localization* можно определить названия параметра для различных локалей. Для этого в отдельных строках текстового поля следует ввести пары `++имя_локали = имя_параметра++`, например:

[source, properties]
----
ru = Книга
----

На вкладке *Transformation* можно задать скрипт Groovy для преобразования параметра перед использованием его в отчёте.

На вкладке *Validation* можно задать Groovy-скрипт с некоторым условием для валидации значения параметра, см. ниже.

[[report_parameter_validation]]
Валидация внешних параметров::
+
--
Вы можете настроить как валидацию отдельных параметров, так и перекрёстную валидацию параметров относительно друг друга.

. Валидацию одного параметра можно разрешить, установив флажок *Validate* на вкладке *Validation* редактора параметров. Логика валидации задаётся в скрипте Groovy. Скрипт должен проверять значение параметра и вызывать метод `invalid()`, если введено некорректное значение. Метод отобразит пользователю уведомление с переданным сообщением об ошибке валидации.
+
В скрипте доступны следующие переменные:
+
* `value` - значение параметра, введённое пользователем.
+
* `dataManager` - объект типа `DataManager`, предоставляющий CRUD-функциональность для работы с персистентными хранилищами данных.
+
* `metadata` - объект типа `Metadata`, позволяющий обращаться к метаданным приложения.
+
* `security` - объект типа `Security`, используемый для проверки прав пользователя на доступ к различным объектам системы.
+
* `userSession` - объект типа `UserSession`, связанный с текущим пользователем системы.
+
image::report_parameter_validation.png[align="center"]

. Перекрёстную валидацию можно включить флажком *Validate* в разделе *Cross parameters validation* на вкладке *Parameters and Formats*. Логика валидации задаётся в скрипте Groovy. Скрипт должен проверить, не противоречат ли друг другу значения введённых параметров, и вызвать метод `invalid()`, если набор значений некорректен. Метод отобразит пользователю уведомление с переданным сообщением об ошибке валидации.
+
В скрипте доступны следующие переменные:
+
* `params` - набор значений параметров, введённый пользователем.
+
* `dataManager` - объект типа `DataManager`, предоставляющий CRUD-функциональность для работы с персистентными хранилищами данных.
+
* `metadata` - объект типа `Metadata`, позволяющий обращаться к метаданным приложения.
+
* `security` - объект типа `Security`, используемый для проверки прав пользователя на доступ к различным объектам системы.
+
* `userSession` - объект типа `UserSession`, связанный с текущим пользователем системы.
+
image::cross_parameter_validation.png[align="center"]
--

[[formatters]]
=== Форматы значений полей

Для любого поля, выводимого отчетом, можно задать форматирование на вкладке *Parameters and Formats* редактора отчета. Рассмотрим форму добавления формата:

image::report_formatter.png[align="center"]

* *Value name* - имя поля отчета с префиксом полосы, например `Book.name`.

* *Format string* - формат поля. Для числовых значений формат должен быть задан по правилам `java.text.DecimalFormat`, для дат - `java.text.SimpleDateFormat`.

Форматы позволяют вставлять в документ изображения и HTML-блоки.

* Для вставки изображения значение поля должно быть строкой URL для доступа к нему, а в формате значения строка форматирования должна иметь вид: `${image:<Width>x<Height>}`, например `${image:200x300}`.
+
Для изображений в формате `FileDescriptor` можно использовать формат `${imageFileId:WxH}`, который принимает как `FileDescriptor` `id`, так и ссылку на экземпляр самого `FileDecriptor`.

* Для вставки HTML-блока необходимо в поле возвращать HTML-разметку, а в формате значения выбрать `${html}` в качестве строки форматирования. В выходном значении тэги верхнего уровня до `<body>` включительно могут быть опущены. При необходимости произойдет автоматическое дополнение недостающих тегов верхнего уровня. Кодировка всех блоков `UTF-8`. CSS и атрибут `style` не поддерживаются.

Также есть возможность задать свой формат значений. Для этого нужно, не открывая список, ввести своё значение и нажать Enter. Также можно выбрать один формат из существующих, отредактировать его и нажать Enter. В обоих случаях значение сохранится.
[[permissions]]
=== Разграничение прав доступа к отчетам

На вкладке *Roles and Screens* редактора отчетов можно определить права пользователей на доступ к отчету, а также принадлежность отчета экранам системы.

Если в списке ролей для отчета указана хотя бы одна роль, то данный отчет будет доступен только пользователям с этой ролью. Если ни одна роль не указана, отчет доступен всем.

Список экранов позволяет определить, в каких экранах данный отчет доступен при использовании <<run_actions,действий>> `RunReportAction`, `TablePrintFormAction` или `EditorPrintFormAction`. Если ни один экран не указан, отчет недоступен из всех экранов.

[[localization]]
=== Локализация названия отчета

Название отчета можно локализовать, то есть в списке отчетов для запуска отображать название на языке, с которым пользователь вошел в систему. Для этого в редакторе отчета необходимо перейти на вкладку *Localization* и в отдельных строках текстового поля ввести пары `++имя_локали = название_отчета++`, например:

[source, properties]
----
en = Books by author
ru = Книги по автору
----